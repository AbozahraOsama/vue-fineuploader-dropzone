{"version":3,"sources":["webpack:///static/js/vendor.3e1f2576aadeeb10b05b.js","webpack:///./~/core-js/library/modules/_wks.js","webpack:///./~/core-js/library/modules/_global.js","webpack:///./~/core-js/library/modules/_an-object.js","webpack:///./~/core-js/library/modules/_core.js","webpack:///./~/core-js/library/modules/_descriptors.js","webpack:///./~/core-js/library/modules/_has.js","webpack:///./~/core-js/library/modules/_hide.js","webpack:///./~/core-js/library/modules/_object-dp.js","webpack:///./~/core-js/library/modules/_defined.js","webpack:///./~/core-js/library/modules/_export.js","webpack:///./~/core-js/library/modules/_fails.js","webpack:///./~/core-js/library/modules/_is-object.js","webpack:///./~/core-js/library/modules/_iterators.js","webpack:///./~/core-js/library/modules/_property-desc.js","webpack:///./~/core-js/library/modules/_shared-key.js","webpack:///./~/core-js/library/modules/_to-integer.js","webpack:///./~/core-js/library/modules/_to-object.js","webpack:///./~/babel-runtime/helpers/extends.js","webpack:///./~/core-js/library/modules/_cof.js","webpack:///./~/core-js/library/modules/_ctx.js","webpack:///./~/core-js/library/modules/_dom-create.js","webpack:///./~/core-js/library/modules/_enum-bug-keys.js","webpack:///./~/core-js/library/modules/_iobject.js","webpack:///./~/core-js/library/modules/_object-keys.js","webpack:///./~/core-js/library/modules/_set-to-string-tag.js","webpack:///./~/core-js/library/modules/_shared.js","webpack:///./~/core-js/library/modules/_to-iobject.js","webpack:///./~/core-js/library/modules/_to-length.js","webpack:///./~/core-js/library/modules/_uid.js","webpack:///./~/vue/dist/vue.runtime.common.js","webpack:///./~/vuex/dist/vuex.js","webpack:///./~/babel-runtime/core-js/array/from.js","webpack:///./~/babel-runtime/core-js/object/assign.js","webpack:///./~/babel-runtime/helpers/toConsumableArray.js","webpack:///./~/core-js/library/fn/array/from.js","webpack:///./~/core-js/library/fn/object/assign.js","webpack:///./~/core-js/library/modules/_a-function.js","webpack:///./~/core-js/library/modules/_array-includes.js","webpack:///./~/core-js/library/modules/_classof.js","webpack:///./~/core-js/library/modules/_create-property.js","webpack:///./~/core-js/library/modules/_html.js","webpack:///./~/core-js/library/modules/_ie8-dom-define.js","webpack:///./~/core-js/library/modules/_is-array-iter.js","webpack:///./~/core-js/library/modules/_iter-call.js","webpack:///./~/core-js/library/modules/_iter-create.js","webpack:///./~/core-js/library/modules/_iter-define.js","webpack:///./~/core-js/library/modules/_iter-detect.js","webpack:///./~/core-js/library/modules/_library.js","webpack:///./~/core-js/library/modules/_object-assign.js","webpack:///./~/core-js/library/modules/_object-create.js","webpack:///./~/core-js/library/modules/_object-dps.js","webpack:///./~/core-js/library/modules/_object-gops.js","webpack:///./~/core-js/library/modules/_object-gpo.js","webpack:///./~/core-js/library/modules/_object-keys-internal.js","webpack:///./~/core-js/library/modules/_object-pie.js","webpack:///./~/core-js/library/modules/_redefine.js","webpack:///./~/core-js/library/modules/_string-at.js","webpack:///./~/core-js/library/modules/_to-index.js","webpack:///./~/core-js/library/modules/_to-primitive.js","webpack:///./~/core-js/library/modules/core.get-iterator-method.js","webpack:///./~/core-js/library/modules/es6.array.from.js","webpack:///./~/core-js/library/modules/es6.object.assign.js","webpack:///./~/core-js/library/modules/es6.string.iterator.js","webpack:///./~/fine-uploader/all.fine-uploader/all.fine-uploader.js","webpack:///./~/fine-uploader/lib/all.js","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/vue-style-loader/addStyles.js"],"names":["webpackJsonp","module","exports","__webpack_require__","store","uid","Symbol","USE_SYMBOL","$exports","name","global","window","Math","self","Function","__g","isObject","it","TypeError","core","version","__e","Object","defineProperty","get","a","hasOwnProperty","key","call","dP","createDesc","object","value","f","anObject","IE8_DOM_DEFINE","toPrimitive","O","P","Attributes","e","undefined","ctx","hide","PROTOTYPE","$export","type","source","own","out","IS_FORCED","F","IS_GLOBAL","G","IS_STATIC","S","IS_PROTO","IS_BIND","B","IS_WRAP","W","expProto","target","C","b","c","this","arguments","length","apply","virtual","R","U","exec","bitmap","enumerable","configurable","writable","shared","ceil","floor","isNaN","defined","_interopRequireDefault","obj","__esModule","default","_assign","_assign2","i","prototype","toString","slice","aFunction","fn","that","document","is","createElement","split","cof","propertyIsEnumerable","$keys","enumBugKeys","keys","def","has","TAG","tag","stat","SHARED","IObject","toInteger","min","id","px","random","concat","_toString","val","JSON","stringify","String","toNumber","n","parseFloat","makeMap","str","expectsLowerCase","map","create","list","toLowerCase","remove$1","arr","item","index","indexOf","splice","hasOwn","isPrimitive","cached","cache","hit","bind$1","boundFn","l","_length","toArray","start","ret","Array","extend","to","_from","isPlainObject","OBJECT_STRING","toObject","res","noop","genStaticKeys","modules","reduce","m","staticKeys","join","looseEqual","isObjectA","isObjectB","looseIndexOf","isReserved","charCodeAt","parsePath","path","bailRE","test","segments","isNative","Ctor","pushTarget","_target","Dep","targetStack","push","popTarget","pop","protoAugment","src","__proto__","copyAugment","observe","asRootData","ob","__ob__","Observer","observerState","shouldConvert","isServerRendering","isArray","isExtensible","_isVue","vmCount","defineReactive$$1","customSetter","dep","property","getOwnPropertyDescriptor","getter","setter","set","childOb","depend","dependArray","newVal","notify","set$1","max","del","mergeData","from","toVal","fromVal","mergeHook","parentVal","childVal","mergeAssets","normalizeProps","options","props","camelize","normalizeDirectives","dirs","directives","bind","update","mergeOptions","parent","child","vm","mergeField","strat","strats","defaultStrat","extendsFrom","extends","mixins","mixin","Vue$2","resolveAsset","warnMissing","assets","camelizedId","PascalCaseId","capitalize","validateProp","propOptions","propsData","prop","absent","isType","Boolean","hyphenate","getPropDefaultValue","prevShouldConvert","$options","getType","match","len","resetSchedulerState","queue","has$1","waiting","flushing","flushSchedulerQueue","sort","watcher","run","devtools","config","emit","queueWatcher","nextTick","traverse","seenObjects","clear","_traverse","seen","isA","depId","add","initState","_watchers","opts","initProps","methods","initMethods","data","initData","_data","computed","initComputed","watch","initWatch","_propKeys","isRoot","$parent","loop","proxy","userDef","computedSharedDefinition","makeComputedGetter","owner","Watcher","lazy","dirty","evaluate","handler","createWatcher","$watch","stateMixin","Vue","dataDef","$set","$delete","expOrFn","cb","user","immediate","teardown","createTextVNode","VNode","cloneVNode","vnode","cloned","children","text","elm","context","componentOptions","ns","isStatic","isCloned","cloneVNodes","vnodes","mergeVNodeHook","hookKey","hook","injectedHash","__injected","oldHook","updateListeners","on","oldOn","remove$$1","cur","old","event","capture","once","charAt","invoker","arrInvoker","fnInvoker","ev","arguments$1","single","o","simpleNormalizeChildren","normalizeChildren","normalizeArrayChildren","nestedIndex","last","getFirstComponentChild","filter","initEvents","_events","_hasHookEvent","listeners","_parentListeners","updateComponentListeners","add$1","$once","$on","remove$2","$off","oldListeners","eventsMixin","hookRE","cbs","$emit","args","initLifecycle","abstract","$children","$root","$refs","_watcher","_inactive","_isMounted","_isDestroyed","_isBeingDestroyed","lifecycleMixin","_mount","el","hydrating","$el","render","createEmptyVNode","callHook","_update","_render","$vnode","prevEl","prevVnode","_vnode","prevActiveInstance","activeInstance","__patch__","_parentElm","_refElm","__vue__","_updateFromParent","parentVnode","renderChildren","hasChildren","_renderChildren","_parentVnode","propKeys","$slots","resolveSlots","$forceUpdate","$destroy","handlers","j","createComponent","baseCtor","_base","cid","resolved","resolveAsyncComponent","resolveConstructorOptions","extractProps","functional","createFunctionalComponent","nativeOn","mergeHooks","_context","h","d","slots","functionalContext","slot","createComponentInstanceForVnode","parentElm","refElm","vnodeComponentOptions","_isComponent","_componentTag","inlineTemplate","staticRenderFns","init","$mount","keepAlive","mountedNode","prepatch","oldVnode","insert","destroy$1","factory","requested","pendingCallbacks","sync","resolve","reject","reason","then","attrs","domProps","altKey","checkProp","hash","preserve","hooksToMerge","fromParent","ours","hooks","mergeHook$1","one","two","normalizationType","alwaysNormalize","ALWAYS_NORMALIZE","_createElement","scopedSlots","SIMPLE_NORMALIZE","getTagNamespace","isReservedTag","parsePlatformTagName","applyNS","initRender","_staticTrees","renderContext","$scopedSlots","_c","$createElement","renderMixin","markStatic","tree","isOnce","markStaticNode","node","$nextTick","ref","_renderProxy","errorHandler","_s","_v","_n","_e","_q","_i","_m","isInFor","_o","_f","identity","_l","_t","fallback","bindObject","scopedSlotFn","slotNodes","_b","asProp","mustUseProp","_k","eventKeyCode","builtInAlias","keyCodes","defaultSlot","isComment","initMixin","_init","_uid","initInternalComponent","constructor","_self","super","superOptions","cachedSuperOptions","extendOptions","_scopeId","components","initUse","use","plugin","installed","unshift","install","initMixin$1","initExtend","Super","SuperId","cachedCtors","_Ctor","Sub","_assetTypes","forEach","initAssetRegisters","definition","matches","pattern","initGlobalAPI","configDef","util","delete","builtInComponents","genClassForVnode","parentNode","childNode","mergeClassData","genClassFromData","staticClass","class","dynamicClass","stringifyClass","stringified","isSVG","isUnknownElement","inBrowser","unknownElementCache","HTMLUnknownElement","HTMLElement","query","querySelector","createElement$1","tagName","setAttribute","createElementNS","namespace","namespaceMap","createTextNode","createComment","insertBefore","newNode","referenceNode","removeChild","appendChild","nextSibling","setTextContent","textContent","registerRef","isRemoval","refs","refInFor","isUndef","s","isDef","sameVnode","vnode1","vnode2","createKeyToOldIdx","beginIdx","endIdx","createPatchFunction","backend","emptyNodeAt","nodeOps","createRmCb","childElm","removeNode","createElm","insertedVnodeQueue","nested","isRootInsert","setScope","createChildren","invokeCreateHooks","isReactivated","initComponent","reactivateComponent","innerNode","transition","activate","emptyNode","isPatchable","i$1","pendingInsert","addVnodes","startIdx","invokeDestroyHook","destroy","removeVnodes","ch","removeAndInvokeRemoveHook","rm","remove","updateChildren","oldCh","newCh","removeOnly","oldKeyToIdx","idxInOld","elmToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","canMove","patchVnode","hasData","postpatch","invokeInsertHook","initial","hydrate","hasChildNodes","childrenMatch","firstChild","isRenderedModule","hooks$1","isInitialPatch","isRealElement","nodeType","hasAttribute","removeAttribute","ancestor","updateDirectives","oldDir","dir","isCreate","isDestroy","oldDirs","normalizeDirectives$1","newDirs","dirsWithInsert","dirsWithPostpatch","oldValue","callHook$1","componentUpdated","inserted","callInsert","modifiers","emptyModifiers","getRawDirName","rawName","updateAttrs","oldAttrs","setAttr","isIE9","isXlink","removeAttributeNS","xlinkNS","getXlinkProp","isEnumeratedAttr","isBooleanAttr","isFalsyAttrValue","setAttributeNS","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","add$2","oldHandler","remove$3","target$1","addEventListener","removeEventListener","updateDOMListeners","updateDOMProps","oldProps","isDirty","_value","strCur","shouldUpdateValue","checkVal","composing","isInputChanged","activeElement","_vModifiers","number","trim","normalizeStyleData","style","normalizeStyleBinding","staticStyle","bindingStyle","parseStyleText","getStyle","checkChild","styleData","updateStyle","oldStaticStyle","oldStyleBinding","oldStyle","newStyle","setProp","addClass","classList","getAttribute","removeClass","tar","replace","nextFrame","raf","addTransitionClass","removeTransitionClass","whenTransitionEnds","expectedType","getTransitionInfo","timeout","propCount","TRANSITION","transitionEndEvent","animationEndEvent","ended","end","onEnd","setTimeout","styles","getComputedStyle","transitioneDelays","transitionProp","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationProp","animationDurations","animationTimeout","ANIMATION","hasTransform","transformRE","delays","durations","toMs","Number","enter","toggleDisplay","_leaveCb","cancelled","resolveTransition","_enterCb","css","enterClass","enterToClass","enterActiveClass","appearClass","appearToClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","transitionNode","isAppear","startClass","activeClass","toClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","expectsCSS","userWantsControl","show","pendingNode","_pending","leave","performLeave","beforeLeave","leaveClass","leaveActiveClass","leaveToClass","afterLeave","leaveCancelled","delayLeave","def$$1","autoCssTransition","called","_enter","_","setSelected","binding","isMultiple","multiple","selected","option","getValue","selectedIndex","hasNoMatchingOption","onCompositionStart","onCompositionEnd","trigger","createEvent","initEvent","dispatchEvent","locateNode","getRealChild","compOptions","extractTransitionData","comp","key$1","placeholder","rawChild","hasParentTransition","isSameChild","oldChild","callPendingCbs","_moveCb","recordPosition","newPos","getBoundingClientRect","applyTranslation","oldPos","pos","dx","left","dy","top","moved","transform","WebkitTransform","transitionDuration","_isServer","_Set","isBuiltInTag","camelizeRE","toUpperCase","hyphenateRE","no","optionMergeStrategies","silent","ignoredElements","_lifecycleHooks","_maxUpdateCount","hasProto","UA","navigator","userAgent","isIE","isEdge","isAndroid","isIOS","env","VUE_ENV","__VUE_DEVTOOLS_GLOBAL_HOOK__","nextTickHandler","pending","copies","callbacks","timerFunc","Promise","p","logError","err","console","error","catch","MutationObserver","counter","observer","textNode","characterData","_resolve","Set","formatComponentName","warn","uid$1","subs","addSub","sub","removeSub","addDep","arrayProto","arrayMethods","method","original","result","observeArray","arrayKeys","getOwnPropertyNames","isSettingProps","augment","walk","items","instanceData","defaultData","freeze","defineReactive","uid$2","deep","active","deps","newDeps","depIds","newDepIds","expression","cleanupDeps","this$1","tmp","raw","patternTypes","RegExp","KeepAlive","include","exclude","created","destroyed","testEl","acceptValue","attr","svg","math","isHTMLTag","baseModules","klass","events","cssText","listDelimiter","propertyDelimiter","cssVarRE","importantRE","setProperty","normalize","prefixes","upper","prefixed","hasTransition","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","requestAnimationFrame","platformModules","patch$1","vmodel","model","needReset","some","v","originalDisplay","__vOriginalDisplay","display","unbind","platformDirectives","transitionProps","mode","Transition","_leaving","oldRawChild","delayedLeave","moveClass","TransitionGroup","prevChildren","rawChildren","transitionData","kept","removed","c$1","beforeUpdate","updated","hasMove","body","offsetHeight","propertyName","_hasMove","info","platformComponents","devtoolPlugin","devtoolHook","_devtoolHook","targetState","replaceState","subscribe","mutation","state","applyMixin","vuexInit","$store","usesInit","beforeCreate","normalizeMap","normalizeNamespace","warnNamespace","helper","forEachValue","isPromise","assert","condition","msg","Error","targetModule","newModule","getChild","resetStore","_actions","_mutations","_wrappedGetters","_modulesNamespaceMap","installModule","_modules","root","resetStoreVM","oldVm","_vm","getters","wrappedGetters","strict","enableStrictMode","_withCommit","rootState","hot","getNamespace","parentState","getNestedState","moduleName","local","makeLocalContext","forEachMutation","namespacedType","registerMutation","forEachAction","action","registerAction","forEachGetter","registerGetter","forEachChild","noNamespace","dispatch","_type","_payload","_options","unifyObjectStyle","payload","commit","makeLocalGetters","gettersProxy","splitPos","localType","entry","rootGetters","rawGetter","_committing","_Vue","mapState","states","mapMutations","mutations","mapGetters","mapActions","actions","Module","rawModule","runtime","_children","_rawModule","prototypeAccessors$1","namespaced","addChild","defineProperties","ModuleCollection","rawRootModule","register","rawChildModule","unregister","Store","plugins","_subscribers","_watcherVM","prototypeAccessors","$data","all","registerModule","unregisterModule","hotUpdate","newOptions","committing","_from2","arr2","assign","toIObject","toLength","toIndex","IS_INCLUDES","$this","fromIndex","ARG","tryGet","T","callee","$defineProperty","documentElement","Iterators","ITERATOR","ArrayProto","iterator","entries","descriptor","setToStringTag","IteratorPrototype","Constructor","NAME","next","LIBRARY","redefine","$iterCreate","getPrototypeOf","BUGGY","FF_ITERATOR","KEYS","VALUES","returnThis","Base","DEFAULT","IS_SET","FORCED","getMethod","kind","proto","DEF_VALUES","VALUES_BUG","$native","$default","$entries","$anyNative","values","SAFE_CLOSING","riter","skipClosing","safe","iter","done","getKeys","gOPS","pIE","$assign","A","K","k","aLen","getSymbols","isEnum","dPs","IE_PROTO","Empty","createDict","iframeDocument","iframe","lt","gt","contentWindow","open","write","close","Properties","getOwnPropertySymbols","ObjectProto","arrayIndexOf","names","TO_STRING","valueOf","classof","getIteratorMethod","isArrayIter","createProperty","getIterFn","arrayLike","step","mapfn","mapping","iterFn","$at","iterated","point","__WEBPACK_AMD_DEFINE_RESULT__","qq","element","attach","attachEvent","detach","detachEvent","contains","descendant","compareDocumentPosition","elementB","opacity","filters","round","hasClass","considerParent","re","className","getByClass","first","candidates","querySelectorAll","getElementsByTagName","each","idx","getFirstByClass","setText","innerText","clearText","attrName","attrVal","canvasToBlob","canvas","mime","quality","dataUriToBlob","toDataURL","dataUri","arrayBuffer","byteString","intArray","mimeString","createBlob","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","blobBuilder","append","getBlob","Blob","atob","decodeURI","ArrayBuffer","Uint8Array","character","log","message","level","variable","isFunction","buffer","isItemList","maybeItemList","isNodeList","maybeNodeList","namedItem","isString","maybeString","trimStr","string","format","newStr","nextIdxToReplace","strBefore","substring","strAfter","isFile","maybeFile","File","isFileList","maybeFileList","FileList","isFileOrInput","maybeFileOrInput","isInput","maybeInput","notFile","evaluateType","normalizedType","HTMLInputElement","isBlob","maybeBlob","isXhrUploadSupported","input","FormData","createXhrInstance","upload","XMLHttpRequest","ActiveXObject","isFolderDropSupported","dataTransfer","webkitGetAsEntry","isFileChunkingSupported","androidStock","webkitSlice","mozSlice","sliceBlob","fileOrBlob","slicer","arrayBufferToHex","bytesAsHex","bytes","byt","byteAsHexStr","readBlobToHex","blob","startOffset","initialBlob","fileReader","FileReader","promise","onload","success","onerror","failure","readAsArrayBuffer","second","extendNested","override","sourceFn","super_","srcPropName","srcPropVal","elt","getUniqueId","r","ie","ie7","ie8","ie10","ie11","edge","safari","vendor","chrome","opera","firefox","windows","platform","android","ios6","ios","ios7","ios8","ios800","iosChrome","iosSafari","iosSafariWebView","preventDefault","returnValue","toElement","div","html","innerHTML","iterableItem","callback","keyOrIndex","retVal","Storage","getItem","oldFunc","newArgs","obj2url","temp","prefixDone","uristrings","prefix","nextObj","nextTemp","encodeURIComponent","obj2FormData","formData","arrayKeyName","obj2Inputs","form","parseJson","json","parse","eval","getExtension","filename","extIdx","lastIndexOf","substr","getFilename","blobOrFileInput","fileName","DisposeSupport","disposers","dispose","disposer","shift","addDisposer","disposeFunction","supportedFeatures","testSupportsFileInputElement","tempInput","supported","disabled","ex","isChrome21OrHigher","isChrome14OrHigher","isCrossOriginXhrSupported","xhr","withCredentials","isXdrSupported","XDomainRequest","isCrossOriginAjaxSupported","isFolderSelectionSupported","webkitdirectory","isLocalStorageSupported","localStorage","setItem","isDragAndDropSupported","span","supportsUploading","supportsUploadingBlobs","supportsFileDrop","supportsAjaxFileUploading","supportsFolderDrop","supportsChunking","supportsResume","supportsUploadViaPaste","supportsUploadCors","supportsDeleteFileXdr","supportsDeleteFileCorsXhr","supportsDeleteFileCors","supportsFolderSelection","supportsImagePreviews","supportsUploadProgress","postMessage","ajaxUploading","blobUploading","canDetermineSize","chunking","deleteFileCors","deleteFileCorsXdr","deleteFileCorsXhr","dialogElement","HTMLDialogElement","fileDrop","folderDrop","folderSelection","imagePreviews","imageValidation","itemSizeValidation","pause","progressBar","resume","scaling","tiffPreviews","unlimitedScaledImageSize","uploading","uploadCors","uploadCustomHeaders","uploadNonMultipart","uploadViaPaste","isGenericPromise","maybePromise","successArgs","failureArgs","successCallbacks","failureCallbacks","doneCallbacks","onSuccess","onFailure","BlobProxy","referenceBlob","onCreate","UploadButton","createInput","BUTTON_ID_ATTR_NAME","buttonId","title","setMultiple","folders","acceptFiles","position","right","fontFamily","fontSize","margin","padding","cursor","height","disposeSupport","onChange","hoverClass","focusClass","ios8BrowserCrashWorkaround","overflow","direction","getInput","getButtonId","optInput","setAcceptFiles","reset","UploadData","uploaderProxy","getDataByIds","idOrIds","getDataByUuids","uuids","uuid","byUuid","getDataByStatus","status","statusResults","statuses","statusEnum","statusResultIndexes","byStatus","dataIndex","byProxyGroupId","byBatchId","addFile","spec","SUBMITTING","originalName","size","batchId","proxyGroupId","onStatusChange","retrieve","optionalFilter","setStatus","newStatus","oldStatus","byStatusOldStatusIndex","uuidChanged","newUuid","oldUuid","updateName","newName","updateSize","newSize","setParentId","targetId","parentId","getIdsInProxyGroup","getIdsInBatch","SUBMITTED","REJECTED","QUEUED","CANCELED","PAUSED","UPLOADING","UPLOAD_RETRYING","UPLOAD_SUCCESSFUL","UPLOAD_FAILED","DELETE_FAILED","DELETING","DELETED","basePublicApi","addBlobs","blobDataOrArray","params","endpoint","addFiles","addInitialFiles","cannedFileList","cannedFile","_addCannedFile","_maybeHandleIos8SafariWorkaround","_storedIds","_currentBatchId","processBlob","_handleNewFile","blobs","defaultName","verifiedFiles","processBlobData","blobData","processCanvas","processCanvasData","canvasData","normalizedQuality","processFileOrInput","fileOrInput","files","file","normalizeData","fileContainer","_prepareItemsForUpload","cancel","_handler","cancelAll","storedIdsCopy","storedFileId","clearStoredFiles","continueUpload","uploadData","_uploadData","enabled","getName","_uploadFile","deleteFile","_onSubmitDelete","doesExist","fileOrBlobId","isValid","drawThumbnail","fileId","imgOrCanvas","maxSize","fromServer","customResizeFunction","fileOrUrl","promiseToReturn","_imageGenerator","_thumbnailUrls","scale","getFile","container","generate","modifiedContainer","getButton","_getButton","_buttonIdsForFileIds","getEndpoint","_endpointStore","getInProgress","getParentId","uploadDataEntry","getUploads","getResumableFilesData","getSize","getNetUploads","_netUploaded","getRemainingAllowedItems","allowedItems","_currentItemLimit","_netUploadedOrQueued","getUuid","debug","pauseUpload","_autoRetries","_retryTimeouts","_preventRetries","_buttons","button","_paramsStore","_pasteHandler","session","refreshOnReset","_refreshSessionData","_succeededSinceLastAllComplete","_failedSinceLastAllComplete","_totalProgress","retry","_manualRetry","scaleImage","specs","Scaler","setCustomHeaders","headers","_customHeadersStore","setDeleteFileCustomHeaders","_deleteFileCustomHeadersStore","setDeleteFileEndpoint","_deleteFileEndpointStore","setDeleteFileParams","_deleteFileParamsStore","setEndpoint","setForm","elementOrId","_updateFormSupportAndParams","setItemLimit","newItemLimit","setName","setParams","setUuid","uploadStoredFiles","_itemError","_uploadStoredFiles","basePrivateApi","sessionData","deleteFileEndpoint","deleteFileParams","thumbnailUrl","_annotateWithButtonId","associatedInput","qqButtonId","_getButtonId","_batchError","onError","_createDeleteHandler","DeleteFileAjaxRequester","maxConnections","uuidParamName","request","uuidName","customHeaders","paramsStore","endpointStore","cors","onDelete","_onDelete","onDeleteComplete","xhrOrXdr","isError","_onDeleteComplete","_createPasteHandler","PasteSupport","targetElement","paste","pasteReceived","_handleCheckedCallback","onPasteReceived","_handlePasteSuccess","identifier","_createStore","initialValue","_readOnlyValues_","catchall","perIdReadOnlyValues","readOnlyValues","copy","orig","getReadOnlyValues","includeReadOnlyValues","existing","addReadOnly","_createUploadDataTracker","_onUploadStatusChange","_maybeAllComplete","_createUploadButton","allowMultiple","workarounds","iosEmptyVideos","_isAllowedExtension","allowedExtensions","accept","validation","classes","buttonFocus","buttonHover","ios8BrowserCrash","inputName","_onInputChange","fileInputTitle","_disposeSupport","_createUploadHandler","additionalOptions","lastOnProgress","preventRetryParam","preventRetryResponseProperty","onProgress","loaded","total","_onProgress","onComplete","_onComplete","onCancel","cancelFinalizationEffort","_onCancel","onUploadPrep","_onUploadPrep","onUpload","_onUpload","onUploadChunk","chunkData","_onUploadChunk","onUploadChunkSuccess","onResume","onAutoRetry","responseJSON","_onAutoRetry","onUuidChanged","setSize","_setSize","getDataByUuid","isQueued","UploadHandlerController","_fileOrBlobRejected","_formatSize","toFixed","sizeSymbols","_generateExtraButtonSpecs","_extraButtonSpecs","extraButtons","extraButtonOptionEntry","extraButtonSpec","_initExtraButton","extraButtonsSpec","_defaultButtonId","buttonOrFileInputOrFile","inputs","fileInput","fileBlobOrInput","_getNotFinished","_getValidationBase","_getValidationDescriptor","fileWrapper","_getValidationDescriptors","fileWrappers","fileDescriptors","_handleCameraAccess","camera","acceptIosCamera","optionRoot","details","callbackRetVal","successParam","newFileWrapperList","actualFile","_customNewFileHandler","_handleNewFileGeneric","addFileToHandler","_trackButton","fileList","extSuppliedName","extension","_initFormSupportAndParams","_formSupport","FormSupport","attachedToForm","getFormInputsAsObject","autoUpload","newAutoUpload","newEndpoint","_isDeletePossible","expected","allowXdr","allowed","valid","allowedExt","extRegex","code","maybeNameOrNames","replacement","extensionsForMessage","placeholderMatch","messages","validationBase","allowedExtension","formatFileName","sizeLimit","minSizeLimit","_onBeforeManualRetry","notFinished","_onAllComplete","ios8SafariUploads","alert","unsupportedBrowserIos8Safari","_maybeParseAndSendUploadError","response","errorReason","defaultResponseError","_maybeProcessNextItemAfterOnValidateCallback","validItem","stopOnFirstInvalidFile","validationDescriptor","onValidate","_onValidateCallbackSuccess","_onValidateCallbackFailure","successful","failed","onAllComplete","_shouldAutoRetry","retryWaitPeriod","autoAttemptDelay","_onBeforeAutoRetry","itemLimit","onManualRetry","clearTimeout","storedItemIndex","expunge","fileIndex","onIndividualProgress","_onSubmit","_onSubmitCallbackSuccess","_onSubmitted","onSubmitted","_storeForLater","onSuccessCallback","additionalMandatedParams","adjustedOnSuccessCallback","onSubmitDelete","_deleteHandler","sendDelete","_onTotalProgress","onTotalProgress","_onValidateBatchCallbackFailure","_onValidateBatchCallbackSuccess","validationDescriptors","errorMessage","proposedNetFilesUploadedOrQueued","tooManyItemsError","nextIndex","_validateFileOrBlobData","_upload","onValidateBatch","_preventLeaveInProgress","onLeave","Session","_session","addFileRecord","refresh","_sessionRequestComplete","onSessionRequestComplete","onNewSize","enableAuto","maxAutoAttempts","formElementOrId","onSubmit","idToUpload","stillSubmitting","validityChecker","ImageValidation","validate","image","errorCode","_wrapCallbacks","safeCallback","errorMsg","exception","callbackName","callbackFunc","FineUploaderBasic","disableCancelForFormUploads","filenameParam","forceMultipart","paramsInBody","totalFileSizeName","maxHeight","maxWidth","minHeight","minWidth","maybeXhr","maybeXhrOrXdr","attemptNumber","fileOrBlobData","typeError","sizeError","minSizeError","emptyError","noFilesError","maxHeightImageError","maxWidthImageError","minHeightImageError","minWidthImageError","retryFailTooManyItems","concurrent","mandatory","paramNames","partIndex","partByteOffset","chunkSize","totalFileSize","totalParts","partSize","recordsExpireIn","resuming","fileOrBlobName","sendCredentials","interceptSubmit","customResizer","sendOriginal","orient","defaultType","defaultQuality","failureText","includeExif","sizes","ImageGenerator","_scaler","handleNewFile","TotalProgress","AjaxRequester","isSimpleMethod","containsNonSimpleHeaders","containsNonSimple","header","isXdr","getCorsAjaxTransport","ontimeout","onprogress","getXhrOrXdr","suppliedXhr","requestData","dequeue","nextId","sendRequest","xdrError","isResponseSuccessful","getParams","onDemandParams","additionalParams","mandatedParams","optXhr","url","onSend","createUrl","additionalQueryParams","getXdrLoadHandler","getXdrErrorHandler","onreadystatechange","getXhrReadyStateChangeHandler","registerForUploadProgress","setHeaders","send","shouldParamsBeInQueryString","contentType","addToPath","readyState","lengthComputable","onDemandHeaders","additionalHeaders","allHeaders","acceptHeader","setRequestHeader","allowXRequestedWithAndCacheControl","responseCode","successfulResponseCodes","prepareToSend","validMethods","DELETE","PATCH","POST","PUT","GET","initTransport","cacheBuster","withPath","appendToPath","withParams","withQueryParams","_additionalQueryParams_","withHeaders","withPayload","thePayload","withCacheBuster","qqtimestamp","Date","getTime","canceled","UploadHandler","fileState","fileItem","onCancelRetVal","getThirdPartyFileId","_getFileState","_setThirdPartyFileId","thirdPartyFileId","_wasCanceled","preventRetryResponse","controller","chunkingPossible","concurrentChunkingPossible","chunked","chunkIdx","_getChunkData","attemptingResume","chunkProgress","_getChunkDataForCallback","finalize","finalizeChunks","normaizedResponse","normalizeResponse","_maybeDeletePersistedChunkData","cleanup","handleFailure","clearCachedChunk","inProgressIdx","responseToReport","inProgress","remaining","ignoreFailure","_getXhrs","ckid","ckXhr","abort","_cancelled","moveInProgressToRemaining","connectionManager","free","hasMoreParts","nextPart","nextIdx","_getTotalChunks","reevaluateChunking","sendNext","inProgressChunks","available","uploadChunk","inProgressChunkIdx","_maybePersistChunkedState","clearXhr","_open","_openChunks","_waiting","openChunkEntriesCount","openChunksCount","openChunkIndexes","dontAllowNext","allowNext","waitingIndex","connectionsIndex","getProxyOrBlob","getWaitingOrConnected","waitingOrConnected","chunks","parseInt","isUsingConnection","openChunksEntry","simple","uploadFile","maybeNewUuid","_clearXhrs","getProxy","initHandler","handlerType","traditional","handlerModuleSubtype","_removeExpiredChunkingRecords","isDeferredEligibleForUpload","maybeDefer","generatedBlob","updateBlob","maybeSendDeferredFiles","errorResponse","idsInGroup","uploadedThisId","idInGroup","now","originalResponse","_shouldChunkThisFile","blobToUpload","cancelRetVal","isProxied","isResumable","WindowReceiveMessage","callbackWrapperDetachers","receiveMessage","onMessageCallbackWrapper","stopReceivingMessages","detacher","FormUploadHandler","expungeFile","detachLoadEvents","isCors","postMessageCallbackTimers","corsMessageReceiver","getElementById","_getIframeName","getFileIdForIframeName","iframeName","initIframeForUpload","registerPostMessageCallback","onloadCallbacks","onloadCallback","_parseJsonResponse","_detachLoadEvent","formHandlerInstanceId","_attachLoadEvent","responseDescriptor","contentDocument","_createIframe","_initFormForUpload","targetName","innerHtmlOrMessage","XhrUploadHandler","xhrId","ajaxRequester","_getAjaxRequester","chunkFiles","resumeEnabled","blobOrProxy","_initTempState","_maybePrepareForResume","cachedChunks","tempState","xhrs","ajaxRequesters","responseParser","lastChunkIdx","_getXhr","resumableFilesData","_iterateResumeRecords","notResumable","optInProgress","optRemaining","reverse","paused","totalChunks","parts","newBlob","chunkId","_createXhr","optChunkIdx","_registerXhr","chunkIndex","fileSize","startBytes","endBytes","part","count","startByte","endByte","_getLocalStorageId","formatVersion","_getMimeType","_getPersistableData","_markNotResumable","localStorageId","removeItem","persistedData","lastUpdated","_registerProgressHandler","progressCalculator","totalSuccessfullyLoadedForFile","loadedForRequest","totalForRequest","estActualChunkLoaded","totalLoadedForFile","chunkLoaded","optAjaxRequester","xhrsId","expirationDays","expirationDate","setDate","getDate","getMandatedParams","_method","requester","detectSubsampling","img","iw","naturalWidth","ih","naturalHeight","width","getContext","drawImage","getImageData","detectVerticalSquash","alpha","ratio","sy","ey","py","renderImageToDataURL","doSquash","renderImageToCanvas","maybeCalculateDownsampledDimensions","maxPixels","origHeight","origWidth","newHeight","sqrt","newWidth","modifiedDimensions","save","resize","renderImageToCanvasWithCustomResizer","imageHeight","imageWidth","orientation","targetHeight","targetWidth","transformCoordinate","tmpCtx","sx","tmpCanvas","vertSquashRatio","dw","dh","clearRect","restore","qqImageRendered","resizeInfo","sourceCanvas","sourceCanvasContext","targetCanvas","translate","rotate","PI","MegaPixImage","srcImage","errorCallback","Image","URL","createObjectURL","webkitURL","imageLoadListeners","opt","imgWidth","imgHeight","optionsKey","optionsValue","oldTargetSrc","onrender","isImg","isCanvas","isImgCorsSupported","crossOrigin","isCanvasSupported","determineMimeOfFileName","nameWithPath","pathSegments","isCrossOrigin","targetProtocol","targetHostname","targetPort","targetAnchor","href","protocol","port","hostname","location","registerImgLoadListeners","registerCanvasDrawImageListener","registerThumbnailRenderedListener","registered","draw","drawPreview","Identify","megapixErrorHandler","isPreviewable","dummyExif","exif","Exif","mpImg","Orientation","failureMsg","drawOnCanvasOrImgFromUrl","canvasOrImg","tempImg","tempImgRender","drawOnImgFromUrlWithCssScaling","drawFromUrl","fileBlobOrUrl","_testing","parseLittleEndian","hex","pow","seekToApp1","offset","theOffset","thePromise","segmentLength","getApp1Offset","isLittleEndian","app1Start","getDirEntryCount","littleEndian","getIfd","dirEntries","getDirEntries","ifdHex","getTagValues","TAG_VAL_OFFSET","tagsToFind","TAG_IDS","vals","tagValHex","tagValLength","idHex","tagsToFindIdx","TAG_INFO","274","parser","onParseFailure","app1Offset","dirEntryCount","tagValues","isIdentifiable","magicBytes","questionableBytes","identifiable","magicBytesEntries","magicBytesArrayEntry","previewable","isPreviewableSync","PREVIEWABLE_MIME_TYPES","fileMime","isRecognizedImage","image/jpeg","image/gif","image/png","image/bmp","image/tiff","hasNonZeroLimits","limits","atLeastOne","limit","getWidthHeight","sizeDetermination","getFailingLimit","dimensions","failingLimit","limitName","limitValue","limitMatcher","dimensionPropName","actualValue","validationEffort","isJsonResponseValid","handleFileItems","fileItems","someItemsIgnored","refreshEffort","refreshCompleteCallback","requesterOptions","SessionAjaxRequester","queryServer","responseText","includeOriginal","failedToScaleText","_getSortedSizes","getFileRecords","originalFileUuid","originalFileName","originalBlobOrBlobData","records","originalBlob","sizeRecord","outputType","_determineOutputType","requestedType","refType","_getName","_generateScaledImage","failedText","api","scaledIds","originalId","record","blobSize","scaledId","qqparentuuid","qqparentsize","param","scalingEffort","scalingOptions","scaler","referenceType","scaledVersionProperties","startOfExt","versionType","scaledName","scaledExt","nameAppendage","sourceFile","imageGenerator","scaledImageDataUri","signalSuccess","_insertExifHeader","scaledImageDataUriWithExif","originalImage","reader","insertionEffort","originalImageDataUri","ExifRestorer","readAsDataURL","_dataUriToBlob","_createBlob","KEY_STR","encode64","chr1","chr2","enc1","enc2","enc3","output","chr3","enc4","origFileBase64","resizedFileBase64","expectedBase64Header","rawImage","decode64","slice2Segments","exifManipulation","exifArray","getExifArray","newImageArray","insertExif","aBuffer","seg","x","imageData","buf","separatePoint","mae","ato","array","rawImageArray","head","endPoint","base64test","perFileProgress","totalLoaded","totalSize","lastLoadedSent","lastTotalSent","callbackProxy","noRetryableFiles","retryable","none","failedId","updateTotalProgress","onNew","newLoaded","newTotal","oldLoaded","oldTotal","isImage","registerPasteHandler","detachPasteHandler","clipboardData","getAsFile","unregisterPasteHandler","startUpload","determineNewEndpoint","formEl","validateForm","nativeSubmit","checkValidity","maybeUploadOnSubmit","submit","determineFormEl","_form2Obj","notIrrelevantType","irrelevantTypes","radioOrCheckbox","ignoreValue","checked","selectValue","select","elements","getIframeContentJson","doc","innerHtml","nodeValue","createForm","responseFromMessage","multipart","addChunkingSpecificParams","allChunksDoneRequester","AllChunksDoneAjaxRequester","createReadyStateChangedHandler","onUploadOrChunkComplete","getChunksCompleteParams","isErrorUploadResponse","parseResponse","sendChunksCompleteRequest","complete","setParamsAndGetEntityToSend","setUploadHeaders","extraHeaders","toSend","promises","endpointHandler","DragAndDrop","uploadDroppedFiles","uploadDropZone","filesAsArray","dropLog","dropDisabled","processingDroppedFilesComplete","getElement","traverseFileTree","parseEntryPromise","fullPath","indexOfNameInFullPath","qqPath","droppedFiles","fileError","isDirectory","getFilesInDirectory","entriesLeft","accumEntries","existingPromise","dirReader","createReader","readEntries","newEntries","handleDataTransfer","pendingFolderPromises","handleDataTransferPromise","processingDroppedFiles","allowMultipleItems","dropError","setupDropzone","dropArea","dropZone","UploadDropZone","HIDE_ZONES_EVENT_NAME","onEnter","dropActive","stopPropagation","onLeaveNotDescendants","onDrop","HIDE_BEFORE_ENTER_ATTR","uploadDropZones","isFileDrag","dragEvent","fileDrag","types","leavingDocumentOut","relatedTarget","y","setupDragDrop","dropZones","dropZoneElements","maybeHideDropZones","setupExtraDropzone","removeDropzone","dzs","targetEl","errorSpecifics","dragoverShouldBeCanceled","disableDropOutside","dropOutsideDisabled","dropEffect","isValidFileDrag","effectTest","dt","isSafari","effectAllowed","isOrSetDropDisabled","isDisabled","preventDrop","triggerHidezonesEvent","triggerUsingOldApi","hideZonesEvent","CustomEvent","attachEvents","effect","elementFromPoint","clientX","clientY","uiPublicApi","_parent","_templating","addCacheToDom","clearFiles","addExtraDropzone","_dnd","removeExtraDropzone","getItemByFileId","isHiddenForever","getFileContainer","_setupDragAndDrop","_totalFilesInBatch","_filesInBatchAddedToUi","_setupClickAndEditEventHandlers","formattedFilename","updateFilename","uploadPaused","continued","uploadContinued","getId","fileContainerOrChildEl","getFileId","getDropTarget","qqDropTarget","uiPrivateApi","_removeFileItem","removeFile","_fileButtonsClickHandler","FileButtonsClickHandler","_bindFileButtonsClickEvent","_focusinEventSupported","_isEditFilenameEnabled","_filenameClickHandler","_bindFilenameClickEvent","_filenameInputFocusInHandler","_bindFilenameInputFocusInEvent","_filenameInputFocusHandler","_bindFilenameInputFocusEvent","dragAndDrop","extraDropzones","templating","defaultDropZone","getDropZone","showDropProcessing","hideDropProcessing","errorData","lvl","onDeleteFile","onRetry","onPause","onContinue","onGetName","isEditFilenamePossible","FilenameClickHandler","FilenameInputFocusHandler","_filenameEditHandler","onGetUploadStatus","onSetName","onEditingStatusChange","isEditing","qqInput","getEditInput","qqFileContainer","hideFilename","hideEditIcon","showFilename","showEditIcon","markFilenameEditable","hideRetry","setStatusText","_classes","retrying","hidePause","FilenameInputFocusInHandler","hideSpinner","resetTotalProgress","reportDirectoryPaths","qqpath","_addToList","addHandler","updateProgress","hideCancel","hideProgress","waitingForResponse","_displayFileSize","completeUpload","_markFileAsSuccessful","fail","showCancel","isRetryPossible","showRetry","_controlFailureTextDisplay","parentRetVal","newResult","showDeleteButton","_maybeUpdateThumbnail","showSpinner","allowPause","retryNumForDisplay","maxAuto","retryNote","_showCancelLink","showAutoRetryNote","autoRetryNote","resetProgress","_onSubmitDeleteSuccess","forceConfirm","_showDeleteConfirm","_sendDeleteRequest","deletingFailedText","hideDeleteButton","deletingStatusText","confirmMessage","deleteRequestArgs","showConfirm","canned","prependData","prependIndex","dontDisplay","hideScaled","prependFiles","disableCancel","_handledProxyGroup","_clearList","addFileToCache","updateThumbnail","thumbnails","generatePreview","fileSizeOnSubmit","loadedSize","sizeForDisplay","_formatProgress","uploadedSize","formatProgress","responseProperty","failureReason","failedUploadTextDisplay","failUpload","enableTooltip","_showTooltip","showMessage","_setupPastePrompt","namePromptMessage","defaultVal","showPrompt","fileStatus","placeholders","waitUntilResponse","FineUploader","listElement","template","editable","tooManyFilesError","unsupportedBrowser","promptForName","maxCount","notAvailablePath","waitingPath","timeBetweenThumbs","hasDialog","showDialog","confirm","defaultValue","prompt","Templating","templateIdOrEl","containerEl","fileContainerEl","maxThumbs","waitUntilUpdate","thumbnailNotAvailable","waitingForThumbnail","renderFailure","isEditElementsExist","isRetryElementExist","templateHtml","showThumbnails","serverScale","FILE_ID_ATTR","FILE_CLASS_PREFIX","THUMBNAIL_MAX_SIZE_ATTR","THUMBNAIL_SERVER_SCALE_ATTR","HIDE_DROPZONE_ATTR","DROPZPONE_TEXT_ATTR","IN_PROGRESS_CLASS","HIDDEN_FOREVER_CLASS","fileBatch","content","createDocumentFragment","isCancelDisabled","generatedThumbnails","thumbnailQueueMonitorRunning","thumbGenerationQueue","thumbnailMaxSize","selectorClasses","alertDialog","dialogCancelButton","confirmDialog","dialogMessage","dialogOkButton","promptDialog","uploader","drop","progressBarContainer","totalProgressBarContainer","totalProgressBar","spinner","continueButton","deleteButton","statusText","editFilenameInput","editNameIcon","dropText","dropProcessing","dropProcessingSpinner","thumbnail","previewGeneration","cachedThumbnailNotAvailableImg","cachedWaitingForThumbnailImg","cacheThumbnailPlaceholders","notAvailableUrl","waitingUrl","updatedImg","displayWaitingImg","waitingImgPlacement","maybeScalePlaceholderViaCss","generateNewPreview","getThumbnail","qqThumbnailId","maybeSetDisplayNotAvailableImg","generateNextQueuedPreview","queuedThumbRequest","processUpdateQueuedPreviewRequest","processNewQueuedPreviewRequest","getCancel","getTemplateEl","getContinue","getDialog","getDelete","getDropProcessing","getEditIcon","getPause","getProgress","getRetry","getSpinner","cssClass","previewing","notAvailableImgPlacement","parseAndGetTemplate","scriptEl","scriptHtml","fileListNode","tempTemplateEl","fileListHtml","defaultButton","dropTextEl","uploaderEl","fileTemplate","prependFile","parentEl","beforeEl","optFileOrBlob","relatedThumbnailId","useCachedPreview","showWaitingImg","setProgressBarWidth","percent","bar","progressBarSelector","targetThumbnailId","cachedThumbnailId","targetThumbnail","cachedThumbnail","hideTotalProgress","cantRenderEl","prependInfo","hideForever","batch","thumb","fileEl","fileNameEl","waitingImg","currentNode","getFileList","filenameEl","isFileName","icon","isEditIcon","isEditInput","isCancel","allowContinueButton","isPause","isContinueButton","isDeleteButton","isRetry","textEl","dialog","messageEl","inputEl","cancelBtn","okBtn","closeHandler","cancelClickHandler","okClickHandler","showModal","UiEventHandler","protectedApi","eventType","srcElement","onHandled","attachTo","getFileIdFromItem","qqFileId","getDisposeSupport","examineEvent","buttonHandlers","buttonType","firstLetterCapButtonType","inheritedInternalApi","handleFilenameEdit","FilenameEditHandler","handleInputFocus","getFilenameSansExtension","filenameSansExt","getOriginalExtension","origName","handleNameUpdate","newFilenameInputEl","origExtension","registerInputBlurHandler","registerInputEnterKeyHandler","keyCode","which","focusInput","focus","CryptoJS","C_lib","lib","overrides","subtype","mixIn","$super","instance","properties","clone","WordArray","words","sigBytes","encoder","Hex","wordArray","thisWords","thatWords","thisSigBytes","thatSigBytes","clamp","thatByte","nBytes","C_enc","enc","hexChars","bite","hexStr","hexStrLength","Latin1","latin1Chars","fromCharCode","latin1Str","latin1StrLength","Utf8","decodeURIComponent","escape","utf8Str","unescape","BufferedBlockAlgorithm","_nDataBytes","_append","_process","doFlush","dataWords","dataSigBytes","blockSize","blockSizeBytes","nBlocksReady","_minBufferSize","nWordsReady","nBytesReady","_doProcessBlock","processedWords","C_algo","Hasher","cfg","_doReset","messageUpdate","_doFinalize","_createHelper","hasher","_createHmacHelper","HMAC","algo","Base64","_map","base64Chars","byte1","byte2","byte3","triplet","paddingChar","base64Str","base64StrLength","paddingIndex","bits1","bits2","_hasher","hasherBlockSize","hasherBlockSizeBytes","oKey","_oKey","iKey","_iKey","oKeyWords","iKeyWords","innerHash","hmac","SHA1","_hash","M","H","t","nBitsTotal","nBitsLeft","HmacSHA1","isPrime","sqrtN","factor","getFractionalBits","nPrime","SHA256","g","gamma0x","gamma0","gamma1x","gamma1","maj","sigma0","sigma1","t1","t2","HmacSHA256","superInit","subInit","typedArray","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","byteOffset","byteLength","typedArrayByteLength","s3","ALGORITHM_PARAM_NAME","AWS_PARAM_PREFIX","CREDENTIAL_PARAM_NAME","DATE_PARAM_NAME","REDUCED_REDUNDANCY_PARAM_NAME","REDUCED_REDUNDANCY_PARAM_VALUE","SERVER_SIDE_ENCRYPTION_PARAM_NAME","SERVER_SIDE_ENCRYPTION_PARAM_VALUE","SESSION_TOKEN_PARAM_NAME","V4_ALGORITHM_PARAM_VALUE","V4_SIGNATURE_PARAM_NAME","CASE_SENSITIVE_PARAM_NAMES","UNSIGNABLE_REST_HEADER_NAMES","UNPREFIXED_PARAM_NAMES","getBucket","bucket","patterns","_getPrefixedParamName","getPolicy","policy","conditions","date","drift","clockDrift","accessKey","acl","expectedStatus","sessionToken","successRedirectUrl","getSuccessRedirectAbsoluteUrl","minFileSize","maxFileSize","reducedRedundancy","region","serverSideEncryption","signatureVersion","expiration","getPolicyExpirationDate","Content-Type","success_action_status","success_action_redirect","getV4CredentialsString","getV4PolicyDate","awsParamName","enforceSizeLimits","refreshPolicyCredentials","newSessionToken","sessionTokenFound","oldCondIdx","oldCondObj","oldCondName","oldCondVal","generateAwsParams","signPolicyCallback","policyJson","awsParams","customParams","AWSAccessKeyId","policyAndSignature","updatedAccessKey","updatedSessionToken","signature","minSize","adjustedMinSize","adjustedMaxSize","adjustedDate","getPolicyDate","getCredentialsDate","getUTCFullYear","getUTCMonth","getUTCDate","_minutesToAdd_","pad","minutesToAdd","setMinutes","getMinutes","toISOString","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","parseIframeResponse","queryString","search","etag","targetAnchorContainer","encodeQueryStringParam","percentEncoded","uriEscape","uriEscapePath","nonTraditionalBasePublicApi","setUploadSuccessParams","_uploadSuccessParamsStore","setUploadSuccessEndpoint","_uploadSuccessEndpointStore","nonTraditionalBasePrivateApi","submitSuccessRequest","successAjaxRequester","onCompleteArgs","successEndpoint","successCustomHeaders","uploadSuccess","successMethod","uploadSuccessParams","fileParams","onSuccessFromServer","successRequestResult","_failedSuccessRequestCallbacks","onFailureFromServer","UploadSuccessAjaxRequester","_getEndpointSpecificParams","sendSuccessRequest","successRequestCallback","objectProperties","host","credentials","secretKey","iframeSupport","localBlankPagePath","onCredentialsExpired","setCredentials","_currentCredentials","_aclStore","_cannedKeys","_cannedBuckets","_buckets","_hosts","getKey","ignoreEmpty","setAcl","aclStore","_determineBucket","getHost","_determineHost","getKeyName","_determineKeyName","maxSizeLimit","oldParams","modifiedParams","paramName","credentialsProvider","onExpired","updateCredentials","_determineObjectPropertyValue","maybe","keynameLogic","onGetKeynameFailure","onGetKeynameSuccess","keyname","keynameToUse","_handleKeynameFunction","keynameFunc","successCallback","failureCallback","getResponseHeader","s3Key","s3Bucket","RequestSigner","handleSignatureReceived","responseJson","pendingSignatureData","pendingSignatures","signatureConstructor","invalid","expectingPolicy","generateHeaders","getStringToSignArtifacts","requestInfo","endOfUrl","signatureSpec","toSign","headerNames","headersStr","generateStringToSign","contentMd5","headerIndexesToRemove","headerName","headerIdx","hashedContent","v2","getStringToSign","v4","signedHeaders","getSignedHeaders","hashed","toSignRaw","thisSignatureRequester","REQUEST_TYPE","MULTIPART_ABORT","uploadId","MULTIPART_INITIATE","MULTIPART_COMPLETE","MULTIPART_UPLOAD","partNum","getEncodedHashedPayload","Host","determineSignatureClientSide","toBeSigned","signatureEffort","updatedHeaders","getHeaders","getToSign","signatureArtifacts","signApiRequest","stringToSign","signPolicy","Authorization","getRequestDate","getEndOfUrl","headersWordArray","headersHmacSha1","headersHmacSha1Base64","policyStr","policyWordArray","base64Policy","policyHmacSha1","policyHmacSha1Base64","getCanonicalQueryString","endOfUri","encodedQueryParams","encodedQueryParamNames","queryStrings","queryParamIdx","canonicalQueryString","nameAndVal","paramVal","encodedQueryParamName","getCanonicalRequest","getCanonicalUri","onloadend","DONE","getScope","canonicalRequest","hashedRequest","scope","stringToSignTemplate","dateKey","dateRegionKey","dateRegionServiceKey","signingKey","headersPattern","credentialPattern","credentialCondition","credential","getSignature","queryParams","stringToSignRaw","constructStringToSign","artifacts","theHeaders","withUploadId","theUploadId","withContent","theContent","withContentType","theContentType","withPartNum","thePartNum","toUTCString","_artifacts_","handleSuccessResponse","parsedResponse","pendingRequests","successIndicator","failureIndicator","InitiateMultipartAjaxRequester","getSignatureAjaxRequester","getContentType","handleInitiateRequestComplete","uploadIdElements","messageElements","pendingInitiateRequests","domParser","DOMParser","responseDoc","parseFromString","CompleteMultipartAjaxRequester","handleCompleteRequestComplete","pendingCompleteRequests","bucketEls","keyEls","getCompleteRequestBody","etagEntries","implementation","createDocument","etagEntry","partEl","partNumEl","partNumTextEl","etagTextEl","etagEl","XMLSerializer","serializeToString","AbortMultipartAjaxRequester","handleAbortRequestComplete","awsErrorMsg","errorEls","onGetBucket","onGetHost","onGetKeyName","combine","etagMap","etags","requesters","completeMultipart","initHeaders","urlSafe","restSignature","put","domain","track","setup","uploadIdPromise","initiateMultipart","abortMultipart","policySignature","initParams","cachedBucket","cachedHost","shouldReset","keyName","encodedKey","parsedErrorProps","parseError","awsResponseXml","codeEls","messageEls","parsedDoc","errorDetails","existedInLocalStorage","baseStorageId","bucketName","isValidResponse","responseData","handleFinishedUpload","handleUpload","azure","AZURE_PARAM_PREFIX","_paramNameMatchesAzureParameter","getParamsAsHeaders","parseAzureError","codeTag","messageTag","errorTag","blobProperties","_cannedBlobNames","getBlobName","onGetBlobName","_determineBlobName","deleteBlob","_deleteBlob","blobNameOptionValue","fileExtension","blobNameToUse","blobName","relatedToCancel","deleteBlobSasUri","blobUriStore","deleteFileEndpointStore","getSasSuccess","sasUri","getSasFailure","DeleteBlob","getSas","GetSas","restRequestVerb","combineChunks","getSignedUrl","mimeType","blockIdEntries","putBlockList","determineBlobUrl","containerUrl","getBlobNameSuccess","getBlobNameFailure","getSasId","getSasXhr","determineBlobUrlSuccess","blobUrl","getSasForPutBlobOrBlock","determineBlobUrlFailure","azureError","minFileSizeForChunking","getBlobMetadata","putBlob","PutBlob","putBlock","PutBlock","PutBlockList","blockIdEntry","chunkingData","maybePossible","sasResponseReceived","requestPromises","blobUri","requestPromise","restVerb","bloburi","codes","endpoints","createBlockId","digits","zeros","paddedPartNum","btoa","blockId","createRequestBody","latestEl","latestTextEl","fileMimeType","registerXhrCallback","blockIdsXml","x-ms-blob-content-type","mediaQuery","alreadyImportedModules","addStylesToDom","domStyle","stylesInDom","addStyle","listToStyles","newStyles","media","sourceMap","insertStyleElement","styleElement","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","removeStyleElement","createStyleElement","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","applyToTag","newObj","styleSheet","replaceText","cssNode","childNodes","sources","memoize","memo","isOldIE","newList","mayRemove","textStore"],"mappings":"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","file":"static/js/vendor.3e1f2576aadeeb10b05b.js","sourcesContent":["webpackJsonp([1,0],[\n/* 0 */,\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar store      = __webpack_require__(26)('wks')\n\t  , uid        = __webpack_require__(29)\n\t  , Symbol     = __webpack_require__(2).Symbol\n\t  , USE_SYMBOL = typeof Symbol == 'function';\n\t\n\tvar $exports = module.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n\t};\n\t\n\t$exports.store = store;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(12);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tvar core = module.exports = {version: '2.4.0'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(11)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP         = __webpack_require__(8)\n\t  , createDesc = __webpack_require__(14);\n\tmodule.exports = __webpack_require__(5) ? function(object, key, value){\n\t  return dP.f(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar anObject       = __webpack_require__(3)\n\t  , IE8_DOM_DEFINE = __webpack_require__(46)\n\t  , toPrimitive    = __webpack_require__(63)\n\t  , dP             = Object.defineProperty;\n\t\n\texports.f = __webpack_require__(5) ? Object.defineProperty : function defineProperty(O, P, Attributes){\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return dP(O, P, Attributes);\n\t  } catch(e){ /* empty */ }\n\t  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n\t  if('value' in Attributes)O[P] = Attributes.value;\n\t  return O;\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(2)\n\t  , core      = __webpack_require__(4)\n\t  , ctx       = __webpack_require__(20)\n\t  , hide      = __webpack_require__(7)\n\t  , PROTOTYPE = 'prototype';\n\t\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , IS_WRAP   = type & $export.W\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , expProto  = exports[PROTOTYPE]\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n\t    , key, own, out;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && target[key] !== undefined;\n\t    if(own && key in exports)continue;\n\t    // export native or passed\n\t    out = own ? target[key] : source[key];\n\t    // prevent global pollution for namespaces\n\t    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n\t    // bind timers to global for call from export context\n\t    : IS_BIND && own ? ctx(out, global)\n\t    // wrap global constructors for prevent change them in library\n\t    : IS_WRAP && target[key] == out ? (function(C){\n\t      var F = function(a, b, c){\n\t        if(this instanceof C){\n\t          switch(arguments.length){\n\t            case 0: return new C;\n\t            case 1: return new C(a);\n\t            case 2: return new C(a, b);\n\t          } return new C(a, b, c);\n\t        } return C.apply(this, arguments);\n\t      };\n\t      F[PROTOTYPE] = C[PROTOTYPE];\n\t      return F;\n\t    // make static versions for prototype methods\n\t    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n\t    if(IS_PROTO){\n\t      (exports.virtual || (exports.virtual = {}))[key] = out;\n\t      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n\t      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n\t    }\n\t  }\n\t};\n\t// type bitmap\n\t$export.F = 1;   // forced\n\t$export.G = 2;   // global\n\t$export.S = 4;   // static\n\t$export.P = 8;   // proto\n\t$export.B = 16;  // bind\n\t$export.W = 32;  // wrap\n\t$export.U = 64;  // safe\n\t$export.R = 128; // real proto method for `library` \n\tmodule.exports = $export;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar shared = __webpack_require__(26)('keys')\n\t  , uid    = __webpack_require__(29);\n\tmodule.exports = function(key){\n\t  return shared[key] || (shared[key] = uid(key));\n\t};\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil  = Math.ceil\n\t  , floor = Math.floor;\n\tmodule.exports = function(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.13 ToObject(argument)\n\tvar defined = __webpack_require__(9);\n\tmodule.exports = function(it){\n\t  return Object(defined(it));\n\t};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _assign = __webpack_require__(37);\n\t\n\tvar _assign2 = _interopRequireDefault(_assign);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _assign2.default || function (target) {\n\t  for (var i = 1; i < arguments.length; i++) {\n\t    var source = arguments[i];\n\t\n\t    for (var key in source) {\n\t      if (Object.prototype.hasOwnProperty.call(source, key)) {\n\t        target[key] = source[key];\n\t      }\n\t    }\n\t  }\n\t\n\t  return target;\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(41);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(12)\n\t  , document = __webpack_require__(2).document\n\t  // in old IE typeof document.createElement is 'object'\n\t  , is = isObject(document) && isObject(document.createElement);\n\tmodule.exports = function(it){\n\t  return is ? document.createElement(it) : {};\n\t};\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t// IE 8- don't enum bug keys\n\tmodule.exports = (\n\t  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n\t).split(',');\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(19);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\tvar $keys       = __webpack_require__(58)\n\t  , enumBugKeys = __webpack_require__(22);\n\t\n\tmodule.exports = Object.keys || function keys(O){\n\t  return $keys(O, enumBugKeys);\n\t};\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(8).f\n\t  , has = __webpack_require__(6)\n\t  , TAG = __webpack_require__(1)('toStringTag');\n\t\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(2)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(23)\n\t  , defined = __webpack_require__(9);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.15 ToLength\n\tvar toInteger = __webpack_require__(16)\n\t  , min       = Math.min;\n\tmodule.exports = function(it){\n\t  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n\t};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*!\n\t * Vue.js v2.1.8\n\t * (c) 2014-2016 Evan You\n\t * Released under the MIT License.\n\t */\n\t'use strict';\n\t\n\t/*  */\n\t\n\t/**\n\t * Convert a value to a string that is actually rendered.\n\t */\n\tfunction _toString (val) {\n\t  return val == null\n\t    ? ''\n\t    : typeof val === 'object'\n\t      ? JSON.stringify(val, null, 2)\n\t      : String(val)\n\t}\n\t\n\t/**\n\t * Convert a input value to a number for persistence.\n\t * If the conversion fails, return original string.\n\t */\n\tfunction toNumber (val) {\n\t  var n = parseFloat(val, 10);\n\t  return (n || n === 0) ? n : val\n\t}\n\t\n\t/**\n\t * Make a map and return a function for checking if a key\n\t * is in that map.\n\t */\n\tfunction makeMap (\n\t  str,\n\t  expectsLowerCase\n\t) {\n\t  var map = Object.create(null);\n\t  var list = str.split(',');\n\t  for (var i = 0; i < list.length; i++) {\n\t    map[list[i]] = true;\n\t  }\n\t  return expectsLowerCase\n\t    ? function (val) { return map[val.toLowerCase()]; }\n\t    : function (val) { return map[val]; }\n\t}\n\t\n\t/**\n\t * Check if a tag is a built-in tag.\n\t */\n\tvar isBuiltInTag = makeMap('slot,component', true);\n\t\n\t/**\n\t * Remove an item from an array\n\t */\n\tfunction remove$1 (arr, item) {\n\t  if (arr.length) {\n\t    var index = arr.indexOf(item);\n\t    if (index > -1) {\n\t      return arr.splice(index, 1)\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Check whether the object has the property.\n\t */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\tfunction hasOwn (obj, key) {\n\t  return hasOwnProperty.call(obj, key)\n\t}\n\t\n\t/**\n\t * Check if value is primitive\n\t */\n\tfunction isPrimitive (value) {\n\t  return typeof value === 'string' || typeof value === 'number'\n\t}\n\t\n\t/**\n\t * Create a cached version of a pure function.\n\t */\n\tfunction cached (fn) {\n\t  var cache = Object.create(null);\n\t  return (function cachedFn (str) {\n\t    var hit = cache[str];\n\t    return hit || (cache[str] = fn(str))\n\t  })\n\t}\n\t\n\t/**\n\t * Camelize a hyphen-delmited string.\n\t */\n\tvar camelizeRE = /-(\\w)/g;\n\tvar camelize = cached(function (str) {\n\t  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n\t});\n\t\n\t/**\n\t * Capitalize a string.\n\t */\n\tvar capitalize = cached(function (str) {\n\t  return str.charAt(0).toUpperCase() + str.slice(1)\n\t});\n\t\n\t/**\n\t * Hyphenate a camelCase string.\n\t */\n\tvar hyphenateRE = /([^-])([A-Z])/g;\n\tvar hyphenate = cached(function (str) {\n\t  return str\n\t    .replace(hyphenateRE, '$1-$2')\n\t    .replace(hyphenateRE, '$1-$2')\n\t    .toLowerCase()\n\t});\n\t\n\t/**\n\t * Simple bind, faster than native\n\t */\n\tfunction bind$1 (fn, ctx) {\n\t  function boundFn (a) {\n\t    var l = arguments.length;\n\t    return l\n\t      ? l > 1\n\t        ? fn.apply(ctx, arguments)\n\t        : fn.call(ctx, a)\n\t      : fn.call(ctx)\n\t  }\n\t  // record original fn length\n\t  boundFn._length = fn.length;\n\t  return boundFn\n\t}\n\t\n\t/**\n\t * Convert an Array-like object to a real Array.\n\t */\n\tfunction toArray (list, start) {\n\t  start = start || 0;\n\t  var i = list.length - start;\n\t  var ret = new Array(i);\n\t  while (i--) {\n\t    ret[i] = list[i + start];\n\t  }\n\t  return ret\n\t}\n\t\n\t/**\n\t * Mix properties into target object.\n\t */\n\tfunction extend (to, _from) {\n\t  for (var key in _from) {\n\t    to[key] = _from[key];\n\t  }\n\t  return to\n\t}\n\t\n\t/**\n\t * Quick object check - this is primarily used to tell\n\t * Objects from primitive values when we know the value\n\t * is a JSON-compliant type.\n\t */\n\tfunction isObject (obj) {\n\t  return obj !== null && typeof obj === 'object'\n\t}\n\t\n\t/**\n\t * Strict object type check. Only returns true\n\t * for plain JavaScript objects.\n\t */\n\tvar toString = Object.prototype.toString;\n\tvar OBJECT_STRING = '[object Object]';\n\tfunction isPlainObject (obj) {\n\t  return toString.call(obj) === OBJECT_STRING\n\t}\n\t\n\t/**\n\t * Merge an Array of Objects into a single Object.\n\t */\n\tfunction toObject (arr) {\n\t  var res = {};\n\t  for (var i = 0; i < arr.length; i++) {\n\t    if (arr[i]) {\n\t      extend(res, arr[i]);\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\t/**\n\t * Perform no operation.\n\t */\n\tfunction noop () {}\n\t\n\t/**\n\t * Always return false.\n\t */\n\tvar no = function () { return false; };\n\t\n\t/**\n\t * Return same value\n\t */\n\tvar identity = function (_) { return _; };\n\t\n\t/**\n\t * Generate a static keys string from compiler modules.\n\t */\n\tfunction genStaticKeys (modules) {\n\t  return modules.reduce(function (keys, m) {\n\t    return keys.concat(m.staticKeys || [])\n\t  }, []).join(',')\n\t}\n\t\n\t/**\n\t * Check if two values are loosely equal - that is,\n\t * if they are plain objects, do they have the same shape?\n\t */\n\tfunction looseEqual (a, b) {\n\t  var isObjectA = isObject(a);\n\t  var isObjectB = isObject(b);\n\t  if (isObjectA && isObjectB) {\n\t    return JSON.stringify(a) === JSON.stringify(b)\n\t  } else if (!isObjectA && !isObjectB) {\n\t    return String(a) === String(b)\n\t  } else {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction looseIndexOf (arr, val) {\n\t  for (var i = 0; i < arr.length; i++) {\n\t    if (looseEqual(arr[i], val)) { return i }\n\t  }\n\t  return -1\n\t}\n\t\n\t/*  */\n\t\n\tvar config = {\n\t  /**\n\t   * Option merge strategies (used in core/util/options)\n\t   */\n\t  optionMergeStrategies: Object.create(null),\n\t\n\t  /**\n\t   * Whether to suppress warnings.\n\t   */\n\t  silent: false,\n\t\n\t  /**\n\t   * Whether to enable devtools\n\t   */\n\t  devtools: (\"production\") !== 'production',\n\t\n\t  /**\n\t   * Error handler for watcher errors\n\t   */\n\t  errorHandler: null,\n\t\n\t  /**\n\t   * Ignore certain custom elements\n\t   */\n\t  ignoredElements: [],\n\t\n\t  /**\n\t   * Custom user key aliases for v-on\n\t   */\n\t  keyCodes: Object.create(null),\n\t\n\t  /**\n\t   * Check if a tag is reserved so that it cannot be registered as a\n\t   * component. This is platform-dependent and may be overwritten.\n\t   */\n\t  isReservedTag: no,\n\t\n\t  /**\n\t   * Check if a tag is an unknown element.\n\t   * Platform-dependent.\n\t   */\n\t  isUnknownElement: no,\n\t\n\t  /**\n\t   * Get the namespace of an element\n\t   */\n\t  getTagNamespace: noop,\n\t\n\t  /**\n\t   * Parse the real tag name for the specific platform.\n\t   */\n\t  parsePlatformTagName: identity,\n\t\n\t  /**\n\t   * Check if an attribute must be bound using property, e.g. value\n\t   * Platform-dependent.\n\t   */\n\t  mustUseProp: no,\n\t\n\t  /**\n\t   * List of asset types that a component can own.\n\t   */\n\t  _assetTypes: [\n\t    'component',\n\t    'directive',\n\t    'filter'\n\t  ],\n\t\n\t  /**\n\t   * List of lifecycle hooks.\n\t   */\n\t  _lifecycleHooks: [\n\t    'beforeCreate',\n\t    'created',\n\t    'beforeMount',\n\t    'mounted',\n\t    'beforeUpdate',\n\t    'updated',\n\t    'beforeDestroy',\n\t    'destroyed',\n\t    'activated',\n\t    'deactivated'\n\t  ],\n\t\n\t  /**\n\t   * Max circular updates allowed in a scheduler flush cycle.\n\t   */\n\t  _maxUpdateCount: 100\n\t};\n\t\n\t/*  */\n\t\n\t/**\n\t * Check if a string starts with $ or _\n\t */\n\tfunction isReserved (str) {\n\t  var c = (str + '').charCodeAt(0);\n\t  return c === 0x24 || c === 0x5F\n\t}\n\t\n\t/**\n\t * Define a property.\n\t */\n\tfunction def (obj, key, val, enumerable) {\n\t  Object.defineProperty(obj, key, {\n\t    value: val,\n\t    enumerable: !!enumerable,\n\t    writable: true,\n\t    configurable: true\n\t  });\n\t}\n\t\n\t/**\n\t * Parse simple path.\n\t */\n\tvar bailRE = /[^\\w.$]/;\n\tfunction parsePath (path) {\n\t  if (bailRE.test(path)) {\n\t    return\n\t  } else {\n\t    var segments = path.split('.');\n\t    return function (obj) {\n\t      for (var i = 0; i < segments.length; i++) {\n\t        if (!obj) { return }\n\t        obj = obj[segments[i]];\n\t      }\n\t      return obj\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t/* globals MutationObserver */\n\t\n\t// can we use __proto__?\n\tvar hasProto = '__proto__' in {};\n\t\n\t// Browser environment sniffing\n\tvar inBrowser = typeof window !== 'undefined';\n\tvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\n\tvar isIE = UA && /msie|trident/.test(UA);\n\tvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n\tvar isEdge = UA && UA.indexOf('edge/') > 0;\n\tvar isAndroid = UA && UA.indexOf('android') > 0;\n\tvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\t\n\t// this needs to be lazy-evaled because vue may be required before\n\t// vue-server-renderer can set VUE_ENV\n\tvar _isServer;\n\tvar isServerRendering = function () {\n\t  if (_isServer === undefined) {\n\t    /* istanbul ignore if */\n\t    if (!inBrowser && typeof global !== 'undefined') {\n\t      // detect presence of vue-server-renderer and avoid\n\t      // Webpack shimming the process\n\t      _isServer = global['process'].env.VUE_ENV === 'server';\n\t    } else {\n\t      _isServer = false;\n\t    }\n\t  }\n\t  return _isServer\n\t};\n\t\n\t// detect devtools\n\tvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\t\n\t/* istanbul ignore next */\n\tfunction isNative (Ctor) {\n\t  return /native code/.test(Ctor.toString())\n\t}\n\t\n\t/**\n\t * Defer a task to execute it asynchronously.\n\t */\n\tvar nextTick = (function () {\n\t  var callbacks = [];\n\t  var pending = false;\n\t  var timerFunc;\n\t\n\t  function nextTickHandler () {\n\t    pending = false;\n\t    var copies = callbacks.slice(0);\n\t    callbacks.length = 0;\n\t    for (var i = 0; i < copies.length; i++) {\n\t      copies[i]();\n\t    }\n\t  }\n\t\n\t  // the nextTick behavior leverages the microtask queue, which can be accessed\n\t  // via either native Promise.then or MutationObserver.\n\t  // MutationObserver has wider support, however it is seriously bugged in\n\t  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n\t  // completely stops working after triggering a few times... so, if native\n\t  // Promise is available, we will use it:\n\t  /* istanbul ignore if */\n\t  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n\t    var p = Promise.resolve();\n\t    var logError = function (err) { console.error(err); };\n\t    timerFunc = function () {\n\t      p.then(nextTickHandler).catch(logError);\n\t      // in problematic UIWebViews, Promise.then doesn't completely break, but\n\t      // it can get stuck in a weird state where callbacks are pushed into the\n\t      // microtask queue but the queue isn't being flushed, until the browser\n\t      // needs to do some other work, e.g. handle a timer. Therefore we can\n\t      // \"force\" the microtask queue to be flushed by adding an empty timer.\n\t      if (isIOS) { setTimeout(noop); }\n\t    };\n\t  } else if (typeof MutationObserver !== 'undefined' && (\n\t    isNative(MutationObserver) ||\n\t    // PhantomJS and iOS 7.x\n\t    MutationObserver.toString() === '[object MutationObserverConstructor]'\n\t  )) {\n\t    // use MutationObserver where native Promise is not available,\n\t    // e.g. PhantomJS IE11, iOS7, Android 4.4\n\t    var counter = 1;\n\t    var observer = new MutationObserver(nextTickHandler);\n\t    var textNode = document.createTextNode(String(counter));\n\t    observer.observe(textNode, {\n\t      characterData: true\n\t    });\n\t    timerFunc = function () {\n\t      counter = (counter + 1) % 2;\n\t      textNode.data = String(counter);\n\t    };\n\t  } else {\n\t    // fallback to setTimeout\n\t    /* istanbul ignore next */\n\t    timerFunc = function () {\n\t      setTimeout(nextTickHandler, 0);\n\t    };\n\t  }\n\t\n\t  return function queueNextTick (cb, ctx) {\n\t    var _resolve;\n\t    callbacks.push(function () {\n\t      if (cb) { cb.call(ctx); }\n\t      if (_resolve) { _resolve(ctx); }\n\t    });\n\t    if (!pending) {\n\t      pending = true;\n\t      timerFunc();\n\t    }\n\t    if (!cb && typeof Promise !== 'undefined') {\n\t      return new Promise(function (resolve) {\n\t        _resolve = resolve;\n\t      })\n\t    }\n\t  }\n\t})();\n\t\n\tvar _Set;\n\t/* istanbul ignore if */\n\tif (typeof Set !== 'undefined' && isNative(Set)) {\n\t  // use native Set when available.\n\t  _Set = Set;\n\t} else {\n\t  // a non-standard Set polyfill that only works with primitive keys.\n\t  _Set = (function () {\n\t    function Set () {\n\t      this.set = Object.create(null);\n\t    }\n\t    Set.prototype.has = function has (key) {\n\t      return this.set[key] === true\n\t    };\n\t    Set.prototype.add = function add (key) {\n\t      this.set[key] = true;\n\t    };\n\t    Set.prototype.clear = function clear () {\n\t      this.set = Object.create(null);\n\t    };\n\t\n\t    return Set;\n\t  }());\n\t}\n\t\n\tvar warn = noop;\n\tvar formatComponentName;\n\t\n\tif (false) {\n\t  var hasConsole = typeof console !== 'undefined';\n\t\n\t  warn = function (msg, vm) {\n\t    if (hasConsole && (!config.silent)) {\n\t      console.error(\"[Vue warn]: \" + msg + \" \" + (\n\t        vm ? formatLocation(formatComponentName(vm)) : ''\n\t      ));\n\t    }\n\t  };\n\t\n\t  formatComponentName = function (vm) {\n\t    if (vm.$root === vm) {\n\t      return 'root instance'\n\t    }\n\t    var name = vm._isVue\n\t      ? vm.$options.name || vm.$options._componentTag\n\t      : vm.name;\n\t    return (\n\t      (name ? (\"component <\" + name + \">\") : \"anonymous component\") +\n\t      (vm._isVue && vm.$options.__file ? (\" at \" + (vm.$options.__file)) : '')\n\t    )\n\t  };\n\t\n\t  var formatLocation = function (str) {\n\t    if (str === 'anonymous component') {\n\t      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n\t    }\n\t    return (\"\\n(found in \" + str + \")\")\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar uid$1 = 0;\n\t\n\t/**\n\t * A dep is an observable that can have multiple\n\t * directives subscribing to it.\n\t */\n\tvar Dep = function Dep () {\n\t  this.id = uid$1++;\n\t  this.subs = [];\n\t};\n\t\n\tDep.prototype.addSub = function addSub (sub) {\n\t  this.subs.push(sub);\n\t};\n\t\n\tDep.prototype.removeSub = function removeSub (sub) {\n\t  remove$1(this.subs, sub);\n\t};\n\t\n\tDep.prototype.depend = function depend () {\n\t  if (Dep.target) {\n\t    Dep.target.addDep(this);\n\t  }\n\t};\n\t\n\tDep.prototype.notify = function notify () {\n\t  // stablize the subscriber list first\n\t  var subs = this.subs.slice();\n\t  for (var i = 0, l = subs.length; i < l; i++) {\n\t    subs[i].update();\n\t  }\n\t};\n\t\n\t// the current target watcher being evaluated.\n\t// this is globally unique because there could be only one\n\t// watcher being evaluated at any time.\n\tDep.target = null;\n\tvar targetStack = [];\n\t\n\tfunction pushTarget (_target) {\n\t  if (Dep.target) { targetStack.push(Dep.target); }\n\t  Dep.target = _target;\n\t}\n\t\n\tfunction popTarget () {\n\t  Dep.target = targetStack.pop();\n\t}\n\t\n\t/*\n\t * not type checking this file because flow doesn't play well with\n\t * dynamically accessing methods on Array prototype\n\t */\n\t\n\tvar arrayProto = Array.prototype;\n\tvar arrayMethods = Object.create(arrayProto);[\n\t  'push',\n\t  'pop',\n\t  'shift',\n\t  'unshift',\n\t  'splice',\n\t  'sort',\n\t  'reverse'\n\t]\n\t.forEach(function (method) {\n\t  // cache original method\n\t  var original = arrayProto[method];\n\t  def(arrayMethods, method, function mutator () {\n\t    var arguments$1 = arguments;\n\t\n\t    // avoid leaking arguments:\n\t    // http://jsperf.com/closure-with-arguments\n\t    var i = arguments.length;\n\t    var args = new Array(i);\n\t    while (i--) {\n\t      args[i] = arguments$1[i];\n\t    }\n\t    var result = original.apply(this, args);\n\t    var ob = this.__ob__;\n\t    var inserted;\n\t    switch (method) {\n\t      case 'push':\n\t        inserted = args;\n\t        break\n\t      case 'unshift':\n\t        inserted = args;\n\t        break\n\t      case 'splice':\n\t        inserted = args.slice(2);\n\t        break\n\t    }\n\t    if (inserted) { ob.observeArray(inserted); }\n\t    // notify change\n\t    ob.dep.notify();\n\t    return result\n\t  });\n\t});\n\t\n\t/*  */\n\t\n\tvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\t\n\t/**\n\t * By default, when a reactive property is set, the new value is\n\t * also converted to become reactive. However when passing down props,\n\t * we don't want to force conversion because the value may be a nested value\n\t * under a frozen data structure. Converting it would defeat the optimization.\n\t */\n\tvar observerState = {\n\t  shouldConvert: true,\n\t  isSettingProps: false\n\t};\n\t\n\t/**\n\t * Observer class that are attached to each observed\n\t * object. Once attached, the observer converts target\n\t * object's property keys into getter/setters that\n\t * collect dependencies and dispatches updates.\n\t */\n\tvar Observer = function Observer (value) {\n\t  this.value = value;\n\t  this.dep = new Dep();\n\t  this.vmCount = 0;\n\t  def(value, '__ob__', this);\n\t  if (Array.isArray(value)) {\n\t    var augment = hasProto\n\t      ? protoAugment\n\t      : copyAugment;\n\t    augment(value, arrayMethods, arrayKeys);\n\t    this.observeArray(value);\n\t  } else {\n\t    this.walk(value);\n\t  }\n\t};\n\t\n\t/**\n\t * Walk through each property and convert them into\n\t * getter/setters. This method should only be called when\n\t * value type is Object.\n\t */\n\tObserver.prototype.walk = function walk (obj) {\n\t  var keys = Object.keys(obj);\n\t  for (var i = 0; i < keys.length; i++) {\n\t    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n\t  }\n\t};\n\t\n\t/**\n\t * Observe a list of Array items.\n\t */\n\tObserver.prototype.observeArray = function observeArray (items) {\n\t  for (var i = 0, l = items.length; i < l; i++) {\n\t    observe(items[i]);\n\t  }\n\t};\n\t\n\t// helpers\n\t\n\t/**\n\t * Augment an target Object or Array by intercepting\n\t * the prototype chain using __proto__\n\t */\n\tfunction protoAugment (target, src) {\n\t  /* eslint-disable no-proto */\n\t  target.__proto__ = src;\n\t  /* eslint-enable no-proto */\n\t}\n\t\n\t/**\n\t * Augment an target Object or Array by defining\n\t * hidden properties.\n\t */\n\t/* istanbul ignore next */\n\tfunction copyAugment (target, src, keys) {\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    var key = keys[i];\n\t    def(target, key, src[key]);\n\t  }\n\t}\n\t\n\t/**\n\t * Attempt to create an observer instance for a value,\n\t * returns the new observer if successfully observed,\n\t * or the existing observer if the value already has one.\n\t */\n\tfunction observe (value, asRootData) {\n\t  if (!isObject(value)) {\n\t    return\n\t  }\n\t  var ob;\n\t  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n\t    ob = value.__ob__;\n\t  } else if (\n\t    observerState.shouldConvert &&\n\t    !isServerRendering() &&\n\t    (Array.isArray(value) || isPlainObject(value)) &&\n\t    Object.isExtensible(value) &&\n\t    !value._isVue\n\t  ) {\n\t    ob = new Observer(value);\n\t  }\n\t  if (asRootData && ob) {\n\t    ob.vmCount++;\n\t  }\n\t  return ob\n\t}\n\t\n\t/**\n\t * Define a reactive property on an Object.\n\t */\n\tfunction defineReactive$$1 (\n\t  obj,\n\t  key,\n\t  val,\n\t  customSetter\n\t) {\n\t  var dep = new Dep();\n\t\n\t  var property = Object.getOwnPropertyDescriptor(obj, key);\n\t  if (property && property.configurable === false) {\n\t    return\n\t  }\n\t\n\t  // cater for pre-defined getter/setters\n\t  var getter = property && property.get;\n\t  var setter = property && property.set;\n\t\n\t  var childOb = observe(val);\n\t  Object.defineProperty(obj, key, {\n\t    enumerable: true,\n\t    configurable: true,\n\t    get: function reactiveGetter () {\n\t      var value = getter ? getter.call(obj) : val;\n\t      if (Dep.target) {\n\t        dep.depend();\n\t        if (childOb) {\n\t          childOb.dep.depend();\n\t        }\n\t        if (Array.isArray(value)) {\n\t          dependArray(value);\n\t        }\n\t      }\n\t      return value\n\t    },\n\t    set: function reactiveSetter (newVal) {\n\t      var value = getter ? getter.call(obj) : val;\n\t      /* eslint-disable no-self-compare */\n\t      if (newVal === value || (newVal !== newVal && value !== value)) {\n\t        return\n\t      }\n\t      /* eslint-enable no-self-compare */\n\t      if (false) {\n\t        customSetter();\n\t      }\n\t      if (setter) {\n\t        setter.call(obj, newVal);\n\t      } else {\n\t        val = newVal;\n\t      }\n\t      childOb = observe(newVal);\n\t      dep.notify();\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * Set a property on an object. Adds the new property and\n\t * triggers change notification if the property doesn't\n\t * already exist.\n\t */\n\tfunction set$1 (obj, key, val) {\n\t  if (Array.isArray(obj)) {\n\t    obj.length = Math.max(obj.length, key);\n\t    obj.splice(key, 1, val);\n\t    return val\n\t  }\n\t  if (hasOwn(obj, key)) {\n\t    obj[key] = val;\n\t    return\n\t  }\n\t  var ob = obj.__ob__;\n\t  if (obj._isVue || (ob && ob.vmCount)) {\n\t    (\"production\") !== 'production' && warn(\n\t      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n\t      'at runtime - declare it upfront in the data option.'\n\t    );\n\t    return\n\t  }\n\t  if (!ob) {\n\t    obj[key] = val;\n\t    return\n\t  }\n\t  defineReactive$$1(ob.value, key, val);\n\t  ob.dep.notify();\n\t  return val\n\t}\n\t\n\t/**\n\t * Delete a property and trigger change if necessary.\n\t */\n\tfunction del (obj, key) {\n\t  var ob = obj.__ob__;\n\t  if (obj._isVue || (ob && ob.vmCount)) {\n\t    (\"production\") !== 'production' && warn(\n\t      'Avoid deleting properties on a Vue instance or its root $data ' +\n\t      '- just set it to null.'\n\t    );\n\t    return\n\t  }\n\t  if (!hasOwn(obj, key)) {\n\t    return\n\t  }\n\t  delete obj[key];\n\t  if (!ob) {\n\t    return\n\t  }\n\t  ob.dep.notify();\n\t}\n\t\n\t/**\n\t * Collect dependencies on array elements when the array is touched, since\n\t * we cannot intercept array element access like property getters.\n\t */\n\tfunction dependArray (value) {\n\t  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n\t    e = value[i];\n\t    e && e.__ob__ && e.__ob__.dep.depend();\n\t    if (Array.isArray(e)) {\n\t      dependArray(e);\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t/**\n\t * Option overwriting strategies are functions that handle\n\t * how to merge a parent option value and a child option\n\t * value into the final value.\n\t */\n\tvar strats = config.optionMergeStrategies;\n\t\n\t/**\n\t * Options with restrictions\n\t */\n\tif (false) {\n\t  strats.el = strats.propsData = function (parent, child, vm, key) {\n\t    if (!vm) {\n\t      warn(\n\t        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n\t        'creation with the `new` keyword.'\n\t      );\n\t    }\n\t    return defaultStrat(parent, child)\n\t  };\n\t}\n\t\n\t/**\n\t * Helper that recursively merges two data objects together.\n\t */\n\tfunction mergeData (to, from) {\n\t  if (!from) { return to }\n\t  var key, toVal, fromVal;\n\t  var keys = Object.keys(from);\n\t  for (var i = 0; i < keys.length; i++) {\n\t    key = keys[i];\n\t    toVal = to[key];\n\t    fromVal = from[key];\n\t    if (!hasOwn(to, key)) {\n\t      set$1(to, key, fromVal);\n\t    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n\t      mergeData(toVal, fromVal);\n\t    }\n\t  }\n\t  return to\n\t}\n\t\n\t/**\n\t * Data\n\t */\n\tstrats.data = function (\n\t  parentVal,\n\t  childVal,\n\t  vm\n\t) {\n\t  if (!vm) {\n\t    // in a Vue.extend merge, both should be functions\n\t    if (!childVal) {\n\t      return parentVal\n\t    }\n\t    if (typeof childVal !== 'function') {\n\t      (\"production\") !== 'production' && warn(\n\t        'The \"data\" option should be a function ' +\n\t        'that returns a per-instance value in component ' +\n\t        'definitions.',\n\t        vm\n\t      );\n\t      return parentVal\n\t    }\n\t    if (!parentVal) {\n\t      return childVal\n\t    }\n\t    // when parentVal & childVal are both present,\n\t    // we need to return a function that returns the\n\t    // merged result of both functions... no need to\n\t    // check if parentVal is a function here because\n\t    // it has to be a function to pass previous merges.\n\t    return function mergedDataFn () {\n\t      return mergeData(\n\t        childVal.call(this),\n\t        parentVal.call(this)\n\t      )\n\t    }\n\t  } else if (parentVal || childVal) {\n\t    return function mergedInstanceDataFn () {\n\t      // instance merge\n\t      var instanceData = typeof childVal === 'function'\n\t        ? childVal.call(vm)\n\t        : childVal;\n\t      var defaultData = typeof parentVal === 'function'\n\t        ? parentVal.call(vm)\n\t        : undefined;\n\t      if (instanceData) {\n\t        return mergeData(instanceData, defaultData)\n\t      } else {\n\t        return defaultData\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Hooks and param attributes are merged as arrays.\n\t */\n\tfunction mergeHook (\n\t  parentVal,\n\t  childVal\n\t) {\n\t  return childVal\n\t    ? parentVal\n\t      ? parentVal.concat(childVal)\n\t      : Array.isArray(childVal)\n\t        ? childVal\n\t        : [childVal]\n\t    : parentVal\n\t}\n\t\n\tconfig._lifecycleHooks.forEach(function (hook) {\n\t  strats[hook] = mergeHook;\n\t});\n\t\n\t/**\n\t * Assets\n\t *\n\t * When a vm is present (instance creation), we need to do\n\t * a three-way merge between constructor options, instance\n\t * options and parent options.\n\t */\n\tfunction mergeAssets (parentVal, childVal) {\n\t  var res = Object.create(parentVal || null);\n\t  return childVal\n\t    ? extend(res, childVal)\n\t    : res\n\t}\n\t\n\tconfig._assetTypes.forEach(function (type) {\n\t  strats[type + 's'] = mergeAssets;\n\t});\n\t\n\t/**\n\t * Watchers.\n\t *\n\t * Watchers hashes should not overwrite one\n\t * another, so we merge them as arrays.\n\t */\n\tstrats.watch = function (parentVal, childVal) {\n\t  /* istanbul ignore if */\n\t  if (!childVal) { return parentVal }\n\t  if (!parentVal) { return childVal }\n\t  var ret = {};\n\t  extend(ret, parentVal);\n\t  for (var key in childVal) {\n\t    var parent = ret[key];\n\t    var child = childVal[key];\n\t    if (parent && !Array.isArray(parent)) {\n\t      parent = [parent];\n\t    }\n\t    ret[key] = parent\n\t      ? parent.concat(child)\n\t      : [child];\n\t  }\n\t  return ret\n\t};\n\t\n\t/**\n\t * Other object hashes.\n\t */\n\tstrats.props =\n\tstrats.methods =\n\tstrats.computed = function (parentVal, childVal) {\n\t  if (!childVal) { return parentVal }\n\t  if (!parentVal) { return childVal }\n\t  var ret = Object.create(null);\n\t  extend(ret, parentVal);\n\t  extend(ret, childVal);\n\t  return ret\n\t};\n\t\n\t/**\n\t * Default strategy.\n\t */\n\tvar defaultStrat = function (parentVal, childVal) {\n\t  return childVal === undefined\n\t    ? parentVal\n\t    : childVal\n\t};\n\t\n\t/**\n\t * Validate component names\n\t */\n\tfunction checkComponents (options) {\n\t  for (var key in options.components) {\n\t    var lower = key.toLowerCase();\n\t    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n\t      warn(\n\t        'Do not use built-in or reserved HTML elements as component ' +\n\t        'id: ' + key\n\t      );\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Ensure all props option syntax are normalized into the\n\t * Object-based format.\n\t */\n\tfunction normalizeProps (options) {\n\t  var props = options.props;\n\t  if (!props) { return }\n\t  var res = {};\n\t  var i, val, name;\n\t  if (Array.isArray(props)) {\n\t    i = props.length;\n\t    while (i--) {\n\t      val = props[i];\n\t      if (typeof val === 'string') {\n\t        name = camelize(val);\n\t        res[name] = { type: null };\n\t      } else if (false) {\n\t        warn('props must be strings when using array syntax.');\n\t      }\n\t    }\n\t  } else if (isPlainObject(props)) {\n\t    for (var key in props) {\n\t      val = props[key];\n\t      name = camelize(key);\n\t      res[name] = isPlainObject(val)\n\t        ? val\n\t        : { type: val };\n\t    }\n\t  }\n\t  options.props = res;\n\t}\n\t\n\t/**\n\t * Normalize raw function directives into object format.\n\t */\n\tfunction normalizeDirectives (options) {\n\t  var dirs = options.directives;\n\t  if (dirs) {\n\t    for (var key in dirs) {\n\t      var def = dirs[key];\n\t      if (typeof def === 'function') {\n\t        dirs[key] = { bind: def, update: def };\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Merge two option objects into a new one.\n\t * Core utility used in both instantiation and inheritance.\n\t */\n\tfunction mergeOptions (\n\t  parent,\n\t  child,\n\t  vm\n\t) {\n\t  if (false) {\n\t    checkComponents(child);\n\t  }\n\t  normalizeProps(child);\n\t  normalizeDirectives(child);\n\t  var extendsFrom = child.extends;\n\t  if (extendsFrom) {\n\t    parent = typeof extendsFrom === 'function'\n\t      ? mergeOptions(parent, extendsFrom.options, vm)\n\t      : mergeOptions(parent, extendsFrom, vm);\n\t  }\n\t  if (child.mixins) {\n\t    for (var i = 0, l = child.mixins.length; i < l; i++) {\n\t      var mixin = child.mixins[i];\n\t      if (mixin.prototype instanceof Vue$2) {\n\t        mixin = mixin.options;\n\t      }\n\t      parent = mergeOptions(parent, mixin, vm);\n\t    }\n\t  }\n\t  var options = {};\n\t  var key;\n\t  for (key in parent) {\n\t    mergeField(key);\n\t  }\n\t  for (key in child) {\n\t    if (!hasOwn(parent, key)) {\n\t      mergeField(key);\n\t    }\n\t  }\n\t  function mergeField (key) {\n\t    var strat = strats[key] || defaultStrat;\n\t    options[key] = strat(parent[key], child[key], vm, key);\n\t  }\n\t  return options\n\t}\n\t\n\t/**\n\t * Resolve an asset.\n\t * This function is used because child instances need access\n\t * to assets defined in its ancestor chain.\n\t */\n\tfunction resolveAsset (\n\t  options,\n\t  type,\n\t  id,\n\t  warnMissing\n\t) {\n\t  /* istanbul ignore if */\n\t  if (typeof id !== 'string') {\n\t    return\n\t  }\n\t  var assets = options[type];\n\t  // check local registration variations first\n\t  if (hasOwn(assets, id)) { return assets[id] }\n\t  var camelizedId = camelize(id);\n\t  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n\t  var PascalCaseId = capitalize(camelizedId);\n\t  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n\t  // fallback to prototype chain\n\t  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\t  if (false) {\n\t    warn(\n\t      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n\t      options\n\t    );\n\t  }\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tfunction validateProp (\n\t  key,\n\t  propOptions,\n\t  propsData,\n\t  vm\n\t) {\n\t  var prop = propOptions[key];\n\t  var absent = !hasOwn(propsData, key);\n\t  var value = propsData[key];\n\t  // handle boolean props\n\t  if (isType(Boolean, prop.type)) {\n\t    if (absent && !hasOwn(prop, 'default')) {\n\t      value = false;\n\t    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n\t      value = true;\n\t    }\n\t  }\n\t  // check default value\n\t  if (value === undefined) {\n\t    value = getPropDefaultValue(vm, prop, key);\n\t    // since the default value is a fresh copy,\n\t    // make sure to observe it.\n\t    var prevShouldConvert = observerState.shouldConvert;\n\t    observerState.shouldConvert = true;\n\t    observe(value);\n\t    observerState.shouldConvert = prevShouldConvert;\n\t  }\n\t  if (false) {\n\t    assertProp(prop, key, value, vm, absent);\n\t  }\n\t  return value\n\t}\n\t\n\t/**\n\t * Get the default value of a prop.\n\t */\n\tfunction getPropDefaultValue (vm, prop, key) {\n\t  // no default, return undefined\n\t  if (!hasOwn(prop, 'default')) {\n\t    return undefined\n\t  }\n\t  var def = prop.default;\n\t  // warn against non-factory defaults for Object & Array\n\t  if (isObject(def)) {\n\t    (\"production\") !== 'production' && warn(\n\t      'Invalid default value for prop \"' + key + '\": ' +\n\t      'Props with type Object/Array must use a factory function ' +\n\t      'to return the default value.',\n\t      vm\n\t    );\n\t  }\n\t  // the raw prop value was also undefined from previous render,\n\t  // return previous default value to avoid unnecessary watcher trigger\n\t  if (vm && vm.$options.propsData &&\n\t    vm.$options.propsData[key] === undefined &&\n\t    vm[key] !== undefined) {\n\t    return vm[key]\n\t  }\n\t  // call factory function for non-Function types\n\t  return typeof def === 'function' && prop.type !== Function\n\t    ? def.call(vm)\n\t    : def\n\t}\n\t\n\t/**\n\t * Assert whether a prop is valid.\n\t */\n\tfunction assertProp (\n\t  prop,\n\t  name,\n\t  value,\n\t  vm,\n\t  absent\n\t) {\n\t  if (prop.required && absent) {\n\t    warn(\n\t      'Missing required prop: \"' + name + '\"',\n\t      vm\n\t    );\n\t    return\n\t  }\n\t  if (value == null && !prop.required) {\n\t    return\n\t  }\n\t  var type = prop.type;\n\t  var valid = !type || type === true;\n\t  var expectedTypes = [];\n\t  if (type) {\n\t    if (!Array.isArray(type)) {\n\t      type = [type];\n\t    }\n\t    for (var i = 0; i < type.length && !valid; i++) {\n\t      var assertedType = assertType(value, type[i]);\n\t      expectedTypes.push(assertedType.expectedType || '');\n\t      valid = assertedType.valid;\n\t    }\n\t  }\n\t  if (!valid) {\n\t    warn(\n\t      'Invalid prop: type check failed for prop \"' + name + '\".' +\n\t      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n\t      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n\t      vm\n\t    );\n\t    return\n\t  }\n\t  var validator = prop.validator;\n\t  if (validator) {\n\t    if (!validator(value)) {\n\t      warn(\n\t        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n\t        vm\n\t      );\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Assert the type of a value\n\t */\n\tfunction assertType (value, type) {\n\t  var valid;\n\t  var expectedType = getType(type);\n\t  if (expectedType === 'String') {\n\t    valid = typeof value === (expectedType = 'string');\n\t  } else if (expectedType === 'Number') {\n\t    valid = typeof value === (expectedType = 'number');\n\t  } else if (expectedType === 'Boolean') {\n\t    valid = typeof value === (expectedType = 'boolean');\n\t  } else if (expectedType === 'Function') {\n\t    valid = typeof value === (expectedType = 'function');\n\t  } else if (expectedType === 'Object') {\n\t    valid = isPlainObject(value);\n\t  } else if (expectedType === 'Array') {\n\t    valid = Array.isArray(value);\n\t  } else {\n\t    valid = value instanceof type;\n\t  }\n\t  return {\n\t    valid: valid,\n\t    expectedType: expectedType\n\t  }\n\t}\n\t\n\t/**\n\t * Use function string name to check built-in types,\n\t * because a simple equality check will fail when running\n\t * across different vms / iframes.\n\t */\n\tfunction getType (fn) {\n\t  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n\t  return match && match[1]\n\t}\n\t\n\tfunction isType (type, fn) {\n\t  if (!Array.isArray(fn)) {\n\t    return getType(fn) === getType(type)\n\t  }\n\t  for (var i = 0, len = fn.length; i < len; i++) {\n\t    if (getType(fn[i]) === getType(type)) {\n\t      return true\n\t    }\n\t  }\n\t  /* istanbul ignore next */\n\t  return false\n\t}\n\t\n\t\n\t\n\tvar util = Object.freeze({\n\t\tdefineReactive: defineReactive$$1,\n\t\t_toString: _toString,\n\t\ttoNumber: toNumber,\n\t\tmakeMap: makeMap,\n\t\tisBuiltInTag: isBuiltInTag,\n\t\tremove: remove$1,\n\t\thasOwn: hasOwn,\n\t\tisPrimitive: isPrimitive,\n\t\tcached: cached,\n\t\tcamelize: camelize,\n\t\tcapitalize: capitalize,\n\t\thyphenate: hyphenate,\n\t\tbind: bind$1,\n\t\ttoArray: toArray,\n\t\textend: extend,\n\t\tisObject: isObject,\n\t\tisPlainObject: isPlainObject,\n\t\ttoObject: toObject,\n\t\tnoop: noop,\n\t\tno: no,\n\t\tidentity: identity,\n\t\tgenStaticKeys: genStaticKeys,\n\t\tlooseEqual: looseEqual,\n\t\tlooseIndexOf: looseIndexOf,\n\t\tisReserved: isReserved,\n\t\tdef: def,\n\t\tparsePath: parsePath,\n\t\thasProto: hasProto,\n\t\tinBrowser: inBrowser,\n\t\tUA: UA,\n\t\tisIE: isIE,\n\t\tisIE9: isIE9,\n\t\tisEdge: isEdge,\n\t\tisAndroid: isAndroid,\n\t\tisIOS: isIOS,\n\t\tisServerRendering: isServerRendering,\n\t\tdevtools: devtools,\n\t\tnextTick: nextTick,\n\t\tget _Set () { return _Set; },\n\t\tmergeOptions: mergeOptions,\n\t\tresolveAsset: resolveAsset,\n\t\tget warn () { return warn; },\n\t\tget formatComponentName () { return formatComponentName; },\n\t\tvalidateProp: validateProp\n\t});\n\t\n\t/* not type checking this file because flow doesn't play well with Proxy */\n\t\n\tvar initProxy;\n\t\n\tif (false) {\n\t  var allowedGlobals = makeMap(\n\t    'Infinity,undefined,NaN,isFinite,isNaN,' +\n\t    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n\t    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n\t    'require' // for Webpack/Browserify\n\t  );\n\t\n\t  var warnNonPresent = function (target, key) {\n\t    warn(\n\t      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n\t      \"referenced during render. Make sure to declare reactive data \" +\n\t      \"properties in the data option.\",\n\t      target\n\t    );\n\t  };\n\t\n\t  var hasProxy =\n\t    typeof Proxy !== 'undefined' &&\n\t    Proxy.toString().match(/native code/);\n\t\n\t  if (hasProxy) {\n\t    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n\t    config.keyCodes = new Proxy(config.keyCodes, {\n\t      set: function set (target, key, value) {\n\t        if (isBuiltInModifier(key)) {\n\t          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n\t          return false\n\t        } else {\n\t          target[key] = value;\n\t          return true\n\t        }\n\t      }\n\t    });\n\t  }\n\t\n\t  var hasHandler = {\n\t    has: function has (target, key) {\n\t      var has = key in target;\n\t      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n\t      if (!has && !isAllowed) {\n\t        warnNonPresent(target, key);\n\t      }\n\t      return has || !isAllowed\n\t    }\n\t  };\n\t\n\t  var getHandler = {\n\t    get: function get (target, key) {\n\t      if (typeof key === 'string' && !(key in target)) {\n\t        warnNonPresent(target, key);\n\t      }\n\t      return target[key]\n\t    }\n\t  };\n\t\n\t  initProxy = function initProxy (vm) {\n\t    if (hasProxy) {\n\t      // determine which proxy handler to use\n\t      var options = vm.$options;\n\t      var handlers = options.render && options.render._withStripped\n\t        ? getHandler\n\t        : hasHandler;\n\t      vm._renderProxy = new Proxy(vm, handlers);\n\t    } else {\n\t      vm._renderProxy = vm;\n\t    }\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar queue = [];\n\tvar has$1 = {};\n\tvar circular = {};\n\tvar waiting = false;\n\tvar flushing = false;\n\tvar index = 0;\n\t\n\t/**\n\t * Reset the scheduler's state.\n\t */\n\tfunction resetSchedulerState () {\n\t  queue.length = 0;\n\t  has$1 = {};\n\t  if (false) {\n\t    circular = {};\n\t  }\n\t  waiting = flushing = false;\n\t}\n\t\n\t/**\n\t * Flush both queues and run the watchers.\n\t */\n\tfunction flushSchedulerQueue () {\n\t  flushing = true;\n\t\n\t  // Sort queue before flush.\n\t  // This ensures that:\n\t  // 1. Components are updated from parent to child. (because parent is always\n\t  //    created before the child)\n\t  // 2. A component's user watchers are run before its render watcher (because\n\t  //    user watchers are created before the render watcher)\n\t  // 3. If a component is destroyed during a parent component's watcher run,\n\t  //    its watchers can be skipped.\n\t  queue.sort(function (a, b) { return a.id - b.id; });\n\t\n\t  // do not cache length because more watchers might be pushed\n\t  // as we run existing watchers\n\t  for (index = 0; index < queue.length; index++) {\n\t    var watcher = queue[index];\n\t    var id = watcher.id;\n\t    has$1[id] = null;\n\t    watcher.run();\n\t    // in dev build, check and stop circular updates.\n\t    if (false) {\n\t      circular[id] = (circular[id] || 0) + 1;\n\t      if (circular[id] > config._maxUpdateCount) {\n\t        warn(\n\t          'You may have an infinite update loop ' + (\n\t            watcher.user\n\t              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n\t              : \"in a component render function.\"\n\t          ),\n\t          watcher.vm\n\t        );\n\t        break\n\t      }\n\t    }\n\t  }\n\t\n\t  // devtool hook\n\t  /* istanbul ignore if */\n\t  if (devtools && config.devtools) {\n\t    devtools.emit('flush');\n\t  }\n\t\n\t  resetSchedulerState();\n\t}\n\t\n\t/**\n\t * Push a watcher into the watcher queue.\n\t * Jobs with duplicate IDs will be skipped unless it's\n\t * pushed when the queue is being flushed.\n\t */\n\tfunction queueWatcher (watcher) {\n\t  var id = watcher.id;\n\t  if (has$1[id] == null) {\n\t    has$1[id] = true;\n\t    if (!flushing) {\n\t      queue.push(watcher);\n\t    } else {\n\t      // if already flushing, splice the watcher based on its id\n\t      // if already past its id, it will be run next immediately.\n\t      var i = queue.length - 1;\n\t      while (i >= 0 && queue[i].id > watcher.id) {\n\t        i--;\n\t      }\n\t      queue.splice(Math.max(i, index) + 1, 0, watcher);\n\t    }\n\t    // queue the flush\n\t    if (!waiting) {\n\t      waiting = true;\n\t      nextTick(flushSchedulerQueue);\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar uid$2 = 0;\n\t\n\t/**\n\t * A watcher parses an expression, collects dependencies,\n\t * and fires callback when the expression value changes.\n\t * This is used for both the $watch() api and directives.\n\t */\n\tvar Watcher = function Watcher (\n\t  vm,\n\t  expOrFn,\n\t  cb,\n\t  options\n\t) {\n\t  this.vm = vm;\n\t  vm._watchers.push(this);\n\t  // options\n\t  if (options) {\n\t    this.deep = !!options.deep;\n\t    this.user = !!options.user;\n\t    this.lazy = !!options.lazy;\n\t    this.sync = !!options.sync;\n\t  } else {\n\t    this.deep = this.user = this.lazy = this.sync = false;\n\t  }\n\t  this.cb = cb;\n\t  this.id = ++uid$2; // uid for batching\n\t  this.active = true;\n\t  this.dirty = this.lazy; // for lazy watchers\n\t  this.deps = [];\n\t  this.newDeps = [];\n\t  this.depIds = new _Set();\n\t  this.newDepIds = new _Set();\n\t  this.expression =  false\n\t    ? expOrFn.toString()\n\t    : '';\n\t  // parse expression for getter\n\t  if (typeof expOrFn === 'function') {\n\t    this.getter = expOrFn;\n\t  } else {\n\t    this.getter = parsePath(expOrFn);\n\t    if (!this.getter) {\n\t      this.getter = function () {};\n\t      (\"production\") !== 'production' && warn(\n\t        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n\t        'Watcher only accepts simple dot-delimited paths. ' +\n\t        'For full control, use a function instead.',\n\t        vm\n\t      );\n\t    }\n\t  }\n\t  this.value = this.lazy\n\t    ? undefined\n\t    : this.get();\n\t};\n\t\n\t/**\n\t * Evaluate the getter, and re-collect dependencies.\n\t */\n\tWatcher.prototype.get = function get () {\n\t  pushTarget(this);\n\t  var value = this.getter.call(this.vm, this.vm);\n\t  // \"touch\" every property so they are all tracked as\n\t  // dependencies for deep watching\n\t  if (this.deep) {\n\t    traverse(value);\n\t  }\n\t  popTarget();\n\t  this.cleanupDeps();\n\t  return value\n\t};\n\t\n\t/**\n\t * Add a dependency to this directive.\n\t */\n\tWatcher.prototype.addDep = function addDep (dep) {\n\t  var id = dep.id;\n\t  if (!this.newDepIds.has(id)) {\n\t    this.newDepIds.add(id);\n\t    this.newDeps.push(dep);\n\t    if (!this.depIds.has(id)) {\n\t      dep.addSub(this);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Clean up for dependency collection.\n\t */\n\tWatcher.prototype.cleanupDeps = function cleanupDeps () {\n\t    var this$1 = this;\n\t\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    var dep = this$1.deps[i];\n\t    if (!this$1.newDepIds.has(dep.id)) {\n\t      dep.removeSub(this$1);\n\t    }\n\t  }\n\t  var tmp = this.depIds;\n\t  this.depIds = this.newDepIds;\n\t  this.newDepIds = tmp;\n\t  this.newDepIds.clear();\n\t  tmp = this.deps;\n\t  this.deps = this.newDeps;\n\t  this.newDeps = tmp;\n\t  this.newDeps.length = 0;\n\t};\n\t\n\t/**\n\t * Subscriber interface.\n\t * Will be called when a dependency changes.\n\t */\n\tWatcher.prototype.update = function update () {\n\t  /* istanbul ignore else */\n\t  if (this.lazy) {\n\t    this.dirty = true;\n\t  } else if (this.sync) {\n\t    this.run();\n\t  } else {\n\t    queueWatcher(this);\n\t  }\n\t};\n\t\n\t/**\n\t * Scheduler job interface.\n\t * Will be called by the scheduler.\n\t */\n\tWatcher.prototype.run = function run () {\n\t  if (this.active) {\n\t    var value = this.get();\n\t    if (\n\t      value !== this.value ||\n\t      // Deep watchers and watchers on Object/Arrays should fire even\n\t      // when the value is the same, because the value may\n\t      // have mutated.\n\t      isObject(value) ||\n\t      this.deep\n\t    ) {\n\t      // set new value\n\t      var oldValue = this.value;\n\t      this.value = value;\n\t      if (this.user) {\n\t        try {\n\t          this.cb.call(this.vm, value, oldValue);\n\t        } catch (e) {\n\t          /* istanbul ignore else */\n\t          if (config.errorHandler) {\n\t            config.errorHandler.call(null, e, this.vm);\n\t          } else {\n\t            (\"production\") !== 'production' && warn(\n\t              (\"Error in watcher \\\"\" + (this.expression) + \"\\\"\"),\n\t              this.vm\n\t            );\n\t            throw e\n\t          }\n\t        }\n\t      } else {\n\t        this.cb.call(this.vm, value, oldValue);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Evaluate the value of the watcher.\n\t * This only gets called for lazy watchers.\n\t */\n\tWatcher.prototype.evaluate = function evaluate () {\n\t  this.value = this.get();\n\t  this.dirty = false;\n\t};\n\t\n\t/**\n\t * Depend on all deps collected by this watcher.\n\t */\n\tWatcher.prototype.depend = function depend () {\n\t    var this$1 = this;\n\t\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    this$1.deps[i].depend();\n\t  }\n\t};\n\t\n\t/**\n\t * Remove self from all dependencies' subscriber list.\n\t */\n\tWatcher.prototype.teardown = function teardown () {\n\t    var this$1 = this;\n\t\n\t  if (this.active) {\n\t    // remove self from vm's watcher list\n\t    // this is a somewhat expensive operation so we skip it\n\t    // if the vm is being destroyed.\n\t    if (!this.vm._isBeingDestroyed) {\n\t      remove$1(this.vm._watchers, this);\n\t    }\n\t    var i = this.deps.length;\n\t    while (i--) {\n\t      this$1.deps[i].removeSub(this$1);\n\t    }\n\t    this.active = false;\n\t  }\n\t};\n\t\n\t/**\n\t * Recursively traverse an object to evoke all converted\n\t * getters, so that every nested property inside the object\n\t * is collected as a \"deep\" dependency.\n\t */\n\tvar seenObjects = new _Set();\n\tfunction traverse (val) {\n\t  seenObjects.clear();\n\t  _traverse(val, seenObjects);\n\t}\n\t\n\tfunction _traverse (val, seen) {\n\t  var i, keys;\n\t  var isA = Array.isArray(val);\n\t  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n\t    return\n\t  }\n\t  if (val.__ob__) {\n\t    var depId = val.__ob__.dep.id;\n\t    if (seen.has(depId)) {\n\t      return\n\t    }\n\t    seen.add(depId);\n\t  }\n\t  if (isA) {\n\t    i = val.length;\n\t    while (i--) { _traverse(val[i], seen); }\n\t  } else {\n\t    keys = Object.keys(val);\n\t    i = keys.length;\n\t    while (i--) { _traverse(val[keys[i]], seen); }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction initState (vm) {\n\t  vm._watchers = [];\n\t  var opts = vm.$options;\n\t  if (opts.props) { initProps(vm, opts.props); }\n\t  if (opts.methods) { initMethods(vm, opts.methods); }\n\t  if (opts.data) {\n\t    initData(vm);\n\t  } else {\n\t    observe(vm._data = {}, true /* asRootData */);\n\t  }\n\t  if (opts.computed) { initComputed(vm, opts.computed); }\n\t  if (opts.watch) { initWatch(vm, opts.watch); }\n\t}\n\t\n\tvar isReservedProp = { key: 1, ref: 1, slot: 1 };\n\t\n\tfunction initProps (vm, props) {\n\t  var propsData = vm.$options.propsData || {};\n\t  var keys = vm.$options._propKeys = Object.keys(props);\n\t  var isRoot = !vm.$parent;\n\t  // root instance props should be converted\n\t  observerState.shouldConvert = isRoot;\n\t  var loop = function ( i ) {\n\t    var key = keys[i];\n\t    /* istanbul ignore else */\n\t    if (false) {\n\t      if (isReservedProp[key]) {\n\t        warn(\n\t          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n\t          vm\n\t        );\n\t      }\n\t      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {\n\t        if (vm.$parent && !observerState.isSettingProps) {\n\t          warn(\n\t            \"Avoid mutating a prop directly since the value will be \" +\n\t            \"overwritten whenever the parent component re-renders. \" +\n\t            \"Instead, use a data or computed property based on the prop's \" +\n\t            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n\t            vm\n\t          );\n\t        }\n\t      });\n\t    } else {\n\t      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm));\n\t    }\n\t  };\n\t\n\t  for (var i = 0; i < keys.length; i++) loop( i );\n\t  observerState.shouldConvert = true;\n\t}\n\t\n\tfunction initData (vm) {\n\t  var data = vm.$options.data;\n\t  data = vm._data = typeof data === 'function'\n\t    ? data.call(vm)\n\t    : data || {};\n\t  if (!isPlainObject(data)) {\n\t    data = {};\n\t    (\"production\") !== 'production' && warn(\n\t      'data functions should return an object:\\n' +\n\t      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n\t      vm\n\t    );\n\t  }\n\t  // proxy data on instance\n\t  var keys = Object.keys(data);\n\t  var props = vm.$options.props;\n\t  var i = keys.length;\n\t  while (i--) {\n\t    if (props && hasOwn(props, keys[i])) {\n\t      (\"production\") !== 'production' && warn(\n\t        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n\t        \"Use prop default value instead.\",\n\t        vm\n\t      );\n\t    } else {\n\t      proxy(vm, keys[i]);\n\t    }\n\t  }\n\t  // observe data\n\t  observe(data, true /* asRootData */);\n\t}\n\t\n\tvar computedSharedDefinition = {\n\t  enumerable: true,\n\t  configurable: true,\n\t  get: noop,\n\t  set: noop\n\t};\n\t\n\tfunction initComputed (vm, computed) {\n\t  for (var key in computed) {\n\t    /* istanbul ignore if */\n\t    if (false) {\n\t      warn(\n\t        \"existing instance property \\\"\" + key + \"\\\" will be \" +\n\t        \"overwritten by a computed property with the same name.\",\n\t        vm\n\t      );\n\t    }\n\t    var userDef = computed[key];\n\t    if (typeof userDef === 'function') {\n\t      computedSharedDefinition.get = makeComputedGetter(userDef, vm);\n\t      computedSharedDefinition.set = noop;\n\t    } else {\n\t      computedSharedDefinition.get = userDef.get\n\t        ? userDef.cache !== false\n\t          ? makeComputedGetter(userDef.get, vm)\n\t          : bind$1(userDef.get, vm)\n\t        : noop;\n\t      computedSharedDefinition.set = userDef.set\n\t        ? bind$1(userDef.set, vm)\n\t        : noop;\n\t    }\n\t    Object.defineProperty(vm, key, computedSharedDefinition);\n\t  }\n\t}\n\t\n\tfunction makeComputedGetter (getter, owner) {\n\t  var watcher = new Watcher(owner, getter, noop, {\n\t    lazy: true\n\t  });\n\t  return function computedGetter () {\n\t    if (watcher.dirty) {\n\t      watcher.evaluate();\n\t    }\n\t    if (Dep.target) {\n\t      watcher.depend();\n\t    }\n\t    return watcher.value\n\t  }\n\t}\n\t\n\tfunction initMethods (vm, methods) {\n\t  for (var key in methods) {\n\t    vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);\n\t    if (false) {\n\t      warn(\n\t        \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n\t        \"Did you reference the function correctly?\",\n\t        vm\n\t      );\n\t    }\n\t  }\n\t}\n\t\n\tfunction initWatch (vm, watch) {\n\t  for (var key in watch) {\n\t    var handler = watch[key];\n\t    if (Array.isArray(handler)) {\n\t      for (var i = 0; i < handler.length; i++) {\n\t        createWatcher(vm, key, handler[i]);\n\t      }\n\t    } else {\n\t      createWatcher(vm, key, handler);\n\t    }\n\t  }\n\t}\n\t\n\tfunction createWatcher (vm, key, handler) {\n\t  var options;\n\t  if (isPlainObject(handler)) {\n\t    options = handler;\n\t    handler = handler.handler;\n\t  }\n\t  if (typeof handler === 'string') {\n\t    handler = vm[handler];\n\t  }\n\t  vm.$watch(key, handler, options);\n\t}\n\t\n\tfunction stateMixin (Vue) {\n\t  // flow somehow has problems with directly declared definition object\n\t  // when using Object.defineProperty, so we have to procedurally build up\n\t  // the object here.\n\t  var dataDef = {};\n\t  dataDef.get = function () {\n\t    return this._data\n\t  };\n\t  if (false) {\n\t    dataDef.set = function (newData) {\n\t      warn(\n\t        'Avoid replacing instance root $data. ' +\n\t        'Use nested data properties instead.',\n\t        this\n\t      );\n\t    };\n\t  }\n\t  Object.defineProperty(Vue.prototype, '$data', dataDef);\n\t\n\t  Vue.prototype.$set = set$1;\n\t  Vue.prototype.$delete = del;\n\t\n\t  Vue.prototype.$watch = function (\n\t    expOrFn,\n\t    cb,\n\t    options\n\t  ) {\n\t    var vm = this;\n\t    options = options || {};\n\t    options.user = true;\n\t    var watcher = new Watcher(vm, expOrFn, cb, options);\n\t    if (options.immediate) {\n\t      cb.call(vm, watcher.value);\n\t    }\n\t    return function unwatchFn () {\n\t      watcher.teardown();\n\t    }\n\t  };\n\t}\n\t\n\tfunction proxy (vm, key) {\n\t  if (!isReserved(key)) {\n\t    Object.defineProperty(vm, key, {\n\t      configurable: true,\n\t      enumerable: true,\n\t      get: function proxyGetter () {\n\t        return vm._data[key]\n\t      },\n\t      set: function proxySetter (val) {\n\t        vm._data[key] = val;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar VNode = function VNode (\n\t  tag,\n\t  data,\n\t  children,\n\t  text,\n\t  elm,\n\t  context,\n\t  componentOptions\n\t) {\n\t  this.tag = tag;\n\t  this.data = data;\n\t  this.children = children;\n\t  this.text = text;\n\t  this.elm = elm;\n\t  this.ns = undefined;\n\t  this.context = context;\n\t  this.functionalContext = undefined;\n\t  this.key = data && data.key;\n\t  this.componentOptions = componentOptions;\n\t  this.child = undefined;\n\t  this.parent = undefined;\n\t  this.raw = false;\n\t  this.isStatic = false;\n\t  this.isRootInsert = true;\n\t  this.isComment = false;\n\t  this.isCloned = false;\n\t  this.isOnce = false;\n\t};\n\t\n\tvar createEmptyVNode = function () {\n\t  var node = new VNode();\n\t  node.text = '';\n\t  node.isComment = true;\n\t  return node\n\t};\n\t\n\tfunction createTextVNode (val) {\n\t  return new VNode(undefined, undefined, undefined, String(val))\n\t}\n\t\n\t// optimized shallow clone\n\t// used for static nodes and slot nodes because they may be reused across\n\t// multiple renders, cloning them avoids errors when DOM manipulations rely\n\t// on their elm reference.\n\tfunction cloneVNode (vnode) {\n\t  var cloned = new VNode(\n\t    vnode.tag,\n\t    vnode.data,\n\t    vnode.children,\n\t    vnode.text,\n\t    vnode.elm,\n\t    vnode.context,\n\t    vnode.componentOptions\n\t  );\n\t  cloned.ns = vnode.ns;\n\t  cloned.isStatic = vnode.isStatic;\n\t  cloned.key = vnode.key;\n\t  cloned.isCloned = true;\n\t  return cloned\n\t}\n\t\n\tfunction cloneVNodes (vnodes) {\n\t  var res = new Array(vnodes.length);\n\t  for (var i = 0; i < vnodes.length; i++) {\n\t    res[i] = cloneVNode(vnodes[i]);\n\t  }\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tfunction mergeVNodeHook (def, hookKey, hook, key) {\n\t  key = key + hookKey;\n\t  var injectedHash = def.__injected || (def.__injected = {});\n\t  if (!injectedHash[key]) {\n\t    injectedHash[key] = true;\n\t    var oldHook = def[hookKey];\n\t    if (oldHook) {\n\t      def[hookKey] = function () {\n\t        oldHook.apply(this, arguments);\n\t        hook.apply(this, arguments);\n\t      };\n\t    } else {\n\t      def[hookKey] = hook;\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction updateListeners (\n\t  on,\n\t  oldOn,\n\t  add,\n\t  remove$$1,\n\t  vm\n\t) {\n\t  var name, cur, old, fn, event, capture, once;\n\t  for (name in on) {\n\t    cur = on[name];\n\t    old = oldOn[name];\n\t    if (!cur) {\n\t      (\"production\") !== 'production' && warn(\n\t        \"Invalid handler for event \\\"\" + name + \"\\\": got \" + String(cur),\n\t        vm\n\t      );\n\t    } else if (!old) {\n\t      once = name.charAt(0) === '~'; // Prefixed last, checked first\n\t      event = once ? name.slice(1) : name;\n\t      capture = event.charAt(0) === '!';\n\t      event = capture ? event.slice(1) : event;\n\t      if (Array.isArray(cur)) {\n\t        add(event, (cur.invoker = arrInvoker(cur)), once, capture);\n\t      } else {\n\t        if (!cur.invoker) {\n\t          fn = cur;\n\t          cur = on[name] = {};\n\t          cur.fn = fn;\n\t          cur.invoker = fnInvoker(cur);\n\t        }\n\t        add(event, cur.invoker, once, capture);\n\t      }\n\t    } else if (cur !== old) {\n\t      if (Array.isArray(old)) {\n\t        old.length = cur.length;\n\t        for (var i = 0; i < old.length; i++) { old[i] = cur[i]; }\n\t        on[name] = old;\n\t      } else {\n\t        old.fn = cur;\n\t        on[name] = old;\n\t      }\n\t    }\n\t  }\n\t  for (name in oldOn) {\n\t    if (!on[name]) {\n\t      once = name.charAt(0) === '~'; // Prefixed last, checked first\n\t      event = once ? name.slice(1) : name;\n\t      capture = event.charAt(0) === '!';\n\t      event = capture ? event.slice(1) : event;\n\t      remove$$1(event, oldOn[name].invoker, capture);\n\t    }\n\t  }\n\t}\n\t\n\tfunction arrInvoker (arr) {\n\t  return function (ev) {\n\t    var arguments$1 = arguments;\n\t\n\t    var single = arguments.length === 1;\n\t    for (var i = 0; i < arr.length; i++) {\n\t      single ? arr[i](ev) : arr[i].apply(null, arguments$1);\n\t    }\n\t  }\n\t}\n\t\n\tfunction fnInvoker (o) {\n\t  return function (ev) {\n\t    var single = arguments.length === 1;\n\t    single ? o.fn(ev) : o.fn.apply(null, arguments);\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t// The template compiler attempts to minimize the need for normalization by\n\t// statically analyzing the template at compile time.\n\t//\n\t// For plain HTML markup, normalization can be completely skipped because the\n\t// generated render function is guaranteed to return Array<VNode>. There are\n\t// two cases where extra normalization is needed:\n\t\n\t// 1. When the children contains components - because a functional component\n\t// may return an Array instead of a single root. In this case, just a simple\n\t// nomralization is needed - if any child is an Array, we flatten the whole\n\t// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n\t// because functional components already normalize their own children.\n\tfunction simpleNormalizeChildren (children) {\n\t  for (var i = 0; i < children.length; i++) {\n\t    if (Array.isArray(children[i])) {\n\t      return Array.prototype.concat.apply([], children)\n\t    }\n\t  }\n\t  return children\n\t}\n\t\n\t// 2. When the children contains constrcuts that always generated nested Arrays,\n\t// e.g. <template>, <slot>, v-for, or when the children is provided by user\n\t// with hand-written render functions / JSX. In such cases a full normalization\n\t// is needed to cater to all possible types of children values.\n\tfunction normalizeChildren (children) {\n\t  return isPrimitive(children)\n\t    ? [createTextVNode(children)]\n\t    : Array.isArray(children)\n\t      ? normalizeArrayChildren(children)\n\t      : undefined\n\t}\n\t\n\tfunction normalizeArrayChildren (children, nestedIndex) {\n\t  var res = [];\n\t  var i, c, last;\n\t  for (i = 0; i < children.length; i++) {\n\t    c = children[i];\n\t    if (c == null || typeof c === 'boolean') { continue }\n\t    last = res[res.length - 1];\n\t    //  nested\n\t    if (Array.isArray(c)) {\n\t      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n\t    } else if (isPrimitive(c)) {\n\t      if (last && last.text) {\n\t        last.text += String(c);\n\t      } else if (c !== '') {\n\t        // convert primitive to vnode\n\t        res.push(createTextVNode(c));\n\t      }\n\t    } else {\n\t      if (c.text && last && last.text) {\n\t        res[res.length - 1] = createTextVNode(last.text + c.text);\n\t      } else {\n\t        // default key for nested array children (likely generated by v-for)\n\t        if (c.tag && c.key == null && nestedIndex != null) {\n\t          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n\t        }\n\t        res.push(c);\n\t      }\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tfunction getFirstComponentChild (children) {\n\t  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n\t}\n\t\n\t/*  */\n\t\n\tfunction initEvents (vm) {\n\t  vm._events = Object.create(null);\n\t  vm._hasHookEvent = false;\n\t  // init parent attached events\n\t  var listeners = vm.$options._parentListeners;\n\t  if (listeners) {\n\t    updateComponentListeners(vm, listeners);\n\t  }\n\t}\n\t\n\tvar target;\n\t\n\tfunction add$1 (event, fn, once) {\n\t  if (once) {\n\t    target.$once(event, fn);\n\t  } else {\n\t    target.$on(event, fn);\n\t  }\n\t}\n\t\n\tfunction remove$2 (event, fn) {\n\t  target.$off(event, fn);\n\t}\n\t\n\tfunction updateComponentListeners (\n\t  vm,\n\t  listeners,\n\t  oldListeners\n\t) {\n\t  target = vm;\n\t  updateListeners(listeners, oldListeners || {}, add$1, remove$2, vm);\n\t}\n\t\n\tfunction eventsMixin (Vue) {\n\t  var hookRE = /^hook:/;\n\t  Vue.prototype.$on = function (event, fn) {\n\t    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);\n\t    // optimize hook:event cost by using a boolean flag marked at registration\n\t    // instead of a hash lookup\n\t    if (hookRE.test(event)) {\n\t      vm._hasHookEvent = true;\n\t    }\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype.$once = function (event, fn) {\n\t    var vm = this;\n\t    function on () {\n\t      vm.$off(event, on);\n\t      fn.apply(vm, arguments);\n\t    }\n\t    on.fn = fn;\n\t    vm.$on(event, on);\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype.$off = function (event, fn) {\n\t    var vm = this;\n\t    // all\n\t    if (!arguments.length) {\n\t      vm._events = Object.create(null);\n\t      return vm\n\t    }\n\t    // specific event\n\t    var cbs = vm._events[event];\n\t    if (!cbs) {\n\t      return vm\n\t    }\n\t    if (arguments.length === 1) {\n\t      vm._events[event] = null;\n\t      return vm\n\t    }\n\t    // specific handler\n\t    var cb;\n\t    var i = cbs.length;\n\t    while (i--) {\n\t      cb = cbs[i];\n\t      if (cb === fn || cb.fn === fn) {\n\t        cbs.splice(i, 1);\n\t        break\n\t      }\n\t    }\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype.$emit = function (event) {\n\t    var vm = this;\n\t    var cbs = vm._events[event];\n\t    if (cbs) {\n\t      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n\t      var args = toArray(arguments, 1);\n\t      for (var i = 0, l = cbs.length; i < l; i++) {\n\t        cbs[i].apply(vm, args);\n\t      }\n\t    }\n\t    return vm\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tvar activeInstance = null;\n\t\n\tfunction initLifecycle (vm) {\n\t  var options = vm.$options;\n\t\n\t  // locate first non-abstract parent\n\t  var parent = options.parent;\n\t  if (parent && !options.abstract) {\n\t    while (parent.$options.abstract && parent.$parent) {\n\t      parent = parent.$parent;\n\t    }\n\t    parent.$children.push(vm);\n\t  }\n\t\n\t  vm.$parent = parent;\n\t  vm.$root = parent ? parent.$root : vm;\n\t\n\t  vm.$children = [];\n\t  vm.$refs = {};\n\t\n\t  vm._watcher = null;\n\t  vm._inactive = false;\n\t  vm._isMounted = false;\n\t  vm._isDestroyed = false;\n\t  vm._isBeingDestroyed = false;\n\t}\n\t\n\tfunction lifecycleMixin (Vue) {\n\t  Vue.prototype._mount = function (\n\t    el,\n\t    hydrating\n\t  ) {\n\t    var vm = this;\n\t    vm.$el = el;\n\t    if (!vm.$options.render) {\n\t      vm.$options.render = createEmptyVNode;\n\t      if (false) {\n\t        /* istanbul ignore if */\n\t        if (vm.$options.template && vm.$options.template.charAt(0) !== '#') {\n\t          warn(\n\t            'You are using the runtime-only build of Vue where the template ' +\n\t            'option is not available. Either pre-compile the templates into ' +\n\t            'render functions, or use the compiler-included build.',\n\t            vm\n\t          );\n\t        } else {\n\t          warn(\n\t            'Failed to mount component: template or render function not defined.',\n\t            vm\n\t          );\n\t        }\n\t      }\n\t    }\n\t    callHook(vm, 'beforeMount');\n\t    vm._watcher = new Watcher(vm, function () {\n\t      vm._update(vm._render(), hydrating);\n\t    }, noop);\n\t    hydrating = false;\n\t    // manually mounted instance, call mounted on self\n\t    // mounted is called for render-created child components in its inserted hook\n\t    if (vm.$vnode == null) {\n\t      vm._isMounted = true;\n\t      callHook(vm, 'mounted');\n\t    }\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype._update = function (vnode, hydrating) {\n\t    var vm = this;\n\t    if (vm._isMounted) {\n\t      callHook(vm, 'beforeUpdate');\n\t    }\n\t    var prevEl = vm.$el;\n\t    var prevVnode = vm._vnode;\n\t    var prevActiveInstance = activeInstance;\n\t    activeInstance = vm;\n\t    vm._vnode = vnode;\n\t    // Vue.prototype.__patch__ is injected in entry points\n\t    // based on the rendering backend used.\n\t    if (!prevVnode) {\n\t      // initial render\n\t      vm.$el = vm.__patch__(\n\t        vm.$el, vnode, hydrating, false /* removeOnly */,\n\t        vm.$options._parentElm,\n\t        vm.$options._refElm\n\t      );\n\t    } else {\n\t      // updates\n\t      vm.$el = vm.__patch__(prevVnode, vnode);\n\t    }\n\t    activeInstance = prevActiveInstance;\n\t    // update __vue__ reference\n\t    if (prevEl) {\n\t      prevEl.__vue__ = null;\n\t    }\n\t    if (vm.$el) {\n\t      vm.$el.__vue__ = vm;\n\t    }\n\t    // if parent is an HOC, update its $el as well\n\t    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n\t      vm.$parent.$el = vm.$el;\n\t    }\n\t    if (vm._isMounted) {\n\t      callHook(vm, 'updated');\n\t    }\n\t  };\n\t\n\t  Vue.prototype._updateFromParent = function (\n\t    propsData,\n\t    listeners,\n\t    parentVnode,\n\t    renderChildren\n\t  ) {\n\t    var vm = this;\n\t    var hasChildren = !!(vm.$options._renderChildren || renderChildren);\n\t    vm.$options._parentVnode = parentVnode;\n\t    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\t    if (vm._vnode) { // update child tree's parent\n\t      vm._vnode.parent = parentVnode;\n\t    }\n\t    vm.$options._renderChildren = renderChildren;\n\t    // update props\n\t    if (propsData && vm.$options.props) {\n\t      observerState.shouldConvert = false;\n\t      if (false) {\n\t        observerState.isSettingProps = true;\n\t      }\n\t      var propKeys = vm.$options._propKeys || [];\n\t      for (var i = 0; i < propKeys.length; i++) {\n\t        var key = propKeys[i];\n\t        vm[key] = validateProp(key, vm.$options.props, propsData, vm);\n\t      }\n\t      observerState.shouldConvert = true;\n\t      if (false) {\n\t        observerState.isSettingProps = false;\n\t      }\n\t      vm.$options.propsData = propsData;\n\t    }\n\t    // update listeners\n\t    if (listeners) {\n\t      var oldListeners = vm.$options._parentListeners;\n\t      vm.$options._parentListeners = listeners;\n\t      updateComponentListeners(vm, listeners, oldListeners);\n\t    }\n\t    // resolve slots + force update if has children\n\t    if (hasChildren) {\n\t      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n\t      vm.$forceUpdate();\n\t    }\n\t  };\n\t\n\t  Vue.prototype.$forceUpdate = function () {\n\t    var vm = this;\n\t    if (vm._watcher) {\n\t      vm._watcher.update();\n\t    }\n\t  };\n\t\n\t  Vue.prototype.$destroy = function () {\n\t    var vm = this;\n\t    if (vm._isBeingDestroyed) {\n\t      return\n\t    }\n\t    callHook(vm, 'beforeDestroy');\n\t    vm._isBeingDestroyed = true;\n\t    // remove self from parent\n\t    var parent = vm.$parent;\n\t    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n\t      remove$1(parent.$children, vm);\n\t    }\n\t    // teardown watchers\n\t    if (vm._watcher) {\n\t      vm._watcher.teardown();\n\t    }\n\t    var i = vm._watchers.length;\n\t    while (i--) {\n\t      vm._watchers[i].teardown();\n\t    }\n\t    // remove reference from data ob\n\t    // frozen object may not have observer.\n\t    if (vm._data.__ob__) {\n\t      vm._data.__ob__.vmCount--;\n\t    }\n\t    // call the last hook...\n\t    vm._isDestroyed = true;\n\t    callHook(vm, 'destroyed');\n\t    // turn off all instance listeners.\n\t    vm.$off();\n\t    // remove __vue__ reference\n\t    if (vm.$el) {\n\t      vm.$el.__vue__ = null;\n\t    }\n\t    // invoke destroy hooks on current rendered tree\n\t    vm.__patch__(vm._vnode, null);\n\t  };\n\t}\n\t\n\tfunction callHook (vm, hook) {\n\t  var handlers = vm.$options[hook];\n\t  if (handlers) {\n\t    for (var i = 0, j = handlers.length; i < j; i++) {\n\t      handlers[i].call(vm);\n\t    }\n\t  }\n\t  if (vm._hasHookEvent) {\n\t    vm.$emit('hook:' + hook);\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };\n\tvar hooksToMerge = Object.keys(hooks);\n\t\n\tfunction createComponent (\n\t  Ctor,\n\t  data,\n\t  context,\n\t  children,\n\t  tag\n\t) {\n\t  if (!Ctor) {\n\t    return\n\t  }\n\t\n\t  var baseCtor = context.$options._base;\n\t  if (isObject(Ctor)) {\n\t    Ctor = baseCtor.extend(Ctor);\n\t  }\n\t\n\t  if (typeof Ctor !== 'function') {\n\t    if (false) {\n\t      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n\t    }\n\t    return\n\t  }\n\t\n\t  // async component\n\t  if (!Ctor.cid) {\n\t    if (Ctor.resolved) {\n\t      Ctor = Ctor.resolved;\n\t    } else {\n\t      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n\t        // it's ok to queue this on every render because\n\t        // $forceUpdate is buffered by the scheduler.\n\t        context.$forceUpdate();\n\t      });\n\t      if (!Ctor) {\n\t        // return nothing if this is indeed an async component\n\t        // wait for the callback to trigger parent update.\n\t        return\n\t      }\n\t    }\n\t  }\n\t\n\t  // resolve constructor options in case global mixins are applied after\n\t  // component constructor creation\n\t  resolveConstructorOptions(Ctor);\n\t\n\t  data = data || {};\n\t\n\t  // extract props\n\t  var propsData = extractProps(data, Ctor);\n\t\n\t  // functional component\n\t  if (Ctor.options.functional) {\n\t    return createFunctionalComponent(Ctor, propsData, data, context, children)\n\t  }\n\t\n\t  // extract listeners, since these needs to be treated as\n\t  // child component listeners instead of DOM listeners\n\t  var listeners = data.on;\n\t  // replace with listeners with .native modifier\n\t  data.on = data.nativeOn;\n\t\n\t  if (Ctor.options.abstract) {\n\t    // abstract components do not keep anything\n\t    // other than props & listeners\n\t    data = {};\n\t  }\n\t\n\t  // merge component management hooks onto the placeholder node\n\t  mergeHooks(data);\n\t\n\t  // return a placeholder vnode\n\t  var name = Ctor.options.name || tag;\n\t  var vnode = new VNode(\n\t    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n\t    data, undefined, undefined, undefined, context,\n\t    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n\t  );\n\t  return vnode\n\t}\n\t\n\tfunction createFunctionalComponent (\n\t  Ctor,\n\t  propsData,\n\t  data,\n\t  context,\n\t  children\n\t) {\n\t  var props = {};\n\t  var propOptions = Ctor.options.props;\n\t  if (propOptions) {\n\t    for (var key in propOptions) {\n\t      props[key] = validateProp(key, propOptions, propsData);\n\t    }\n\t  }\n\t  // ensure the createElement function in functional components\n\t  // gets a unique context - this is necessary for correct named slot check\n\t  var _context = Object.create(context);\n\t  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n\t  var vnode = Ctor.options.render.call(null, h, {\n\t    props: props,\n\t    data: data,\n\t    parent: context,\n\t    children: children,\n\t    slots: function () { return resolveSlots(children, context); }\n\t  });\n\t  if (vnode instanceof VNode) {\n\t    vnode.functionalContext = context;\n\t    if (data.slot) {\n\t      (vnode.data || (vnode.data = {})).slot = data.slot;\n\t    }\n\t  }\n\t  return vnode\n\t}\n\t\n\tfunction createComponentInstanceForVnode (\n\t  vnode, // we know it's MountedComponentVNode but flow doesn't\n\t  parent, // activeInstance in lifecycle state\n\t  parentElm,\n\t  refElm\n\t) {\n\t  var vnodeComponentOptions = vnode.componentOptions;\n\t  var options = {\n\t    _isComponent: true,\n\t    parent: parent,\n\t    propsData: vnodeComponentOptions.propsData,\n\t    _componentTag: vnodeComponentOptions.tag,\n\t    _parentVnode: vnode,\n\t    _parentListeners: vnodeComponentOptions.listeners,\n\t    _renderChildren: vnodeComponentOptions.children,\n\t    _parentElm: parentElm || null,\n\t    _refElm: refElm || null\n\t  };\n\t  // check inline-template render functions\n\t  var inlineTemplate = vnode.data.inlineTemplate;\n\t  if (inlineTemplate) {\n\t    options.render = inlineTemplate.render;\n\t    options.staticRenderFns = inlineTemplate.staticRenderFns;\n\t  }\n\t  return new vnodeComponentOptions.Ctor(options)\n\t}\n\t\n\tfunction init (\n\t  vnode,\n\t  hydrating,\n\t  parentElm,\n\t  refElm\n\t) {\n\t  if (!vnode.child || vnode.child._isDestroyed) {\n\t    var child = vnode.child = createComponentInstanceForVnode(\n\t      vnode,\n\t      activeInstance,\n\t      parentElm,\n\t      refElm\n\t    );\n\t    child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n\t  } else if (vnode.data.keepAlive) {\n\t    // kept-alive components, treat as a patch\n\t    var mountedNode = vnode; // work around flow\n\t    prepatch(mountedNode, mountedNode);\n\t  }\n\t}\n\t\n\tfunction prepatch (\n\t  oldVnode,\n\t  vnode\n\t) {\n\t  var options = vnode.componentOptions;\n\t  var child = vnode.child = oldVnode.child;\n\t  child._updateFromParent(\n\t    options.propsData, // updated props\n\t    options.listeners, // updated listeners\n\t    vnode, // new parent vnode\n\t    options.children // new children\n\t  );\n\t}\n\t\n\tfunction insert (vnode) {\n\t  if (!vnode.child._isMounted) {\n\t    vnode.child._isMounted = true;\n\t    callHook(vnode.child, 'mounted');\n\t  }\n\t  if (vnode.data.keepAlive) {\n\t    vnode.child._inactive = false;\n\t    callHook(vnode.child, 'activated');\n\t  }\n\t}\n\t\n\tfunction destroy$1 (vnode) {\n\t  if (!vnode.child._isDestroyed) {\n\t    if (!vnode.data.keepAlive) {\n\t      vnode.child.$destroy();\n\t    } else {\n\t      vnode.child._inactive = true;\n\t      callHook(vnode.child, 'deactivated');\n\t    }\n\t  }\n\t}\n\t\n\tfunction resolveAsyncComponent (\n\t  factory,\n\t  baseCtor,\n\t  cb\n\t) {\n\t  if (factory.requested) {\n\t    // pool callbacks\n\t    factory.pendingCallbacks.push(cb);\n\t  } else {\n\t    factory.requested = true;\n\t    var cbs = factory.pendingCallbacks = [cb];\n\t    var sync = true;\n\t\n\t    var resolve = function (res) {\n\t      if (isObject(res)) {\n\t        res = baseCtor.extend(res);\n\t      }\n\t      // cache resolved\n\t      factory.resolved = res;\n\t      // invoke callbacks only if this is not a synchronous resolve\n\t      // (async resolves are shimmed as synchronous during SSR)\n\t      if (!sync) {\n\t        for (var i = 0, l = cbs.length; i < l; i++) {\n\t          cbs[i](res);\n\t        }\n\t      }\n\t    };\n\t\n\t    var reject = function (reason) {\n\t      (\"production\") !== 'production' && warn(\n\t        \"Failed to resolve async component: \" + (String(factory)) +\n\t        (reason ? (\"\\nReason: \" + reason) : '')\n\t      );\n\t    };\n\t\n\t    var res = factory(resolve, reject);\n\t\n\t    // handle promise\n\t    if (res && typeof res.then === 'function' && !factory.resolved) {\n\t      res.then(resolve, reject);\n\t    }\n\t\n\t    sync = false;\n\t    // return in case resolved synchronously\n\t    return factory.resolved\n\t  }\n\t}\n\t\n\tfunction extractProps (data, Ctor) {\n\t  // we are only extracting raw values here.\n\t  // validation and default values are handled in the child\n\t  // component itself.\n\t  var propOptions = Ctor.options.props;\n\t  if (!propOptions) {\n\t    return\n\t  }\n\t  var res = {};\n\t  var attrs = data.attrs;\n\t  var props = data.props;\n\t  var domProps = data.domProps;\n\t  if (attrs || props || domProps) {\n\t    for (var key in propOptions) {\n\t      var altKey = hyphenate(key);\n\t      checkProp(res, props, key, altKey, true) ||\n\t      checkProp(res, attrs, key, altKey) ||\n\t      checkProp(res, domProps, key, altKey);\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\tfunction checkProp (\n\t  res,\n\t  hash,\n\t  key,\n\t  altKey,\n\t  preserve\n\t) {\n\t  if (hash) {\n\t    if (hasOwn(hash, key)) {\n\t      res[key] = hash[key];\n\t      if (!preserve) {\n\t        delete hash[key];\n\t      }\n\t      return true\n\t    } else if (hasOwn(hash, altKey)) {\n\t      res[key] = hash[altKey];\n\t      if (!preserve) {\n\t        delete hash[altKey];\n\t      }\n\t      return true\n\t    }\n\t  }\n\t  return false\n\t}\n\t\n\tfunction mergeHooks (data) {\n\t  if (!data.hook) {\n\t    data.hook = {};\n\t  }\n\t  for (var i = 0; i < hooksToMerge.length; i++) {\n\t    var key = hooksToMerge[i];\n\t    var fromParent = data.hook[key];\n\t    var ours = hooks[key];\n\t    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n\t  }\n\t}\n\t\n\tfunction mergeHook$1 (one, two) {\n\t  return function (a, b, c, d) {\n\t    one(a, b, c, d);\n\t    two(a, b, c, d);\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar SIMPLE_NORMALIZE = 1;\n\tvar ALWAYS_NORMALIZE = 2;\n\t\n\t// wrapper function for providing a more flexible interface\n\t// without getting yelled at by flow\n\tfunction createElement (\n\t  context,\n\t  tag,\n\t  data,\n\t  children,\n\t  normalizationType,\n\t  alwaysNormalize\n\t) {\n\t  if (Array.isArray(data) || isPrimitive(data)) {\n\t    normalizationType = children;\n\t    children = data;\n\t    data = undefined;\n\t  }\n\t  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\n\t  return _createElement(context, tag, data, children, normalizationType)\n\t}\n\t\n\tfunction _createElement (\n\t  context,\n\t  tag,\n\t  data,\n\t  children,\n\t  normalizationType\n\t) {\n\t  if (data && data.__ob__) {\n\t    (\"production\") !== 'production' && warn(\n\t      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n\t      'Always create fresh vnode data objects in each render!',\n\t      context\n\t    );\n\t    return createEmptyVNode()\n\t  }\n\t  if (!tag) {\n\t    // in case of component :is set to falsy value\n\t    return createEmptyVNode()\n\t  }\n\t  // support single function children as default scoped slot\n\t  if (Array.isArray(children) &&\n\t      typeof children[0] === 'function') {\n\t    data = data || {};\n\t    data.scopedSlots = { default: children[0] };\n\t    children.length = 0;\n\t  }\n\t  if (normalizationType === ALWAYS_NORMALIZE) {\n\t    children = normalizeChildren(children);\n\t  } else if (normalizationType === SIMPLE_NORMALIZE) {\n\t    children = simpleNormalizeChildren(children);\n\t  }\n\t  var vnode, ns;\n\t  if (typeof tag === 'string') {\n\t    var Ctor;\n\t    ns = config.getTagNamespace(tag);\n\t    if (config.isReservedTag(tag)) {\n\t      // platform built-in elements\n\t      vnode = new VNode(\n\t        config.parsePlatformTagName(tag), data, children,\n\t        undefined, undefined, context\n\t      );\n\t    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n\t      // component\n\t      vnode = createComponent(Ctor, data, context, children, tag);\n\t    } else {\n\t      // unknown or unlisted namespaced elements\n\t      // check at runtime because it may get assigned a namespace when its\n\t      // parent normalizes children\n\t      vnode = new VNode(\n\t        tag, data, children,\n\t        undefined, undefined, context\n\t      );\n\t    }\n\t  } else {\n\t    // direct component options / constructor\n\t    vnode = createComponent(tag, data, context, children);\n\t  }\n\t  if (vnode) {\n\t    if (ns) { applyNS(vnode, ns); }\n\t    return vnode\n\t  } else {\n\t    return createEmptyVNode()\n\t  }\n\t}\n\t\n\tfunction applyNS (vnode, ns) {\n\t  vnode.ns = ns;\n\t  if (vnode.tag === 'foreignObject') {\n\t    // use default namespace inside foreignObject\n\t    return\n\t  }\n\t  if (vnode.children) {\n\t    for (var i = 0, l = vnode.children.length; i < l; i++) {\n\t      var child = vnode.children[i];\n\t      if (child.tag && !child.ns) {\n\t        applyNS(child, ns);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction initRender (vm) {\n\t  vm.$vnode = null; // the placeholder node in parent tree\n\t  vm._vnode = null; // the root of the child tree\n\t  vm._staticTrees = null;\n\t  var parentVnode = vm.$options._parentVnode;\n\t  var renderContext = parentVnode && parentVnode.context;\n\t  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n\t  vm.$scopedSlots = {};\n\t  // bind the createElement fn to this instance\n\t  // so that we get proper render context inside it.\n\t  // args order: tag, data, children, normalizationType, alwaysNormalize\n\t  // internal version is used by render functions compiled from templates\n\t  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n\t  // normalization is always applied for the public version, used in\n\t  // user-written render functions.\n\t  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\t  if (vm.$options.el) {\n\t    vm.$mount(vm.$options.el);\n\t  }\n\t}\n\t\n\tfunction renderMixin (Vue) {\n\t  Vue.prototype.$nextTick = function (fn) {\n\t    return nextTick(fn, this)\n\t  };\n\t\n\t  Vue.prototype._render = function () {\n\t    var vm = this;\n\t    var ref = vm.$options;\n\t    var render = ref.render;\n\t    var staticRenderFns = ref.staticRenderFns;\n\t    var _parentVnode = ref._parentVnode;\n\t\n\t    if (vm._isMounted) {\n\t      // clone slot nodes on re-renders\n\t      for (var key in vm.$slots) {\n\t        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n\t      }\n\t    }\n\t\n\t    if (_parentVnode && _parentVnode.data.scopedSlots) {\n\t      vm.$scopedSlots = _parentVnode.data.scopedSlots;\n\t    }\n\t\n\t    if (staticRenderFns && !vm._staticTrees) {\n\t      vm._staticTrees = [];\n\t    }\n\t    // set parent vnode. this allows render functions to have access\n\t    // to the data on the placeholder node.\n\t    vm.$vnode = _parentVnode;\n\t    // render self\n\t    var vnode;\n\t    try {\n\t      vnode = render.call(vm._renderProxy, vm.$createElement);\n\t    } catch (e) {\n\t      /* istanbul ignore else */\n\t      if (config.errorHandler) {\n\t        config.errorHandler.call(null, e, vm);\n\t      } else {\n\t        if (false) {\n\t          warn((\"Error when rendering \" + (formatComponentName(vm)) + \":\"));\n\t        }\n\t        throw e\n\t      }\n\t      // return previous vnode to prevent render error causing blank component\n\t      vnode = vm._vnode;\n\t    }\n\t    // return empty vnode in case the render function errored out\n\t    if (!(vnode instanceof VNode)) {\n\t      if (false) {\n\t        warn(\n\t          'Multiple root nodes returned from render function. Render function ' +\n\t          'should return a single root node.',\n\t          vm\n\t        );\n\t      }\n\t      vnode = createEmptyVNode();\n\t    }\n\t    // set parent\n\t    vnode.parent = _parentVnode;\n\t    return vnode\n\t  };\n\t\n\t  // toString for mustaches\n\t  Vue.prototype._s = _toString;\n\t  // convert text to vnode\n\t  Vue.prototype._v = createTextVNode;\n\t  // number conversion\n\t  Vue.prototype._n = toNumber;\n\t  // empty vnode\n\t  Vue.prototype._e = createEmptyVNode;\n\t  // loose equal\n\t  Vue.prototype._q = looseEqual;\n\t  // loose indexOf\n\t  Vue.prototype._i = looseIndexOf;\n\t\n\t  // render static tree by index\n\t  Vue.prototype._m = function renderStatic (\n\t    index,\n\t    isInFor\n\t  ) {\n\t    var tree = this._staticTrees[index];\n\t    // if has already-rendered static tree and not inside v-for,\n\t    // we can reuse the same tree by doing a shallow clone.\n\t    if (tree && !isInFor) {\n\t      return Array.isArray(tree)\n\t        ? cloneVNodes(tree)\n\t        : cloneVNode(tree)\n\t    }\n\t    // otherwise, render a fresh tree.\n\t    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n\t    markStatic(tree, (\"__static__\" + index), false);\n\t    return tree\n\t  };\n\t\n\t  // mark node as static (v-once)\n\t  Vue.prototype._o = function markOnce (\n\t    tree,\n\t    index,\n\t    key\n\t  ) {\n\t    markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n\t    return tree\n\t  };\n\t\n\t  function markStatic (tree, key, isOnce) {\n\t    if (Array.isArray(tree)) {\n\t      for (var i = 0; i < tree.length; i++) {\n\t        if (tree[i] && typeof tree[i] !== 'string') {\n\t          markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n\t        }\n\t      }\n\t    } else {\n\t      markStaticNode(tree, key, isOnce);\n\t    }\n\t  }\n\t\n\t  function markStaticNode (node, key, isOnce) {\n\t    node.isStatic = true;\n\t    node.key = key;\n\t    node.isOnce = isOnce;\n\t  }\n\t\n\t  // filter resolution helper\n\t  Vue.prototype._f = function resolveFilter (id) {\n\t    return resolveAsset(this.$options, 'filters', id, true) || identity\n\t  };\n\t\n\t  // render v-for\n\t  Vue.prototype._l = function renderList (\n\t    val,\n\t    render\n\t  ) {\n\t    var ret, i, l, keys, key;\n\t    if (Array.isArray(val) || typeof val === 'string') {\n\t      ret = new Array(val.length);\n\t      for (i = 0, l = val.length; i < l; i++) {\n\t        ret[i] = render(val[i], i);\n\t      }\n\t    } else if (typeof val === 'number') {\n\t      ret = new Array(val);\n\t      for (i = 0; i < val; i++) {\n\t        ret[i] = render(i + 1, i);\n\t      }\n\t    } else if (isObject(val)) {\n\t      keys = Object.keys(val);\n\t      ret = new Array(keys.length);\n\t      for (i = 0, l = keys.length; i < l; i++) {\n\t        key = keys[i];\n\t        ret[i] = render(val[key], key, i);\n\t      }\n\t    }\n\t    return ret\n\t  };\n\t\n\t  // renderSlot\n\t  Vue.prototype._t = function (\n\t    name,\n\t    fallback,\n\t    props,\n\t    bindObject\n\t  ) {\n\t    var scopedSlotFn = this.$scopedSlots[name];\n\t    if (scopedSlotFn) { // scoped slot\n\t      props = props || {};\n\t      if (bindObject) {\n\t        extend(props, bindObject);\n\t      }\n\t      return scopedSlotFn(props) || fallback\n\t    } else {\n\t      var slotNodes = this.$slots[name];\n\t      // warn duplicate slot usage\n\t      if (slotNodes && (\"production\") !== 'production') {\n\t        slotNodes._rendered && warn(\n\t          \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n\t          \"- this will likely cause render errors.\",\n\t          this\n\t        );\n\t        slotNodes._rendered = true;\n\t      }\n\t      return slotNodes || fallback\n\t    }\n\t  };\n\t\n\t  // apply v-bind object\n\t  Vue.prototype._b = function bindProps (\n\t    data,\n\t    tag,\n\t    value,\n\t    asProp\n\t  ) {\n\t    if (value) {\n\t      if (!isObject(value)) {\n\t        (\"production\") !== 'production' && warn(\n\t          'v-bind without argument expects an Object or Array value',\n\t          this\n\t        );\n\t      } else {\n\t        if (Array.isArray(value)) {\n\t          value = toObject(value);\n\t        }\n\t        for (var key in value) {\n\t          if (key === 'class' || key === 'style') {\n\t            data[key] = value[key];\n\t          } else {\n\t            var hash = asProp || config.mustUseProp(tag, key)\n\t              ? data.domProps || (data.domProps = {})\n\t              : data.attrs || (data.attrs = {});\n\t            hash[key] = value[key];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return data\n\t  };\n\t\n\t  // check v-on keyCodes\n\t  Vue.prototype._k = function checkKeyCodes (\n\t    eventKeyCode,\n\t    key,\n\t    builtInAlias\n\t  ) {\n\t    var keyCodes = config.keyCodes[key] || builtInAlias;\n\t    if (Array.isArray(keyCodes)) {\n\t      return keyCodes.indexOf(eventKeyCode) === -1\n\t    } else {\n\t      return keyCodes !== eventKeyCode\n\t    }\n\t  };\n\t}\n\t\n\tfunction resolveSlots (\n\t  children,\n\t  context\n\t) {\n\t  var slots = {};\n\t  if (!children) {\n\t    return slots\n\t  }\n\t  var defaultSlot = [];\n\t  var name, child;\n\t  for (var i = 0, l = children.length; i < l; i++) {\n\t    child = children[i];\n\t    // named slots should only be respected if the vnode was rendered in the\n\t    // same context.\n\t    if ((child.context === context || child.functionalContext === context) &&\n\t        child.data && (name = child.data.slot)) {\n\t      var slot = (slots[name] || (slots[name] = []));\n\t      if (child.tag === 'template') {\n\t        slot.push.apply(slot, child.children);\n\t      } else {\n\t        slot.push(child);\n\t      }\n\t    } else {\n\t      defaultSlot.push(child);\n\t    }\n\t  }\n\t  // ignore single whitespace\n\t  if (defaultSlot.length && !(\n\t    defaultSlot.length === 1 &&\n\t    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)\n\t  )) {\n\t    slots.default = defaultSlot;\n\t  }\n\t  return slots\n\t}\n\t\n\t/*  */\n\t\n\tvar uid = 0;\n\t\n\tfunction initMixin (Vue) {\n\t  Vue.prototype._init = function (options) {\n\t    var vm = this;\n\t    // a uid\n\t    vm._uid = uid++;\n\t    // a flag to avoid this being observed\n\t    vm._isVue = true;\n\t    // merge options\n\t    if (options && options._isComponent) {\n\t      // optimize internal component instantiation\n\t      // since dynamic options merging is pretty slow, and none of the\n\t      // internal component options needs special treatment.\n\t      initInternalComponent(vm, options);\n\t    } else {\n\t      vm.$options = mergeOptions(\n\t        resolveConstructorOptions(vm.constructor),\n\t        options || {},\n\t        vm\n\t      );\n\t    }\n\t    /* istanbul ignore else */\n\t    if (false) {\n\t      initProxy(vm);\n\t    } else {\n\t      vm._renderProxy = vm;\n\t    }\n\t    // expose real self\n\t    vm._self = vm;\n\t    initLifecycle(vm);\n\t    initEvents(vm);\n\t    callHook(vm, 'beforeCreate');\n\t    initState(vm);\n\t    callHook(vm, 'created');\n\t    initRender(vm);\n\t  };\n\t}\n\t\n\tfunction initInternalComponent (vm, options) {\n\t  var opts = vm.$options = Object.create(vm.constructor.options);\n\t  // doing this because it's faster than dynamic enumeration.\n\t  opts.parent = options.parent;\n\t  opts.propsData = options.propsData;\n\t  opts._parentVnode = options._parentVnode;\n\t  opts._parentListeners = options._parentListeners;\n\t  opts._renderChildren = options._renderChildren;\n\t  opts._componentTag = options._componentTag;\n\t  opts._parentElm = options._parentElm;\n\t  opts._refElm = options._refElm;\n\t  if (options.render) {\n\t    opts.render = options.render;\n\t    opts.staticRenderFns = options.staticRenderFns;\n\t  }\n\t}\n\t\n\tfunction resolveConstructorOptions (Ctor) {\n\t  var options = Ctor.options;\n\t  if (Ctor.super) {\n\t    var superOptions = Ctor.super.options;\n\t    var cachedSuperOptions = Ctor.superOptions;\n\t    var extendOptions = Ctor.extendOptions;\n\t    if (superOptions !== cachedSuperOptions) {\n\t      // super option changed\n\t      Ctor.superOptions = superOptions;\n\t      extendOptions.render = options.render;\n\t      extendOptions.staticRenderFns = options.staticRenderFns;\n\t      extendOptions._scopeId = options._scopeId;\n\t      options = Ctor.options = mergeOptions(superOptions, extendOptions);\n\t      if (options.name) {\n\t        options.components[options.name] = Ctor;\n\t      }\n\t    }\n\t  }\n\t  return options\n\t}\n\t\n\tfunction Vue$2 (options) {\n\t  if (false) {\n\t    warn('Vue is a constructor and should be called with the `new` keyword');\n\t  }\n\t  this._init(options);\n\t}\n\t\n\tinitMixin(Vue$2);\n\tstateMixin(Vue$2);\n\teventsMixin(Vue$2);\n\tlifecycleMixin(Vue$2);\n\trenderMixin(Vue$2);\n\t\n\t/*  */\n\t\n\tfunction initUse (Vue) {\n\t  Vue.use = function (plugin) {\n\t    /* istanbul ignore if */\n\t    if (plugin.installed) {\n\t      return\n\t    }\n\t    // additional parameters\n\t    var args = toArray(arguments, 1);\n\t    args.unshift(this);\n\t    if (typeof plugin.install === 'function') {\n\t      plugin.install.apply(plugin, args);\n\t    } else {\n\t      plugin.apply(null, args);\n\t    }\n\t    plugin.installed = true;\n\t    return this\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tfunction initMixin$1 (Vue) {\n\t  Vue.mixin = function (mixin) {\n\t    this.options = mergeOptions(this.options, mixin);\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tfunction initExtend (Vue) {\n\t  /**\n\t   * Each instance constructor, including Vue, has a unique\n\t   * cid. This enables us to create wrapped \"child\n\t   * constructors\" for prototypal inheritance and cache them.\n\t   */\n\t  Vue.cid = 0;\n\t  var cid = 1;\n\t\n\t  /**\n\t   * Class inheritance\n\t   */\n\t  Vue.extend = function (extendOptions) {\n\t    extendOptions = extendOptions || {};\n\t    var Super = this;\n\t    var SuperId = Super.cid;\n\t    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\t    if (cachedCtors[SuperId]) {\n\t      return cachedCtors[SuperId]\n\t    }\n\t    var name = extendOptions.name || Super.options.name;\n\t    if (false) {\n\t      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n\t        warn(\n\t          'Invalid component name: \"' + name + '\". Component names ' +\n\t          'can only contain alphanumeric characters and the hyphen, ' +\n\t          'and must start with a letter.'\n\t        );\n\t      }\n\t    }\n\t    var Sub = function VueComponent (options) {\n\t      this._init(options);\n\t    };\n\t    Sub.prototype = Object.create(Super.prototype);\n\t    Sub.prototype.constructor = Sub;\n\t    Sub.cid = cid++;\n\t    Sub.options = mergeOptions(\n\t      Super.options,\n\t      extendOptions\n\t    );\n\t    Sub['super'] = Super;\n\t    // allow further extension/mixin/plugin usage\n\t    Sub.extend = Super.extend;\n\t    Sub.mixin = Super.mixin;\n\t    Sub.use = Super.use;\n\t    // create asset registers, so extended classes\n\t    // can have their private assets too.\n\t    config._assetTypes.forEach(function (type) {\n\t      Sub[type] = Super[type];\n\t    });\n\t    // enable recursive self-lookup\n\t    if (name) {\n\t      Sub.options.components[name] = Sub;\n\t    }\n\t    // keep a reference to the super options at extension time.\n\t    // later at instantiation we can check if Super's options have\n\t    // been updated.\n\t    Sub.superOptions = Super.options;\n\t    Sub.extendOptions = extendOptions;\n\t    // cache constructor\n\t    cachedCtors[SuperId] = Sub;\n\t    return Sub\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tfunction initAssetRegisters (Vue) {\n\t  /**\n\t   * Create asset registration methods.\n\t   */\n\t  config._assetTypes.forEach(function (type) {\n\t    Vue[type] = function (\n\t      id,\n\t      definition\n\t    ) {\n\t      if (!definition) {\n\t        return this.options[type + 's'][id]\n\t      } else {\n\t        /* istanbul ignore if */\n\t        if (false) {\n\t          if (type === 'component' && config.isReservedTag(id)) {\n\t            warn(\n\t              'Do not use built-in or reserved HTML elements as component ' +\n\t              'id: ' + id\n\t            );\n\t          }\n\t        }\n\t        if (type === 'component' && isPlainObject(definition)) {\n\t          definition.name = definition.name || id;\n\t          definition = this.options._base.extend(definition);\n\t        }\n\t        if (type === 'directive' && typeof definition === 'function') {\n\t          definition = { bind: definition, update: definition };\n\t        }\n\t        this.options[type + 's'][id] = definition;\n\t        return definition\n\t      }\n\t    };\n\t  });\n\t}\n\t\n\t/*  */\n\t\n\tvar patternTypes = [String, RegExp];\n\t\n\tfunction matches (pattern, name) {\n\t  if (typeof pattern === 'string') {\n\t    return pattern.split(',').indexOf(name) > -1\n\t  } else {\n\t    return pattern.test(name)\n\t  }\n\t}\n\t\n\tvar KeepAlive = {\n\t  name: 'keep-alive',\n\t  abstract: true,\n\t  props: {\n\t    include: patternTypes,\n\t    exclude: patternTypes\n\t  },\n\t  created: function created () {\n\t    this.cache = Object.create(null);\n\t  },\n\t  render: function render () {\n\t    var vnode = getFirstComponentChild(this.$slots.default);\n\t    if (vnode && vnode.componentOptions) {\n\t      var opts = vnode.componentOptions;\n\t      // check pattern\n\t      var name = opts.Ctor.options.name || opts.tag;\n\t      if (name && (\n\t        (this.include && !matches(this.include, name)) ||\n\t        (this.exclude && matches(this.exclude, name))\n\t      )) {\n\t        return vnode\n\t      }\n\t      var key = vnode.key == null\n\t        // same constructor may get registered as different local components\n\t        // so cid alone is not enough (#3269)\n\t        ? opts.Ctor.cid + (opts.tag ? (\"::\" + (opts.tag)) : '')\n\t        : vnode.key;\n\t      if (this.cache[key]) {\n\t        vnode.child = this.cache[key].child;\n\t      } else {\n\t        this.cache[key] = vnode;\n\t      }\n\t      vnode.data.keepAlive = true;\n\t    }\n\t    return vnode\n\t  },\n\t  destroyed: function destroyed () {\n\t    var this$1 = this;\n\t\n\t    for (var key in this.cache) {\n\t      var vnode = this$1.cache[key];\n\t      callHook(vnode.child, 'deactivated');\n\t      vnode.child.$destroy();\n\t    }\n\t  }\n\t};\n\t\n\tvar builtInComponents = {\n\t  KeepAlive: KeepAlive\n\t};\n\t\n\t/*  */\n\t\n\tfunction initGlobalAPI (Vue) {\n\t  // config\n\t  var configDef = {};\n\t  configDef.get = function () { return config; };\n\t  if (false) {\n\t    configDef.set = function () {\n\t      warn(\n\t        'Do not replace the Vue.config object, set individual fields instead.'\n\t      );\n\t    };\n\t  }\n\t  Object.defineProperty(Vue, 'config', configDef);\n\t  Vue.util = util;\n\t  Vue.set = set$1;\n\t  Vue.delete = del;\n\t  Vue.nextTick = nextTick;\n\t\n\t  Vue.options = Object.create(null);\n\t  config._assetTypes.forEach(function (type) {\n\t    Vue.options[type + 's'] = Object.create(null);\n\t  });\n\t\n\t  // this is used to identify the \"base\" constructor to extend all plain-object\n\t  // components with in Weex's multi-instance scenarios.\n\t  Vue.options._base = Vue;\n\t\n\t  extend(Vue.options.components, builtInComponents);\n\t\n\t  initUse(Vue);\n\t  initMixin$1(Vue);\n\t  initExtend(Vue);\n\t  initAssetRegisters(Vue);\n\t}\n\t\n\tinitGlobalAPI(Vue$2);\n\t\n\tObject.defineProperty(Vue$2.prototype, '$isServer', {\n\t  get: isServerRendering\n\t});\n\t\n\tVue$2.version = '2.1.8';\n\t\n\t/*  */\n\t\n\t// attributes that should be using props for binding\n\tvar acceptValue = makeMap('input,textarea,option,select');\n\tvar mustUseProp = function (tag, attr) {\n\t  return (\n\t    (attr === 'value' && acceptValue(tag)) ||\n\t    (attr === 'selected' && tag === 'option') ||\n\t    (attr === 'checked' && tag === 'input') ||\n\t    (attr === 'muted' && tag === 'video')\n\t  )\n\t};\n\t\n\tvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\t\n\tvar isBooleanAttr = makeMap(\n\t  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n\t  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n\t  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n\t  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n\t  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n\t  'truespeed,typemustmatch,visible'\n\t);\n\t\n\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\t\n\tvar isXlink = function (name) {\n\t  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n\t};\n\t\n\tvar getXlinkProp = function (name) {\n\t  return isXlink(name) ? name.slice(6, name.length) : ''\n\t};\n\t\n\tvar isFalsyAttrValue = function (val) {\n\t  return val == null || val === false\n\t};\n\t\n\t/*  */\n\t\n\tfunction genClassForVnode (vnode) {\n\t  var data = vnode.data;\n\t  var parentNode = vnode;\n\t  var childNode = vnode;\n\t  while (childNode.child) {\n\t    childNode = childNode.child._vnode;\n\t    if (childNode.data) {\n\t      data = mergeClassData(childNode.data, data);\n\t    }\n\t  }\n\t  while ((parentNode = parentNode.parent)) {\n\t    if (parentNode.data) {\n\t      data = mergeClassData(data, parentNode.data);\n\t    }\n\t  }\n\t  return genClassFromData(data)\n\t}\n\t\n\tfunction mergeClassData (child, parent) {\n\t  return {\n\t    staticClass: concat(child.staticClass, parent.staticClass),\n\t    class: child.class\n\t      ? [child.class, parent.class]\n\t      : parent.class\n\t  }\n\t}\n\t\n\tfunction genClassFromData (data) {\n\t  var dynamicClass = data.class;\n\t  var staticClass = data.staticClass;\n\t  if (staticClass || dynamicClass) {\n\t    return concat(staticClass, stringifyClass(dynamicClass))\n\t  }\n\t  /* istanbul ignore next */\n\t  return ''\n\t}\n\t\n\tfunction concat (a, b) {\n\t  return a ? b ? (a + ' ' + b) : a : (b || '')\n\t}\n\t\n\tfunction stringifyClass (value) {\n\t  var res = '';\n\t  if (!value) {\n\t    return res\n\t  }\n\t  if (typeof value === 'string') {\n\t    return value\n\t  }\n\t  if (Array.isArray(value)) {\n\t    var stringified;\n\t    for (var i = 0, l = value.length; i < l; i++) {\n\t      if (value[i]) {\n\t        if ((stringified = stringifyClass(value[i]))) {\n\t          res += stringified + ' ';\n\t        }\n\t      }\n\t    }\n\t    return res.slice(0, -1)\n\t  }\n\t  if (isObject(value)) {\n\t    for (var key in value) {\n\t      if (value[key]) { res += key + ' '; }\n\t    }\n\t    return res.slice(0, -1)\n\t  }\n\t  /* istanbul ignore next */\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tvar namespaceMap = {\n\t  svg: 'http://www.w3.org/2000/svg',\n\t  math: 'http://www.w3.org/1998/Math/MathML'\n\t};\n\t\n\tvar isHTMLTag = makeMap(\n\t  'html,body,base,head,link,meta,style,title,' +\n\t  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n\t  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n\t  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n\t  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n\t  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n\t  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n\t  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n\t  'output,progress,select,textarea,' +\n\t  'details,dialog,menu,menuitem,summary,' +\n\t  'content,element,shadow,template'\n\t);\n\t\n\t// this map is intentionally selective, only covering SVG elements that may\n\t// contain child elements.\n\tvar isSVG = makeMap(\n\t  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,' +\n\t  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n\t  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n\t  true\n\t);\n\t\n\t\n\t\n\tvar isReservedTag = function (tag) {\n\t  return isHTMLTag(tag) || isSVG(tag)\n\t};\n\t\n\tfunction getTagNamespace (tag) {\n\t  if (isSVG(tag)) {\n\t    return 'svg'\n\t  }\n\t  // basic support for MathML\n\t  // note it doesn't support other MathML elements being component roots\n\t  if (tag === 'math') {\n\t    return 'math'\n\t  }\n\t}\n\t\n\tvar unknownElementCache = Object.create(null);\n\tfunction isUnknownElement (tag) {\n\t  /* istanbul ignore if */\n\t  if (!inBrowser) {\n\t    return true\n\t  }\n\t  if (isReservedTag(tag)) {\n\t    return false\n\t  }\n\t  tag = tag.toLowerCase();\n\t  /* istanbul ignore if */\n\t  if (unknownElementCache[tag] != null) {\n\t    return unknownElementCache[tag]\n\t  }\n\t  var el = document.createElement(tag);\n\t  if (tag.indexOf('-') > -1) {\n\t    // http://stackoverflow.com/a/28210364/1070244\n\t    return (unknownElementCache[tag] = (\n\t      el.constructor === window.HTMLUnknownElement ||\n\t      el.constructor === window.HTMLElement\n\t    ))\n\t  } else {\n\t    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t/**\n\t * Query an element selector if it's not an element already.\n\t */\n\tfunction query (el) {\n\t  if (typeof el === 'string') {\n\t    var selector = el;\n\t    el = document.querySelector(el);\n\t    if (!el) {\n\t      (\"production\") !== 'production' && warn(\n\t        'Cannot find element: ' + selector\n\t      );\n\t      return document.createElement('div')\n\t    }\n\t  }\n\t  return el\n\t}\n\t\n\t/*  */\n\t\n\tfunction createElement$1 (tagName, vnode) {\n\t  var elm = document.createElement(tagName);\n\t  if (tagName !== 'select') {\n\t    return elm\n\t  }\n\t  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {\n\t    elm.setAttribute('multiple', 'multiple');\n\t  }\n\t  return elm\n\t}\n\t\n\tfunction createElementNS (namespace, tagName) {\n\t  return document.createElementNS(namespaceMap[namespace], tagName)\n\t}\n\t\n\tfunction createTextNode (text) {\n\t  return document.createTextNode(text)\n\t}\n\t\n\tfunction createComment (text) {\n\t  return document.createComment(text)\n\t}\n\t\n\tfunction insertBefore (parentNode, newNode, referenceNode) {\n\t  parentNode.insertBefore(newNode, referenceNode);\n\t}\n\t\n\tfunction removeChild (node, child) {\n\t  node.removeChild(child);\n\t}\n\t\n\tfunction appendChild (node, child) {\n\t  node.appendChild(child);\n\t}\n\t\n\tfunction parentNode (node) {\n\t  return node.parentNode\n\t}\n\t\n\tfunction nextSibling (node) {\n\t  return node.nextSibling\n\t}\n\t\n\tfunction tagName (node) {\n\t  return node.tagName\n\t}\n\t\n\tfunction setTextContent (node, text) {\n\t  node.textContent = text;\n\t}\n\t\n\tfunction setAttribute (node, key, val) {\n\t  node.setAttribute(key, val);\n\t}\n\t\n\t\n\tvar nodeOps = Object.freeze({\n\t\tcreateElement: createElement$1,\n\t\tcreateElementNS: createElementNS,\n\t\tcreateTextNode: createTextNode,\n\t\tcreateComment: createComment,\n\t\tinsertBefore: insertBefore,\n\t\tremoveChild: removeChild,\n\t\tappendChild: appendChild,\n\t\tparentNode: parentNode,\n\t\tnextSibling: nextSibling,\n\t\ttagName: tagName,\n\t\tsetTextContent: setTextContent,\n\t\tsetAttribute: setAttribute\n\t});\n\t\n\t/*  */\n\t\n\tvar ref = {\n\t  create: function create (_, vnode) {\n\t    registerRef(vnode);\n\t  },\n\t  update: function update (oldVnode, vnode) {\n\t    if (oldVnode.data.ref !== vnode.data.ref) {\n\t      registerRef(oldVnode, true);\n\t      registerRef(vnode);\n\t    }\n\t  },\n\t  destroy: function destroy (vnode) {\n\t    registerRef(vnode, true);\n\t  }\n\t};\n\t\n\tfunction registerRef (vnode, isRemoval) {\n\t  var key = vnode.data.ref;\n\t  if (!key) { return }\n\t\n\t  var vm = vnode.context;\n\t  var ref = vnode.child || vnode.elm;\n\t  var refs = vm.$refs;\n\t  if (isRemoval) {\n\t    if (Array.isArray(refs[key])) {\n\t      remove$1(refs[key], ref);\n\t    } else if (refs[key] === ref) {\n\t      refs[key] = undefined;\n\t    }\n\t  } else {\n\t    if (vnode.data.refInFor) {\n\t      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n\t        refs[key].push(ref);\n\t      } else {\n\t        refs[key] = [ref];\n\t      }\n\t    } else {\n\t      refs[key] = ref;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Virtual DOM patching algorithm based on Snabbdom by\n\t * Simon Friis Vindum (@paldepind)\n\t * Licensed under the MIT License\n\t * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n\t *\n\t * modified by Evan You (@yyx990803)\n\t *\n\t\n\t/*\n\t * Not type-checking this because this file is perf-critical and the cost\n\t * of making flow understand it is not worth it.\n\t */\n\t\n\tvar emptyNode = new VNode('', {}, []);\n\t\n\tvar hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];\n\t\n\tfunction isUndef (s) {\n\t  return s == null\n\t}\n\t\n\tfunction isDef (s) {\n\t  return s != null\n\t}\n\t\n\tfunction sameVnode (vnode1, vnode2) {\n\t  return (\n\t    vnode1.key === vnode2.key &&\n\t    vnode1.tag === vnode2.tag &&\n\t    vnode1.isComment === vnode2.isComment &&\n\t    !vnode1.data === !vnode2.data\n\t  )\n\t}\n\t\n\tfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n\t  var i, key;\n\t  var map = {};\n\t  for (i = beginIdx; i <= endIdx; ++i) {\n\t    key = children[i].key;\n\t    if (isDef(key)) { map[key] = i; }\n\t  }\n\t  return map\n\t}\n\t\n\tfunction createPatchFunction (backend) {\n\t  var i, j;\n\t  var cbs = {};\n\t\n\t  var modules = backend.modules;\n\t  var nodeOps = backend.nodeOps;\n\t\n\t  for (i = 0; i < hooks$1.length; ++i) {\n\t    cbs[hooks$1[i]] = [];\n\t    for (j = 0; j < modules.length; ++j) {\n\t      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }\n\t    }\n\t  }\n\t\n\t  function emptyNodeAt (elm) {\n\t    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n\t  }\n\t\n\t  function createRmCb (childElm, listeners) {\n\t    function remove$$1 () {\n\t      if (--remove$$1.listeners === 0) {\n\t        removeNode(childElm);\n\t      }\n\t    }\n\t    remove$$1.listeners = listeners;\n\t    return remove$$1\n\t  }\n\t\n\t  function removeNode (el) {\n\t    var parent = nodeOps.parentNode(el);\n\t    // element may have already been removed due to v-html / v-text\n\t    if (parent) {\n\t      nodeOps.removeChild(parent, el);\n\t    }\n\t  }\n\t\n\t  var inPre = 0;\n\t  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n\t    vnode.isRootInsert = !nested; // for transition enter check\n\t    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n\t      return\n\t    }\n\t\n\t    var data = vnode.data;\n\t    var children = vnode.children;\n\t    var tag = vnode.tag;\n\t    if (isDef(tag)) {\n\t      if (false) {\n\t        if (data && data.pre) {\n\t          inPre++;\n\t        }\n\t        if (\n\t          !inPre &&\n\t          !vnode.ns &&\n\t          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n\t          config.isUnknownElement(tag)\n\t        ) {\n\t          warn(\n\t            'Unknown custom element: <' + tag + '> - did you ' +\n\t            'register the component correctly? For recursive components, ' +\n\t            'make sure to provide the \"name\" option.',\n\t            vnode.context\n\t          );\n\t        }\n\t      }\n\t      vnode.elm = vnode.ns\n\t        ? nodeOps.createElementNS(vnode.ns, tag)\n\t        : nodeOps.createElement(tag, vnode);\n\t      setScope(vnode);\n\t\n\t      /* istanbul ignore if */\n\t      {\n\t        createChildren(vnode, children, insertedVnodeQueue);\n\t        if (isDef(data)) {\n\t          invokeCreateHooks(vnode, insertedVnodeQueue);\n\t        }\n\t        insert(parentElm, vnode.elm, refElm);\n\t      }\n\t\n\t      if (false) {\n\t        inPre--;\n\t      }\n\t    } else if (vnode.isComment) {\n\t      vnode.elm = nodeOps.createComment(vnode.text);\n\t      insert(parentElm, vnode.elm, refElm);\n\t    } else {\n\t      vnode.elm = nodeOps.createTextNode(vnode.text);\n\t      insert(parentElm, vnode.elm, refElm);\n\t    }\n\t  }\n\t\n\t  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n\t    var i = vnode.data;\n\t    if (isDef(i)) {\n\t      var isReactivated = isDef(vnode.child) && i.keepAlive;\n\t      if (isDef(i = i.hook) && isDef(i = i.init)) {\n\t        i(vnode, false /* hydrating */, parentElm, refElm);\n\t      }\n\t      // after calling the init hook, if the vnode is a child component\n\t      // it should've created a child instance and mounted it. the child\n\t      // component also has set the placeholder vnode's elm.\n\t      // in that case we can just return the element and be done.\n\t      if (isDef(vnode.child)) {\n\t        initComponent(vnode, insertedVnodeQueue);\n\t        if (isReactivated) {\n\t          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n\t        }\n\t        return true\n\t      }\n\t    }\n\t  }\n\t\n\t  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n\t    var i;\n\t    // hack for #4339: a reactivated component with inner transition\n\t    // does not trigger because the inner node's created hooks are not called\n\t    // again. It's not ideal to involve module-specific logic in here but\n\t    // there doesn't seem to be a better way to do it.\n\t    var innerNode = vnode;\n\t    while (innerNode.child) {\n\t      innerNode = innerNode.child._vnode;\n\t      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n\t        for (i = 0; i < cbs.activate.length; ++i) {\n\t          cbs.activate[i](emptyNode, innerNode);\n\t        }\n\t        insertedVnodeQueue.push(innerNode);\n\t        break\n\t      }\n\t    }\n\t    // unlike a newly created component,\n\t    // a reactivated keep-alive component doesn't insert itself\n\t    insert(parentElm, vnode.elm, refElm);\n\t  }\n\t\n\t  function insert (parent, elm, ref) {\n\t    if (parent) {\n\t      if (ref) {\n\t        nodeOps.insertBefore(parent, elm, ref);\n\t      } else {\n\t        nodeOps.appendChild(parent, elm);\n\t      }\n\t    }\n\t  }\n\t\n\t  function createChildren (vnode, children, insertedVnodeQueue) {\n\t    if (Array.isArray(children)) {\n\t      for (var i = 0; i < children.length; ++i) {\n\t        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n\t      }\n\t    } else if (isPrimitive(vnode.text)) {\n\t      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n\t    }\n\t  }\n\t\n\t  function isPatchable (vnode) {\n\t    while (vnode.child) {\n\t      vnode = vnode.child._vnode;\n\t    }\n\t    return isDef(vnode.tag)\n\t  }\n\t\n\t  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n\t    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n\t      cbs.create[i$1](emptyNode, vnode);\n\t    }\n\t    i = vnode.data.hook; // Reuse variable\n\t    if (isDef(i)) {\n\t      if (i.create) { i.create(emptyNode, vnode); }\n\t      if (i.insert) { insertedVnodeQueue.push(vnode); }\n\t    }\n\t  }\n\t\n\t  function initComponent (vnode, insertedVnodeQueue) {\n\t    if (vnode.data.pendingInsert) {\n\t      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n\t    }\n\t    vnode.elm = vnode.child.$el;\n\t    if (isPatchable(vnode)) {\n\t      invokeCreateHooks(vnode, insertedVnodeQueue);\n\t      setScope(vnode);\n\t    } else {\n\t      // empty component root.\n\t      // skip all element-related modules except for ref (#3455)\n\t      registerRef(vnode);\n\t      // make sure to invoke the insert hook\n\t      insertedVnodeQueue.push(vnode);\n\t    }\n\t  }\n\t\n\t  // set scope id attribute for scoped CSS.\n\t  // this is implemented as a special case to avoid the overhead\n\t  // of going through the normal attribute patching process.\n\t  function setScope (vnode) {\n\t    var i;\n\t    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {\n\t      nodeOps.setAttribute(vnode.elm, i, '');\n\t    }\n\t    if (isDef(i = activeInstance) &&\n\t        i !== vnode.context &&\n\t        isDef(i = i.$options._scopeId)) {\n\t      nodeOps.setAttribute(vnode.elm, i, '');\n\t    }\n\t  }\n\t\n\t  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n\t    for (; startIdx <= endIdx; ++startIdx) {\n\t      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n\t    }\n\t  }\n\t\n\t  function invokeDestroyHook (vnode) {\n\t    var i, j;\n\t    var data = vnode.data;\n\t    if (isDef(data)) {\n\t      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n\t      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n\t    }\n\t    if (isDef(i = vnode.children)) {\n\t      for (j = 0; j < vnode.children.length; ++j) {\n\t        invokeDestroyHook(vnode.children[j]);\n\t      }\n\t    }\n\t  }\n\t\n\t  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n\t    for (; startIdx <= endIdx; ++startIdx) {\n\t      var ch = vnodes[startIdx];\n\t      if (isDef(ch)) {\n\t        if (isDef(ch.tag)) {\n\t          removeAndInvokeRemoveHook(ch);\n\t          invokeDestroyHook(ch);\n\t        } else { // Text node\n\t          removeNode(ch.elm);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  function removeAndInvokeRemoveHook (vnode, rm) {\n\t    if (rm || isDef(vnode.data)) {\n\t      var listeners = cbs.remove.length + 1;\n\t      if (!rm) {\n\t        // directly removing\n\t        rm = createRmCb(vnode.elm, listeners);\n\t      } else {\n\t        // we have a recursively passed down rm callback\n\t        // increase the listeners count\n\t        rm.listeners += listeners;\n\t      }\n\t      // recursively invoke hooks on child component root node\n\t      if (isDef(i = vnode.child) && isDef(i = i._vnode) && isDef(i.data)) {\n\t        removeAndInvokeRemoveHook(i, rm);\n\t      }\n\t      for (i = 0; i < cbs.remove.length; ++i) {\n\t        cbs.remove[i](vnode, rm);\n\t      }\n\t      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n\t        i(vnode, rm);\n\t      } else {\n\t        rm();\n\t      }\n\t    } else {\n\t      removeNode(vnode.elm);\n\t    }\n\t  }\n\t\n\t  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n\t    var oldStartIdx = 0;\n\t    var newStartIdx = 0;\n\t    var oldEndIdx = oldCh.length - 1;\n\t    var oldStartVnode = oldCh[0];\n\t    var oldEndVnode = oldCh[oldEndIdx];\n\t    var newEndIdx = newCh.length - 1;\n\t    var newStartVnode = newCh[0];\n\t    var newEndVnode = newCh[newEndIdx];\n\t    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\t\n\t    // removeOnly is a special flag used only by <transition-group>\n\t    // to ensure removed elements stay in correct relative positions\n\t    // during leaving transitions\n\t    var canMove = !removeOnly;\n\t\n\t    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n\t      if (isUndef(oldStartVnode)) {\n\t        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n\t      } else if (isUndef(oldEndVnode)) {\n\t        oldEndVnode = oldCh[--oldEndIdx];\n\t      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n\t        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n\t        oldStartVnode = oldCh[++oldStartIdx];\n\t        newStartVnode = newCh[++newStartIdx];\n\t      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n\t        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n\t        oldEndVnode = oldCh[--oldEndIdx];\n\t        newEndVnode = newCh[--newEndIdx];\n\t      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n\t        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n\t        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n\t        oldStartVnode = oldCh[++oldStartIdx];\n\t        newEndVnode = newCh[--newEndIdx];\n\t      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n\t        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n\t        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n\t        oldEndVnode = oldCh[--oldEndIdx];\n\t        newStartVnode = newCh[++newStartIdx];\n\t      } else {\n\t        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n\t        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n\t        if (isUndef(idxInOld)) { // New element\n\t          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n\t          newStartVnode = newCh[++newStartIdx];\n\t        } else {\n\t          elmToMove = oldCh[idxInOld];\n\t          /* istanbul ignore if */\n\t          if (false) {\n\t            warn(\n\t              'It seems there are duplicate keys that is causing an update error. ' +\n\t              'Make sure each v-for item has a unique key.'\n\t            );\n\t          }\n\t          if (sameVnode(elmToMove, newStartVnode)) {\n\t            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n\t            oldCh[idxInOld] = undefined;\n\t            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n\t            newStartVnode = newCh[++newStartIdx];\n\t          } else {\n\t            // same key but different element. treat as new element\n\t            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n\t            newStartVnode = newCh[++newStartIdx];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    if (oldStartIdx > oldEndIdx) {\n\t      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n\t      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n\t    } else if (newStartIdx > newEndIdx) {\n\t      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n\t    }\n\t  }\n\t\n\t  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n\t    if (oldVnode === vnode) {\n\t      return\n\t    }\n\t    // reuse element for static trees.\n\t    // note we only do this if the vnode is cloned -\n\t    // if the new node is not cloned it means the render functions have been\n\t    // reset by the hot-reload-api and we need to do a proper re-render.\n\t    if (vnode.isStatic &&\n\t        oldVnode.isStatic &&\n\t        vnode.key === oldVnode.key &&\n\t        (vnode.isCloned || vnode.isOnce)) {\n\t      vnode.elm = oldVnode.elm;\n\t      vnode.child = oldVnode.child;\n\t      return\n\t    }\n\t    var i;\n\t    var data = vnode.data;\n\t    var hasData = isDef(data);\n\t    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n\t      i(oldVnode, vnode);\n\t    }\n\t    var elm = vnode.elm = oldVnode.elm;\n\t    var oldCh = oldVnode.children;\n\t    var ch = vnode.children;\n\t    if (hasData && isPatchable(vnode)) {\n\t      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n\t      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n\t    }\n\t    if (isUndef(vnode.text)) {\n\t      if (isDef(oldCh) && isDef(ch)) {\n\t        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n\t      } else if (isDef(ch)) {\n\t        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n\t        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n\t      } else if (isDef(oldCh)) {\n\t        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n\t      } else if (isDef(oldVnode.text)) {\n\t        nodeOps.setTextContent(elm, '');\n\t      }\n\t    } else if (oldVnode.text !== vnode.text) {\n\t      nodeOps.setTextContent(elm, vnode.text);\n\t    }\n\t    if (hasData) {\n\t      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n\t    }\n\t  }\n\t\n\t  function invokeInsertHook (vnode, queue, initial) {\n\t    // delay insert hooks for component root nodes, invoke them after the\n\t    // element is really inserted\n\t    if (initial && vnode.parent) {\n\t      vnode.parent.data.pendingInsert = queue;\n\t    } else {\n\t      for (var i = 0; i < queue.length; ++i) {\n\t        queue[i].data.hook.insert(queue[i]);\n\t      }\n\t    }\n\t  }\n\t\n\t  var bailed = false;\n\t  // list of modules that can skip create hook during hydration because they\n\t  // are already rendered on the client or has no need for initialization\n\t  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\t\n\t  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n\t  function hydrate (elm, vnode, insertedVnodeQueue) {\n\t    if (false) {\n\t      if (!assertNodeMatch(elm, vnode)) {\n\t        return false\n\t      }\n\t    }\n\t    vnode.elm = elm;\n\t    var tag = vnode.tag;\n\t    var data = vnode.data;\n\t    var children = vnode.children;\n\t    if (isDef(data)) {\n\t      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n\t      if (isDef(i = vnode.child)) {\n\t        // child component. it should have hydrated its own tree.\n\t        initComponent(vnode, insertedVnodeQueue);\n\t        return true\n\t      }\n\t    }\n\t    if (isDef(tag)) {\n\t      if (isDef(children)) {\n\t        // empty element, allow client to pick up and populate children\n\t        if (!elm.hasChildNodes()) {\n\t          createChildren(vnode, children, insertedVnodeQueue);\n\t        } else {\n\t          var childrenMatch = true;\n\t          var childNode = elm.firstChild;\n\t          for (var i$1 = 0; i$1 < children.length; i$1++) {\n\t            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n\t              childrenMatch = false;\n\t              break\n\t            }\n\t            childNode = childNode.nextSibling;\n\t          }\n\t          // if childNode is not null, it means the actual childNodes list is\n\t          // longer than the virtual children list.\n\t          if (!childrenMatch || childNode) {\n\t            if (false) {\n\t              bailed = true;\n\t              console.warn('Parent: ', elm);\n\t              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n\t            }\n\t            return false\n\t          }\n\t        }\n\t      }\n\t      if (isDef(data)) {\n\t        for (var key in data) {\n\t          if (!isRenderedModule(key)) {\n\t            invokeCreateHooks(vnode, insertedVnodeQueue);\n\t            break\n\t          }\n\t        }\n\t      }\n\t    } else if (elm.data !== vnode.text) {\n\t      elm.data = vnode.text;\n\t    }\n\t    return true\n\t  }\n\t\n\t  function assertNodeMatch (node, vnode) {\n\t    if (vnode.tag) {\n\t      return (\n\t        vnode.tag.indexOf('vue-component') === 0 ||\n\t        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n\t      )\n\t    } else {\n\t      return node.nodeType === (vnode.isComment ? 8 : 3)\n\t    }\n\t  }\n\t\n\t  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n\t    if (!vnode) {\n\t      if (oldVnode) { invokeDestroyHook(oldVnode); }\n\t      return\n\t    }\n\t\n\t    var elm, parent;\n\t    var isInitialPatch = false;\n\t    var insertedVnodeQueue = [];\n\t\n\t    if (!oldVnode) {\n\t      // empty mount (likely as component), create new root element\n\t      isInitialPatch = true;\n\t      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n\t    } else {\n\t      var isRealElement = isDef(oldVnode.nodeType);\n\t      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n\t        // patch existing root node\n\t        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n\t      } else {\n\t        if (isRealElement) {\n\t          // mounting to a real element\n\t          // check if this is server-rendered content and if we can perform\n\t          // a successful hydration.\n\t          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n\t            oldVnode.removeAttribute('server-rendered');\n\t            hydrating = true;\n\t          }\n\t          if (hydrating) {\n\t            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n\t              invokeInsertHook(vnode, insertedVnodeQueue, true);\n\t              return oldVnode\n\t            } else if (false) {\n\t              warn(\n\t                'The client-side rendered virtual DOM tree is not matching ' +\n\t                'server-rendered content. This is likely caused by incorrect ' +\n\t                'HTML markup, for example nesting block-level elements inside ' +\n\t                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n\t                'full client-side render.'\n\t              );\n\t            }\n\t          }\n\t          // either not server-rendered, or hydration failed.\n\t          // create an empty node and replace it\n\t          oldVnode = emptyNodeAt(oldVnode);\n\t        }\n\t        // replacing existing element\n\t        elm = oldVnode.elm;\n\t        parent = nodeOps.parentNode(elm);\n\t        createElm(vnode, insertedVnodeQueue, parent, nodeOps.nextSibling(elm));\n\t\n\t        if (vnode.parent) {\n\t          // component root element replaced.\n\t          // update parent placeholder node element, recursively\n\t          var ancestor = vnode.parent;\n\t          while (ancestor) {\n\t            ancestor.elm = vnode.elm;\n\t            ancestor = ancestor.parent;\n\t          }\n\t          if (isPatchable(vnode)) {\n\t            for (var i = 0; i < cbs.create.length; ++i) {\n\t              cbs.create[i](emptyNode, vnode.parent);\n\t            }\n\t          }\n\t        }\n\t\n\t        if (parent !== null) {\n\t          removeVnodes(parent, [oldVnode], 0, 0);\n\t        } else if (isDef(oldVnode.tag)) {\n\t          invokeDestroyHook(oldVnode);\n\t        }\n\t      }\n\t    }\n\t\n\t    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n\t    return vnode.elm\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar directives = {\n\t  create: updateDirectives,\n\t  update: updateDirectives,\n\t  destroy: function unbindDirectives (vnode) {\n\t    updateDirectives(vnode, emptyNode);\n\t  }\n\t};\n\t\n\tfunction updateDirectives (oldVnode, vnode) {\n\t  if (oldVnode.data.directives || vnode.data.directives) {\n\t    _update(oldVnode, vnode);\n\t  }\n\t}\n\t\n\tfunction _update (oldVnode, vnode) {\n\t  var isCreate = oldVnode === emptyNode;\n\t  var isDestroy = vnode === emptyNode;\n\t  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n\t  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\t\n\t  var dirsWithInsert = [];\n\t  var dirsWithPostpatch = [];\n\t\n\t  var key, oldDir, dir;\n\t  for (key in newDirs) {\n\t    oldDir = oldDirs[key];\n\t    dir = newDirs[key];\n\t    if (!oldDir) {\n\t      // new directive, bind\n\t      callHook$1(dir, 'bind', vnode, oldVnode);\n\t      if (dir.def && dir.def.inserted) {\n\t        dirsWithInsert.push(dir);\n\t      }\n\t    } else {\n\t      // existing directive, update\n\t      dir.oldValue = oldDir.value;\n\t      callHook$1(dir, 'update', vnode, oldVnode);\n\t      if (dir.def && dir.def.componentUpdated) {\n\t        dirsWithPostpatch.push(dir);\n\t      }\n\t    }\n\t  }\n\t\n\t  if (dirsWithInsert.length) {\n\t    var callInsert = function () {\n\t      for (var i = 0; i < dirsWithInsert.length; i++) {\n\t        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n\t      }\n\t    };\n\t    if (isCreate) {\n\t      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');\n\t    } else {\n\t      callInsert();\n\t    }\n\t  }\n\t\n\t  if (dirsWithPostpatch.length) {\n\t    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n\t      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n\t        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n\t      }\n\t    }, 'dir-postpatch');\n\t  }\n\t\n\t  if (!isCreate) {\n\t    for (key in oldDirs) {\n\t      if (!newDirs[key]) {\n\t        // no longer present, unbind\n\t        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tvar emptyModifiers = Object.create(null);\n\t\n\tfunction normalizeDirectives$1 (\n\t  dirs,\n\t  vm\n\t) {\n\t  var res = Object.create(null);\n\t  if (!dirs) {\n\t    return res\n\t  }\n\t  var i, dir;\n\t  for (i = 0; i < dirs.length; i++) {\n\t    dir = dirs[i];\n\t    if (!dir.modifiers) {\n\t      dir.modifiers = emptyModifiers;\n\t    }\n\t    res[getRawDirName(dir)] = dir;\n\t    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n\t  }\n\t  return res\n\t}\n\t\n\tfunction getRawDirName (dir) {\n\t  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n\t}\n\t\n\tfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n\t  var fn = dir.def && dir.def[hook];\n\t  if (fn) {\n\t    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n\t  }\n\t}\n\t\n\tvar baseModules = [\n\t  ref,\n\t  directives\n\t];\n\t\n\t/*  */\n\t\n\tfunction updateAttrs (oldVnode, vnode) {\n\t  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n\t    return\n\t  }\n\t  var key, cur, old;\n\t  var elm = vnode.elm;\n\t  var oldAttrs = oldVnode.data.attrs || {};\n\t  var attrs = vnode.data.attrs || {};\n\t  // clone observed objects, as the user probably wants to mutate it\n\t  if (attrs.__ob__) {\n\t    attrs = vnode.data.attrs = extend({}, attrs);\n\t  }\n\t\n\t  for (key in attrs) {\n\t    cur = attrs[key];\n\t    old = oldAttrs[key];\n\t    if (old !== cur) {\n\t      setAttr(elm, key, cur);\n\t    }\n\t  }\n\t  // #4391: in IE9, setting type can reset value for input[type=radio]\n\t  /* istanbul ignore if */\n\t  if (isIE9 && attrs.value !== oldAttrs.value) {\n\t    setAttr(elm, 'value', attrs.value);\n\t  }\n\t  for (key in oldAttrs) {\n\t    if (attrs[key] == null) {\n\t      if (isXlink(key)) {\n\t        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n\t      } else if (!isEnumeratedAttr(key)) {\n\t        elm.removeAttribute(key);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction setAttr (el, key, value) {\n\t  if (isBooleanAttr(key)) {\n\t    // set attribute for blank value\n\t    // e.g. <option disabled>Select one</option>\n\t    if (isFalsyAttrValue(value)) {\n\t      el.removeAttribute(key);\n\t    } else {\n\t      el.setAttribute(key, key);\n\t    }\n\t  } else if (isEnumeratedAttr(key)) {\n\t    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n\t  } else if (isXlink(key)) {\n\t    if (isFalsyAttrValue(value)) {\n\t      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n\t    } else {\n\t      el.setAttributeNS(xlinkNS, key, value);\n\t    }\n\t  } else {\n\t    if (isFalsyAttrValue(value)) {\n\t      el.removeAttribute(key);\n\t    } else {\n\t      el.setAttribute(key, value);\n\t    }\n\t  }\n\t}\n\t\n\tvar attrs = {\n\t  create: updateAttrs,\n\t  update: updateAttrs\n\t};\n\t\n\t/*  */\n\t\n\tfunction updateClass (oldVnode, vnode) {\n\t  var el = vnode.elm;\n\t  var data = vnode.data;\n\t  var oldData = oldVnode.data;\n\t  if (!data.staticClass && !data.class &&\n\t      (!oldData || (!oldData.staticClass && !oldData.class))) {\n\t    return\n\t  }\n\t\n\t  var cls = genClassForVnode(vnode);\n\t\n\t  // handle transition classes\n\t  var transitionClass = el._transitionClasses;\n\t  if (transitionClass) {\n\t    cls = concat(cls, stringifyClass(transitionClass));\n\t  }\n\t\n\t  // set the class\n\t  if (cls !== el._prevClass) {\n\t    el.setAttribute('class', cls);\n\t    el._prevClass = cls;\n\t  }\n\t}\n\t\n\tvar klass = {\n\t  create: updateClass,\n\t  update: updateClass\n\t};\n\t\n\t/*  */\n\t\n\tvar target$1;\n\t\n\tfunction add$2 (event, handler, once, capture) {\n\t  if (once) {\n\t    var oldHandler = handler;\n\t    handler = function (ev) {\n\t      remove$3(event, handler, capture);\n\t      arguments.length === 1\n\t        ? oldHandler(ev)\n\t        : oldHandler.apply(null, arguments);\n\t    };\n\t  }\n\t  target$1.addEventListener(event, handler, capture);\n\t}\n\t\n\tfunction remove$3 (event, handler, capture) {\n\t  target$1.removeEventListener(event, handler, capture);\n\t}\n\t\n\tfunction updateDOMListeners (oldVnode, vnode) {\n\t  if (!oldVnode.data.on && !vnode.data.on) {\n\t    return\n\t  }\n\t  var on = vnode.data.on || {};\n\t  var oldOn = oldVnode.data.on || {};\n\t  target$1 = vnode.elm;\n\t  updateListeners(on, oldOn, add$2, remove$3, vnode.context);\n\t}\n\t\n\tvar events = {\n\t  create: updateDOMListeners,\n\t  update: updateDOMListeners\n\t};\n\t\n\t/*  */\n\t\n\tfunction updateDOMProps (oldVnode, vnode) {\n\t  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n\t    return\n\t  }\n\t  var key, cur;\n\t  var elm = vnode.elm;\n\t  var oldProps = oldVnode.data.domProps || {};\n\t  var props = vnode.data.domProps || {};\n\t  // clone observed objects, as the user probably wants to mutate it\n\t  if (props.__ob__) {\n\t    props = vnode.data.domProps = extend({}, props);\n\t  }\n\t\n\t  for (key in oldProps) {\n\t    if (props[key] == null) {\n\t      elm[key] = '';\n\t    }\n\t  }\n\t  for (key in props) {\n\t    cur = props[key];\n\t    // ignore children if the node has textContent or innerHTML,\n\t    // as these will throw away existing DOM nodes and cause removal errors\n\t    // on subsequent patches (#3360)\n\t    if (key === 'textContent' || key === 'innerHTML') {\n\t      if (vnode.children) { vnode.children.length = 0; }\n\t      if (cur === oldProps[key]) { continue }\n\t    }\n\t    // #4521: if a click event triggers update before the change event is\n\t    // dispatched on a checkbox/radio input, the input's checked state will\n\t    // be reset and fail to trigger another update.\n\t    /* istanbul ignore next */\n\t    if (key === 'checked' && !isDirty(elm, cur)) {\n\t      continue\n\t    }\n\t    if (key === 'value') {\n\t      // store value as _value as well since\n\t      // non-string values will be stringified\n\t      elm._value = cur;\n\t      // avoid resetting cursor position when value is the same\n\t      var strCur = cur == null ? '' : String(cur);\n\t      if (shouldUpdateValue(elm, vnode, strCur)) {\n\t        elm.value = strCur;\n\t      }\n\t    } else {\n\t      elm[key] = cur;\n\t    }\n\t  }\n\t}\n\t\n\t// check platforms/web/util/attrs.js acceptValue\n\t\n\t\n\tfunction shouldUpdateValue (\n\t  elm,\n\t  vnode,\n\t  checkVal\n\t) {\n\t  if (!elm.composing && (\n\t    vnode.tag === 'option' ||\n\t    isDirty(elm, checkVal) ||\n\t    isInputChanged(vnode, checkVal)\n\t  )) {\n\t    return true\n\t  }\n\t  return false\n\t}\n\t\n\tfunction isDirty (elm, checkVal) {\n\t  return document.activeElement !== elm && elm.value !== checkVal\n\t}\n\t\n\tfunction isInputChanged (vnode, newVal) {\n\t  var value = vnode.elm.value;\n\t  var modifiers = vnode.elm._vModifiers; // injected by v-model runtime\n\t  if ((modifiers && modifiers.number) || vnode.elm.type === 'number') {\n\t    return toNumber(value) !== toNumber(newVal)\n\t  }\n\t  if (modifiers && modifiers.trim) {\n\t    return value.trim() !== newVal.trim()\n\t  }\n\t  return value !== newVal\n\t}\n\t\n\tvar domProps = {\n\t  create: updateDOMProps,\n\t  update: updateDOMProps\n\t};\n\t\n\t/*  */\n\t\n\tvar parseStyleText = cached(function (cssText) {\n\t  var res = {};\n\t  var listDelimiter = /;(?![^(]*\\))/g;\n\t  var propertyDelimiter = /:(.+)/;\n\t  cssText.split(listDelimiter).forEach(function (item) {\n\t    if (item) {\n\t      var tmp = item.split(propertyDelimiter);\n\t      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n\t    }\n\t  });\n\t  return res\n\t});\n\t\n\t// merge static and dynamic style data on the same vnode\n\tfunction normalizeStyleData (data) {\n\t  var style = normalizeStyleBinding(data.style);\n\t  // static style is pre-processed into an object during compilation\n\t  // and is always a fresh object, so it's safe to merge into it\n\t  return data.staticStyle\n\t    ? extend(data.staticStyle, style)\n\t    : style\n\t}\n\t\n\t// normalize possible array / string values into Object\n\tfunction normalizeStyleBinding (bindingStyle) {\n\t  if (Array.isArray(bindingStyle)) {\n\t    return toObject(bindingStyle)\n\t  }\n\t  if (typeof bindingStyle === 'string') {\n\t    return parseStyleText(bindingStyle)\n\t  }\n\t  return bindingStyle\n\t}\n\t\n\t/**\n\t * parent component style should be after child's\n\t * so that parent component's style could override it\n\t */\n\tfunction getStyle (vnode, checkChild) {\n\t  var res = {};\n\t  var styleData;\n\t\n\t  if (checkChild) {\n\t    var childNode = vnode;\n\t    while (childNode.child) {\n\t      childNode = childNode.child._vnode;\n\t      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n\t        extend(res, styleData);\n\t      }\n\t    }\n\t  }\n\t\n\t  if ((styleData = normalizeStyleData(vnode.data))) {\n\t    extend(res, styleData);\n\t  }\n\t\n\t  var parentNode = vnode;\n\t  while ((parentNode = parentNode.parent)) {\n\t    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n\t      extend(res, styleData);\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tvar cssVarRE = /^--/;\n\tvar importantRE = /\\s*!important$/;\n\tvar setProp = function (el, name, val) {\n\t  /* istanbul ignore if */\n\t  if (cssVarRE.test(name)) {\n\t    el.style.setProperty(name, val);\n\t  } else if (importantRE.test(val)) {\n\t    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n\t  } else {\n\t    el.style[normalize(name)] = val;\n\t  }\n\t};\n\t\n\tvar prefixes = ['Webkit', 'Moz', 'ms'];\n\t\n\tvar testEl;\n\tvar normalize = cached(function (prop) {\n\t  testEl = testEl || document.createElement('div');\n\t  prop = camelize(prop);\n\t  if (prop !== 'filter' && (prop in testEl.style)) {\n\t    return prop\n\t  }\n\t  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n\t  for (var i = 0; i < prefixes.length; i++) {\n\t    var prefixed = prefixes[i] + upper;\n\t    if (prefixed in testEl.style) {\n\t      return prefixed\n\t    }\n\t  }\n\t});\n\t\n\tfunction updateStyle (oldVnode, vnode) {\n\t  var data = vnode.data;\n\t  var oldData = oldVnode.data;\n\t\n\t  if (!data.staticStyle && !data.style &&\n\t      !oldData.staticStyle && !oldData.style) {\n\t    return\n\t  }\n\t\n\t  var cur, name;\n\t  var el = vnode.elm;\n\t  var oldStaticStyle = oldVnode.data.staticStyle;\n\t  var oldStyleBinding = oldVnode.data.style || {};\n\t\n\t  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\t  var oldStyle = oldStaticStyle || oldStyleBinding;\n\t\n\t  var style = normalizeStyleBinding(vnode.data.style) || {};\n\t\n\t  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\t\n\t  var newStyle = getStyle(vnode, true);\n\t\n\t  for (name in oldStyle) {\n\t    if (newStyle[name] == null) {\n\t      setProp(el, name, '');\n\t    }\n\t  }\n\t  for (name in newStyle) {\n\t    cur = newStyle[name];\n\t    if (cur !== oldStyle[name]) {\n\t      // ie9 setting to null has no effect, must use empty string\n\t      setProp(el, name, cur == null ? '' : cur);\n\t    }\n\t  }\n\t}\n\t\n\tvar style = {\n\t  create: updateStyle,\n\t  update: updateStyle\n\t};\n\t\n\t/*  */\n\t\n\t/**\n\t * Add class with compatibility for SVG since classList is not supported on\n\t * SVG elements in IE\n\t */\n\tfunction addClass (el, cls) {\n\t  /* istanbul ignore if */\n\t  if (!cls || !cls.trim()) {\n\t    return\n\t  }\n\t\n\t  /* istanbul ignore else */\n\t  if (el.classList) {\n\t    if (cls.indexOf(' ') > -1) {\n\t      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n\t    } else {\n\t      el.classList.add(cls);\n\t    }\n\t  } else {\n\t    var cur = ' ' + el.getAttribute('class') + ' ';\n\t    if (cur.indexOf(' ' + cls + ' ') < 0) {\n\t      el.setAttribute('class', (cur + cls).trim());\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Remove class with compatibility for SVG since classList is not supported on\n\t * SVG elements in IE\n\t */\n\tfunction removeClass (el, cls) {\n\t  /* istanbul ignore if */\n\t  if (!cls || !cls.trim()) {\n\t    return\n\t  }\n\t\n\t  /* istanbul ignore else */\n\t  if (el.classList) {\n\t    if (cls.indexOf(' ') > -1) {\n\t      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n\t    } else {\n\t      el.classList.remove(cls);\n\t    }\n\t  } else {\n\t    var cur = ' ' + el.getAttribute('class') + ' ';\n\t    var tar = ' ' + cls + ' ';\n\t    while (cur.indexOf(tar) >= 0) {\n\t      cur = cur.replace(tar, ' ');\n\t    }\n\t    el.setAttribute('class', cur.trim());\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar hasTransition = inBrowser && !isIE9;\n\tvar TRANSITION = 'transition';\n\tvar ANIMATION = 'animation';\n\t\n\t// Transition property/event sniffing\n\tvar transitionProp = 'transition';\n\tvar transitionEndEvent = 'transitionend';\n\tvar animationProp = 'animation';\n\tvar animationEndEvent = 'animationend';\n\tif (hasTransition) {\n\t  /* istanbul ignore if */\n\t  if (window.ontransitionend === undefined &&\n\t    window.onwebkittransitionend !== undefined) {\n\t    transitionProp = 'WebkitTransition';\n\t    transitionEndEvent = 'webkitTransitionEnd';\n\t  }\n\t  if (window.onanimationend === undefined &&\n\t    window.onwebkitanimationend !== undefined) {\n\t    animationProp = 'WebkitAnimation';\n\t    animationEndEvent = 'webkitAnimationEnd';\n\t  }\n\t}\n\t\n\tvar raf = (inBrowser && window.requestAnimationFrame) || setTimeout;\n\tfunction nextFrame (fn) {\n\t  raf(function () {\n\t    raf(fn);\n\t  });\n\t}\n\t\n\tfunction addTransitionClass (el, cls) {\n\t  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n\t  addClass(el, cls);\n\t}\n\t\n\tfunction removeTransitionClass (el, cls) {\n\t  if (el._transitionClasses) {\n\t    remove$1(el._transitionClasses, cls);\n\t  }\n\t  removeClass(el, cls);\n\t}\n\t\n\tfunction whenTransitionEnds (\n\t  el,\n\t  expectedType,\n\t  cb\n\t) {\n\t  var ref = getTransitionInfo(el, expectedType);\n\t  var type = ref.type;\n\t  var timeout = ref.timeout;\n\t  var propCount = ref.propCount;\n\t  if (!type) { return cb() }\n\t  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n\t  var ended = 0;\n\t  var end = function () {\n\t    el.removeEventListener(event, onEnd);\n\t    cb();\n\t  };\n\t  var onEnd = function (e) {\n\t    if (e.target === el) {\n\t      if (++ended >= propCount) {\n\t        end();\n\t      }\n\t    }\n\t  };\n\t  setTimeout(function () {\n\t    if (ended < propCount) {\n\t      end();\n\t    }\n\t  }, timeout + 1);\n\t  el.addEventListener(event, onEnd);\n\t}\n\t\n\tvar transformRE = /\\b(transform|all)(,|$)/;\n\t\n\tfunction getTransitionInfo (el, expectedType) {\n\t  var styles = window.getComputedStyle(el);\n\t  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');\n\t  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n\t  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);\n\t  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n\t  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n\t  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\t\n\t  var type;\n\t  var timeout = 0;\n\t  var propCount = 0;\n\t  /* istanbul ignore if */\n\t  if (expectedType === TRANSITION) {\n\t    if (transitionTimeout > 0) {\n\t      type = TRANSITION;\n\t      timeout = transitionTimeout;\n\t      propCount = transitionDurations.length;\n\t    }\n\t  } else if (expectedType === ANIMATION) {\n\t    if (animationTimeout > 0) {\n\t      type = ANIMATION;\n\t      timeout = animationTimeout;\n\t      propCount = animationDurations.length;\n\t    }\n\t  } else {\n\t    timeout = Math.max(transitionTimeout, animationTimeout);\n\t    type = timeout > 0\n\t      ? transitionTimeout > animationTimeout\n\t        ? TRANSITION\n\t        : ANIMATION\n\t      : null;\n\t    propCount = type\n\t      ? type === TRANSITION\n\t        ? transitionDurations.length\n\t        : animationDurations.length\n\t      : 0;\n\t  }\n\t  var hasTransform =\n\t    type === TRANSITION &&\n\t    transformRE.test(styles[transitionProp + 'Property']);\n\t  return {\n\t    type: type,\n\t    timeout: timeout,\n\t    propCount: propCount,\n\t    hasTransform: hasTransform\n\t  }\n\t}\n\t\n\tfunction getTimeout (delays, durations) {\n\t  /* istanbul ignore next */\n\t  while (delays.length < durations.length) {\n\t    delays = delays.concat(delays);\n\t  }\n\t\n\t  return Math.max.apply(null, durations.map(function (d, i) {\n\t    return toMs(d) + toMs(delays[i])\n\t  }))\n\t}\n\t\n\tfunction toMs (s) {\n\t  return Number(s.slice(0, -1)) * 1000\n\t}\n\t\n\t/*  */\n\t\n\tfunction enter (vnode, toggleDisplay) {\n\t  var el = vnode.elm;\n\t\n\t  // call leave callback now\n\t  if (el._leaveCb) {\n\t    el._leaveCb.cancelled = true;\n\t    el._leaveCb();\n\t  }\n\t\n\t  var data = resolveTransition(vnode.data.transition);\n\t  if (!data) {\n\t    return\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (el._enterCb || el.nodeType !== 1) {\n\t    return\n\t  }\n\t\n\t  var css = data.css;\n\t  var type = data.type;\n\t  var enterClass = data.enterClass;\n\t  var enterToClass = data.enterToClass;\n\t  var enterActiveClass = data.enterActiveClass;\n\t  var appearClass = data.appearClass;\n\t  var appearToClass = data.appearToClass;\n\t  var appearActiveClass = data.appearActiveClass;\n\t  var beforeEnter = data.beforeEnter;\n\t  var enter = data.enter;\n\t  var afterEnter = data.afterEnter;\n\t  var enterCancelled = data.enterCancelled;\n\t  var beforeAppear = data.beforeAppear;\n\t  var appear = data.appear;\n\t  var afterAppear = data.afterAppear;\n\t  var appearCancelled = data.appearCancelled;\n\t\n\t  // activeInstance will always be the <transition> component managing this\n\t  // transition. One edge case to check is when the <transition> is placed\n\t  // as the root node of a child component. In that case we need to check\n\t  // <transition>'s parent for appear check.\n\t  var context = activeInstance;\n\t  var transitionNode = activeInstance.$vnode;\n\t  while (transitionNode && transitionNode.parent) {\n\t    transitionNode = transitionNode.parent;\n\t    context = transitionNode.context;\n\t  }\n\t\n\t  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\t\n\t  if (isAppear && !appear && appear !== '') {\n\t    return\n\t  }\n\t\n\t  var startClass = isAppear ? appearClass : enterClass;\n\t  var activeClass = isAppear ? appearActiveClass : enterActiveClass;\n\t  var toClass = isAppear ? appearToClass : enterToClass;\n\t  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;\n\t  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;\n\t  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;\n\t  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;\n\t\n\t  var expectsCSS = css !== false && !isIE9;\n\t  var userWantsControl =\n\t    enterHook &&\n\t    // enterHook may be a bound method which exposes\n\t    // the length of original fn as _length\n\t    (enterHook._length || enterHook.length) > 1;\n\t\n\t  var cb = el._enterCb = once(function () {\n\t    if (expectsCSS) {\n\t      removeTransitionClass(el, toClass);\n\t      removeTransitionClass(el, activeClass);\n\t    }\n\t    if (cb.cancelled) {\n\t      if (expectsCSS) {\n\t        removeTransitionClass(el, startClass);\n\t      }\n\t      enterCancelledHook && enterCancelledHook(el);\n\t    } else {\n\t      afterEnterHook && afterEnterHook(el);\n\t    }\n\t    el._enterCb = null;\n\t  });\n\t\n\t  if (!vnode.data.show) {\n\t    // remove pending leave element on enter by injecting an insert hook\n\t    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n\t      var parent = el.parentNode;\n\t      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\t      if (pendingNode &&\n\t          pendingNode.context === vnode.context &&\n\t          pendingNode.tag === vnode.tag &&\n\t          pendingNode.elm._leaveCb) {\n\t        pendingNode.elm._leaveCb();\n\t      }\n\t      enterHook && enterHook(el, cb);\n\t    }, 'transition-insert');\n\t  }\n\t\n\t  // start enter transition\n\t  beforeEnterHook && beforeEnterHook(el);\n\t  if (expectsCSS) {\n\t    addTransitionClass(el, startClass);\n\t    addTransitionClass(el, activeClass);\n\t    nextFrame(function () {\n\t      addTransitionClass(el, toClass);\n\t      removeTransitionClass(el, startClass);\n\t      if (!cb.cancelled && !userWantsControl) {\n\t        whenTransitionEnds(el, type, cb);\n\t      }\n\t    });\n\t  }\n\t\n\t  if (vnode.data.show) {\n\t    toggleDisplay && toggleDisplay();\n\t    enterHook && enterHook(el, cb);\n\t  }\n\t\n\t  if (!expectsCSS && !userWantsControl) {\n\t    cb();\n\t  }\n\t}\n\t\n\tfunction leave (vnode, rm) {\n\t  var el = vnode.elm;\n\t\n\t  // call enter callback now\n\t  if (el._enterCb) {\n\t    el._enterCb.cancelled = true;\n\t    el._enterCb();\n\t  }\n\t\n\t  var data = resolveTransition(vnode.data.transition);\n\t  if (!data) {\n\t    return rm()\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (el._leaveCb || el.nodeType !== 1) {\n\t    return\n\t  }\n\t\n\t  var css = data.css;\n\t  var type = data.type;\n\t  var leaveClass = data.leaveClass;\n\t  var leaveToClass = data.leaveToClass;\n\t  var leaveActiveClass = data.leaveActiveClass;\n\t  var beforeLeave = data.beforeLeave;\n\t  var leave = data.leave;\n\t  var afterLeave = data.afterLeave;\n\t  var leaveCancelled = data.leaveCancelled;\n\t  var delayLeave = data.delayLeave;\n\t\n\t  var expectsCSS = css !== false && !isIE9;\n\t  var userWantsControl =\n\t    leave &&\n\t    // leave hook may be a bound method which exposes\n\t    // the length of original fn as _length\n\t    (leave._length || leave.length) > 1;\n\t\n\t  var cb = el._leaveCb = once(function () {\n\t    if (el.parentNode && el.parentNode._pending) {\n\t      el.parentNode._pending[vnode.key] = null;\n\t    }\n\t    if (expectsCSS) {\n\t      removeTransitionClass(el, leaveToClass);\n\t      removeTransitionClass(el, leaveActiveClass);\n\t    }\n\t    if (cb.cancelled) {\n\t      if (expectsCSS) {\n\t        removeTransitionClass(el, leaveClass);\n\t      }\n\t      leaveCancelled && leaveCancelled(el);\n\t    } else {\n\t      rm();\n\t      afterLeave && afterLeave(el);\n\t    }\n\t    el._leaveCb = null;\n\t  });\n\t\n\t  if (delayLeave) {\n\t    delayLeave(performLeave);\n\t  } else {\n\t    performLeave();\n\t  }\n\t\n\t  function performLeave () {\n\t    // the delayed leave may have already been cancelled\n\t    if (cb.cancelled) {\n\t      return\n\t    }\n\t    // record leaving element\n\t    if (!vnode.data.show) {\n\t      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n\t    }\n\t    beforeLeave && beforeLeave(el);\n\t    if (expectsCSS) {\n\t      addTransitionClass(el, leaveClass);\n\t      addTransitionClass(el, leaveActiveClass);\n\t      nextFrame(function () {\n\t        addTransitionClass(el, leaveToClass);\n\t        removeTransitionClass(el, leaveClass);\n\t        if (!cb.cancelled && !userWantsControl) {\n\t          whenTransitionEnds(el, type, cb);\n\t        }\n\t      });\n\t    }\n\t    leave && leave(el, cb);\n\t    if (!expectsCSS && !userWantsControl) {\n\t      cb();\n\t    }\n\t  }\n\t}\n\t\n\tfunction resolveTransition (def$$1) {\n\t  if (!def$$1) {\n\t    return\n\t  }\n\t  /* istanbul ignore else */\n\t  if (typeof def$$1 === 'object') {\n\t    var res = {};\n\t    if (def$$1.css !== false) {\n\t      extend(res, autoCssTransition(def$$1.name || 'v'));\n\t    }\n\t    extend(res, def$$1);\n\t    return res\n\t  } else if (typeof def$$1 === 'string') {\n\t    return autoCssTransition(def$$1)\n\t  }\n\t}\n\t\n\tvar autoCssTransition = cached(function (name) {\n\t  return {\n\t    enterClass: (name + \"-enter\"),\n\t    leaveClass: (name + \"-leave\"),\n\t    appearClass: (name + \"-enter\"),\n\t    enterToClass: (name + \"-enter-to\"),\n\t    leaveToClass: (name + \"-leave-to\"),\n\t    appearToClass: (name + \"-enter-to\"),\n\t    enterActiveClass: (name + \"-enter-active\"),\n\t    leaveActiveClass: (name + \"-leave-active\"),\n\t    appearActiveClass: (name + \"-enter-active\")\n\t  }\n\t});\n\t\n\tfunction once (fn) {\n\t  var called = false;\n\t  return function () {\n\t    if (!called) {\n\t      called = true;\n\t      fn();\n\t    }\n\t  }\n\t}\n\t\n\tfunction _enter (_, vnode) {\n\t  if (!vnode.data.show) {\n\t    enter(vnode);\n\t  }\n\t}\n\t\n\tvar transition = inBrowser ? {\n\t  create: _enter,\n\t  activate: _enter,\n\t  remove: function remove (vnode, rm) {\n\t    /* istanbul ignore else */\n\t    if (!vnode.data.show) {\n\t      leave(vnode, rm);\n\t    } else {\n\t      rm();\n\t    }\n\t  }\n\t} : {};\n\t\n\tvar platformModules = [\n\t  attrs,\n\t  klass,\n\t  events,\n\t  domProps,\n\t  style,\n\t  transition\n\t];\n\t\n\t/*  */\n\t\n\t// the directive module should be applied last, after all\n\t// built-in modules have been applied.\n\tvar modules = platformModules.concat(baseModules);\n\t\n\tvar patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\t\n\t/**\n\t * Not type checking this file because flow doesn't like attaching\n\t * properties to Elements.\n\t */\n\t\n\tvar modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;\n\t\n\t/* istanbul ignore if */\n\tif (isIE9) {\n\t  // http://www.matts411.com/post/internet-explorer-9-oninput/\n\t  document.addEventListener('selectionchange', function () {\n\t    var el = document.activeElement;\n\t    if (el && el.vmodel) {\n\t      trigger(el, 'input');\n\t    }\n\t  });\n\t}\n\t\n\tvar model = {\n\t  inserted: function inserted (el, binding, vnode) {\n\t    if (false) {\n\t      if (!modelableTagRE.test(vnode.tag)) {\n\t        warn(\n\t          \"v-model is not supported on element type: <\" + (vnode.tag) + \">. \" +\n\t          'If you are working with contenteditable, it\\'s recommended to ' +\n\t          'wrap a library dedicated for that purpose inside a custom component.',\n\t          vnode.context\n\t        );\n\t      }\n\t    }\n\t    if (vnode.tag === 'select') {\n\t      var cb = function () {\n\t        setSelected(el, binding, vnode.context);\n\t      };\n\t      cb();\n\t      /* istanbul ignore if */\n\t      if (isIE || isEdge) {\n\t        setTimeout(cb, 0);\n\t      }\n\t    } else if (vnode.tag === 'textarea' || el.type === 'text') {\n\t      el._vModifiers = binding.modifiers;\n\t      if (!binding.modifiers.lazy) {\n\t        if (!isAndroid) {\n\t          el.addEventListener('compositionstart', onCompositionStart);\n\t          el.addEventListener('compositionend', onCompositionEnd);\n\t        }\n\t        /* istanbul ignore if */\n\t        if (isIE9) {\n\t          el.vmodel = true;\n\t        }\n\t      }\n\t    }\n\t  },\n\t  componentUpdated: function componentUpdated (el, binding, vnode) {\n\t    if (vnode.tag === 'select') {\n\t      setSelected(el, binding, vnode.context);\n\t      // in case the options rendered by v-for have changed,\n\t      // it's possible that the value is out-of-sync with the rendered options.\n\t      // detect such cases and filter out values that no longer has a matching\n\t      // option in the DOM.\n\t      var needReset = el.multiple\n\t        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n\t        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n\t      if (needReset) {\n\t        trigger(el, 'change');\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tfunction setSelected (el, binding, vm) {\n\t  var value = binding.value;\n\t  var isMultiple = el.multiple;\n\t  if (isMultiple && !Array.isArray(value)) {\n\t    (\"production\") !== 'production' && warn(\n\t      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n\t      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n\t      vm\n\t    );\n\t    return\n\t  }\n\t  var selected, option;\n\t  for (var i = 0, l = el.options.length; i < l; i++) {\n\t    option = el.options[i];\n\t    if (isMultiple) {\n\t      selected = looseIndexOf(value, getValue(option)) > -1;\n\t      if (option.selected !== selected) {\n\t        option.selected = selected;\n\t      }\n\t    } else {\n\t      if (looseEqual(getValue(option), value)) {\n\t        if (el.selectedIndex !== i) {\n\t          el.selectedIndex = i;\n\t        }\n\t        return\n\t      }\n\t    }\n\t  }\n\t  if (!isMultiple) {\n\t    el.selectedIndex = -1;\n\t  }\n\t}\n\t\n\tfunction hasNoMatchingOption (value, options) {\n\t  for (var i = 0, l = options.length; i < l; i++) {\n\t    if (looseEqual(getValue(options[i]), value)) {\n\t      return false\n\t    }\n\t  }\n\t  return true\n\t}\n\t\n\tfunction getValue (option) {\n\t  return '_value' in option\n\t    ? option._value\n\t    : option.value\n\t}\n\t\n\tfunction onCompositionStart (e) {\n\t  e.target.composing = true;\n\t}\n\t\n\tfunction onCompositionEnd (e) {\n\t  e.target.composing = false;\n\t  trigger(e.target, 'input');\n\t}\n\t\n\tfunction trigger (el, type) {\n\t  var e = document.createEvent('HTMLEvents');\n\t  e.initEvent(type, true, true);\n\t  el.dispatchEvent(e);\n\t}\n\t\n\t/*  */\n\t\n\t// recursively search for possible transition defined inside the component root\n\tfunction locateNode (vnode) {\n\t  return vnode.child && (!vnode.data || !vnode.data.transition)\n\t    ? locateNode(vnode.child._vnode)\n\t    : vnode\n\t}\n\t\n\tvar show = {\n\t  bind: function bind (el, ref, vnode) {\n\t    var value = ref.value;\n\t\n\t    vnode = locateNode(vnode);\n\t    var transition = vnode.data && vnode.data.transition;\n\t    var originalDisplay = el.__vOriginalDisplay =\n\t      el.style.display === 'none' ? '' : el.style.display;\n\t    if (value && transition && !isIE9) {\n\t      vnode.data.show = true;\n\t      enter(vnode, function () {\n\t        el.style.display = originalDisplay;\n\t      });\n\t    } else {\n\t      el.style.display = value ? originalDisplay : 'none';\n\t    }\n\t  },\n\t\n\t  update: function update (el, ref, vnode) {\n\t    var value = ref.value;\n\t    var oldValue = ref.oldValue;\n\t\n\t    /* istanbul ignore if */\n\t    if (value === oldValue) { return }\n\t    vnode = locateNode(vnode);\n\t    var transition = vnode.data && vnode.data.transition;\n\t    if (transition && !isIE9) {\n\t      vnode.data.show = true;\n\t      if (value) {\n\t        enter(vnode, function () {\n\t          el.style.display = el.__vOriginalDisplay;\n\t        });\n\t      } else {\n\t        leave(vnode, function () {\n\t          el.style.display = 'none';\n\t        });\n\t      }\n\t    } else {\n\t      el.style.display = value ? el.__vOriginalDisplay : 'none';\n\t    }\n\t  },\n\t\n\t  unbind: function unbind (\n\t    el,\n\t    binding,\n\t    vnode,\n\t    oldVnode,\n\t    isDestroy\n\t  ) {\n\t    if (!isDestroy) {\n\t      el.style.display = el.__vOriginalDisplay;\n\t    }\n\t  }\n\t};\n\t\n\tvar platformDirectives = {\n\t  model: model,\n\t  show: show\n\t};\n\t\n\t/*  */\n\t\n\t// Provides transition support for a single element/component.\n\t// supports transition mode (out-in / in-out)\n\t\n\tvar transitionProps = {\n\t  name: String,\n\t  appear: Boolean,\n\t  css: Boolean,\n\t  mode: String,\n\t  type: String,\n\t  enterClass: String,\n\t  leaveClass: String,\n\t  enterToClass: String,\n\t  leaveToClass: String,\n\t  enterActiveClass: String,\n\t  leaveActiveClass: String,\n\t  appearClass: String,\n\t  appearActiveClass: String,\n\t  appearToClass: String\n\t};\n\t\n\t// in case the child is also an abstract component, e.g. <keep-alive>\n\t// we want to recursively retrieve the real component to be rendered\n\tfunction getRealChild (vnode) {\n\t  var compOptions = vnode && vnode.componentOptions;\n\t  if (compOptions && compOptions.Ctor.options.abstract) {\n\t    return getRealChild(getFirstComponentChild(compOptions.children))\n\t  } else {\n\t    return vnode\n\t  }\n\t}\n\t\n\tfunction extractTransitionData (comp) {\n\t  var data = {};\n\t  var options = comp.$options;\n\t  // props\n\t  for (var key in options.propsData) {\n\t    data[key] = comp[key];\n\t  }\n\t  // events.\n\t  // extract listeners and pass them directly to the transition methods\n\t  var listeners = options._parentListeners;\n\t  for (var key$1 in listeners) {\n\t    data[camelize(key$1)] = listeners[key$1].fn;\n\t  }\n\t  return data\n\t}\n\t\n\tfunction placeholder (h, rawChild) {\n\t  return /\\d-keep-alive$/.test(rawChild.tag)\n\t    ? h('keep-alive')\n\t    : null\n\t}\n\t\n\tfunction hasParentTransition (vnode) {\n\t  while ((vnode = vnode.parent)) {\n\t    if (vnode.data.transition) {\n\t      return true\n\t    }\n\t  }\n\t}\n\t\n\tfunction isSameChild (child, oldChild) {\n\t  return oldChild.key === child.key && oldChild.tag === child.tag\n\t}\n\t\n\tvar Transition = {\n\t  name: 'transition',\n\t  props: transitionProps,\n\t  abstract: true,\n\t  render: function render (h) {\n\t    var this$1 = this;\n\t\n\t    var children = this.$slots.default;\n\t    if (!children) {\n\t      return\n\t    }\n\t\n\t    // filter out text nodes (possible whitespaces)\n\t    children = children.filter(function (c) { return c.tag; });\n\t    /* istanbul ignore if */\n\t    if (!children.length) {\n\t      return\n\t    }\n\t\n\t    // warn multiple elements\n\t    if (false) {\n\t      warn(\n\t        '<transition> can only be used on a single element. Use ' +\n\t        '<transition-group> for lists.',\n\t        this.$parent\n\t      );\n\t    }\n\t\n\t    var mode = this.mode;\n\t\n\t    // warn invalid mode\n\t    if (false) {\n\t      warn(\n\t        'invalid <transition> mode: ' + mode,\n\t        this.$parent\n\t      );\n\t    }\n\t\n\t    var rawChild = children[0];\n\t\n\t    // if this is a component root node and the component's\n\t    // parent container node also has transition, skip.\n\t    if (hasParentTransition(this.$vnode)) {\n\t      return rawChild\n\t    }\n\t\n\t    // apply transition data to child\n\t    // use getRealChild() to ignore abstract components e.g. keep-alive\n\t    var child = getRealChild(rawChild);\n\t    /* istanbul ignore if */\n\t    if (!child) {\n\t      return rawChild\n\t    }\n\t\n\t    if (this._leaving) {\n\t      return placeholder(h, rawChild)\n\t    }\n\t\n\t    var key = child.key = child.key == null || child.isStatic\n\t      ? (\"__v\" + (child.tag + this._uid) + \"__\")\n\t      : child.key;\n\t    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n\t    var oldRawChild = this._vnode;\n\t    var oldChild = getRealChild(oldRawChild);\n\t\n\t    // mark v-show\n\t    // so that the transition module can hand over the control to the directive\n\t    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n\t      child.data.show = true;\n\t    }\n\t\n\t    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n\t      // replace old child transition data with fresh one\n\t      // important for dynamic transitions!\n\t      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n\t      // handle transition mode\n\t      if (mode === 'out-in') {\n\t        // return placeholder node and queue update when leave finishes\n\t        this._leaving = true;\n\t        mergeVNodeHook(oldData, 'afterLeave', function () {\n\t          this$1._leaving = false;\n\t          this$1.$forceUpdate();\n\t        }, key);\n\t        return placeholder(h, rawChild)\n\t      } else if (mode === 'in-out') {\n\t        var delayedLeave;\n\t        var performLeave = function () { delayedLeave(); };\n\t        mergeVNodeHook(data, 'afterEnter', performLeave, key);\n\t        mergeVNodeHook(data, 'enterCancelled', performLeave, key);\n\t        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n\t          delayedLeave = leave;\n\t        }, key);\n\t      }\n\t    }\n\t\n\t    return rawChild\n\t  }\n\t};\n\t\n\t/*  */\n\t\n\t// Provides transition support for list items.\n\t// supports move transitions using the FLIP technique.\n\t\n\t// Because the vdom's children update algorithm is \"unstable\" - i.e.\n\t// it doesn't guarantee the relative positioning of removed elements,\n\t// we force transition-group to update its children into two passes:\n\t// in the first pass, we remove all nodes that need to be removed,\n\t// triggering their leaving transition; in the second pass, we insert/move\n\t// into the final disired state. This way in the second pass removed\n\t// nodes will remain where they should be.\n\t\n\tvar props = extend({\n\t  tag: String,\n\t  moveClass: String\n\t}, transitionProps);\n\t\n\tdelete props.mode;\n\t\n\tvar TransitionGroup = {\n\t  props: props,\n\t\n\t  render: function render (h) {\n\t    var tag = this.tag || this.$vnode.data.tag || 'span';\n\t    var map = Object.create(null);\n\t    var prevChildren = this.prevChildren = this.children;\n\t    var rawChildren = this.$slots.default || [];\n\t    var children = this.children = [];\n\t    var transitionData = extractTransitionData(this);\n\t\n\t    for (var i = 0; i < rawChildren.length; i++) {\n\t      var c = rawChildren[i];\n\t      if (c.tag) {\n\t        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n\t          children.push(c);\n\t          map[c.key] = c\n\t          ;(c.data || (c.data = {})).transition = transitionData;\n\t        } else if (false) {\n\t          var opts = c.componentOptions;\n\t          var name = opts\n\t            ? (opts.Ctor.options.name || opts.tag)\n\t            : c.tag;\n\t          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n\t        }\n\t      }\n\t    }\n\t\n\t    if (prevChildren) {\n\t      var kept = [];\n\t      var removed = [];\n\t      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n\t        var c$1 = prevChildren[i$1];\n\t        c$1.data.transition = transitionData;\n\t        c$1.data.pos = c$1.elm.getBoundingClientRect();\n\t        if (map[c$1.key]) {\n\t          kept.push(c$1);\n\t        } else {\n\t          removed.push(c$1);\n\t        }\n\t      }\n\t      this.kept = h(tag, null, kept);\n\t      this.removed = removed;\n\t    }\n\t\n\t    return h(tag, null, children)\n\t  },\n\t\n\t  beforeUpdate: function beforeUpdate () {\n\t    // force removing pass\n\t    this.__patch__(\n\t      this._vnode,\n\t      this.kept,\n\t      false, // hydrating\n\t      true // removeOnly (!important, avoids unnecessary moves)\n\t    );\n\t    this._vnode = this.kept;\n\t  },\n\t\n\t  updated: function updated () {\n\t    var children = this.prevChildren;\n\t    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n\t    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n\t      return\n\t    }\n\t\n\t    // we divide the work into three loops to avoid mixing DOM reads and writes\n\t    // in each iteration - which helps prevent layout thrashing.\n\t    children.forEach(callPendingCbs);\n\t    children.forEach(recordPosition);\n\t    children.forEach(applyTranslation);\n\t\n\t    // force reflow to put everything in position\n\t    var f = document.body.offsetHeight; // eslint-disable-line\n\t\n\t    children.forEach(function (c) {\n\t      if (c.data.moved) {\n\t        var el = c.elm;\n\t        var s = el.style;\n\t        addTransitionClass(el, moveClass);\n\t        s.transform = s.WebkitTransform = s.transitionDuration = '';\n\t        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n\t          if (!e || /transform$/.test(e.propertyName)) {\n\t            el.removeEventListener(transitionEndEvent, cb);\n\t            el._moveCb = null;\n\t            removeTransitionClass(el, moveClass);\n\t          }\n\t        });\n\t      }\n\t    });\n\t  },\n\t\n\t  methods: {\n\t    hasMove: function hasMove (el, moveClass) {\n\t      /* istanbul ignore if */\n\t      if (!hasTransition) {\n\t        return false\n\t      }\n\t      if (this._hasMove != null) {\n\t        return this._hasMove\n\t      }\n\t      addTransitionClass(el, moveClass);\n\t      var info = getTransitionInfo(el);\n\t      removeTransitionClass(el, moveClass);\n\t      return (this._hasMove = info.hasTransform)\n\t    }\n\t  }\n\t};\n\t\n\tfunction callPendingCbs (c) {\n\t  /* istanbul ignore if */\n\t  if (c.elm._moveCb) {\n\t    c.elm._moveCb();\n\t  }\n\t  /* istanbul ignore if */\n\t  if (c.elm._enterCb) {\n\t    c.elm._enterCb();\n\t  }\n\t}\n\t\n\tfunction recordPosition (c) {\n\t  c.data.newPos = c.elm.getBoundingClientRect();\n\t}\n\t\n\tfunction applyTranslation (c) {\n\t  var oldPos = c.data.pos;\n\t  var newPos = c.data.newPos;\n\t  var dx = oldPos.left - newPos.left;\n\t  var dy = oldPos.top - newPos.top;\n\t  if (dx || dy) {\n\t    c.data.moved = true;\n\t    var s = c.elm.style;\n\t    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n\t    s.transitionDuration = '0s';\n\t  }\n\t}\n\t\n\tvar platformComponents = {\n\t  Transition: Transition,\n\t  TransitionGroup: TransitionGroup\n\t};\n\t\n\t/*  */\n\t\n\t// install platform specific utils\n\tVue$2.config.isUnknownElement = isUnknownElement;\n\tVue$2.config.isReservedTag = isReservedTag;\n\tVue$2.config.getTagNamespace = getTagNamespace;\n\tVue$2.config.mustUseProp = mustUseProp;\n\t\n\t// install platform runtime directives & components\n\textend(Vue$2.options.directives, platformDirectives);\n\textend(Vue$2.options.components, platformComponents);\n\t\n\t// install platform patch function\n\tVue$2.prototype.__patch__ = inBrowser ? patch$1 : noop;\n\t\n\t// wrap mount\n\tVue$2.prototype.$mount = function (\n\t  el,\n\t  hydrating\n\t) {\n\t  el = el && inBrowser ? query(el) : undefined;\n\t  return this._mount(el, hydrating)\n\t};\n\t\n\tif (false) {\n\t  console[console.info ? 'info' : 'log'](\n\t    \"You are running Vue in development mode.\\n\" +\n\t    \"Make sure to turn on production mode when deploying for production.\\n\" +\n\t    \"See more tips at https://vuejs.org/guide/deployment.html\"\n\t  );\n\t}\n\t\n\t// devtools global hook\n\t/* istanbul ignore next */\n\tsetTimeout(function () {\n\t  if (config.devtools) {\n\t    if (devtools) {\n\t      devtools.emit('init', Vue$2);\n\t    } else if (\n\t      false\n\t    ) {\n\t      console[console.info ? 'info' : 'log'](\n\t        'Download the Vue Devtools extension for a better development experience:\\n' +\n\t        'https://github.com/vuejs/vue-devtools'\n\t      );\n\t    }\n\t  }\n\t}, 0);\n\t\n\tmodule.exports = Vue$2;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * vuex v2.1.1\n\t * (c) 2016 Evan You\n\t * @license MIT\n\t */\n\t(function (global, factory) {\n\t   true ? module.exports = factory() :\n\t  typeof define === 'function' && define.amd ? define(factory) :\n\t  (global.Vuex = factory());\n\t}(this, (function () { 'use strict';\n\t\n\tvar devtoolHook =\n\t  typeof window !== 'undefined' &&\n\t  window.__VUE_DEVTOOLS_GLOBAL_HOOK__\n\t\n\tfunction devtoolPlugin (store) {\n\t  if (!devtoolHook) { return }\n\t\n\t  store._devtoolHook = devtoolHook\n\t\n\t  devtoolHook.emit('vuex:init', store)\n\t\n\t  devtoolHook.on('vuex:travel-to-state', function (targetState) {\n\t    store.replaceState(targetState)\n\t  })\n\t\n\t  store.subscribe(function (mutation, state) {\n\t    devtoolHook.emit('vuex:mutation', mutation, state)\n\t  })\n\t}\n\t\n\tfunction applyMixin (Vue) {\n\t  var version = Number(Vue.version.split('.')[0])\n\t\n\t  if (version >= 2) {\n\t    var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1\n\t    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit })\n\t  } else {\n\t    // override init and inject vuex init procedure\n\t    // for 1.x backwards compatibility.\n\t    var _init = Vue.prototype._init\n\t    Vue.prototype._init = function (options) {\n\t      if ( options === void 0 ) options = {};\n\t\n\t      options.init = options.init\n\t        ? [vuexInit].concat(options.init)\n\t        : vuexInit\n\t      _init.call(this, options)\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Vuex init hook, injected into each instances init hooks list.\n\t   */\n\t\n\t  function vuexInit () {\n\t    var options = this.$options\n\t    // store injection\n\t    if (options.store) {\n\t      this.$store = options.store\n\t    } else if (options.parent && options.parent.$store) {\n\t      this.$store = options.parent.$store\n\t    }\n\t  }\n\t}\n\t\n\tvar mapState = normalizeNamespace(function (namespace, states) {\n\t  var res = {}\n\t  normalizeMap(states).forEach(function (ref) {\n\t    var key = ref.key;\n\t    var val = ref.val;\n\t\n\t    res[key] = function mappedState () {\n\t      var state = this.$store.state\n\t      var getters = this.$store.getters\n\t      if (namespace) {\n\t        var module = this.$store._modulesNamespaceMap[namespace]\n\t        if (!module) {\n\t          warnNamespace('mapState', namespace)\n\t          return\n\t        }\n\t        state = module.state\n\t        getters = module.context.getters\n\t      }\n\t      return typeof val === 'function'\n\t        ? val.call(this, state, getters)\n\t        : state[val]\n\t    }\n\t  })\n\t  return res\n\t})\n\t\n\tvar mapMutations = normalizeNamespace(function (namespace, mutations) {\n\t  var res = {}\n\t  normalizeMap(mutations).forEach(function (ref) {\n\t    var key = ref.key;\n\t    var val = ref.val;\n\t\n\t    val = namespace + val\n\t    res[key] = function mappedMutation () {\n\t      var args = [], len = arguments.length;\n\t      while ( len-- ) args[ len ] = arguments[ len ];\n\t\n\t      return this.$store.commit.apply(this.$store, [val].concat(args))\n\t    }\n\t  })\n\t  return res\n\t})\n\t\n\tvar mapGetters = normalizeNamespace(function (namespace, getters) {\n\t  var res = {}\n\t  normalizeMap(getters).forEach(function (ref) {\n\t    var key = ref.key;\n\t    var val = ref.val;\n\t\n\t    val = namespace + val\n\t    res[key] = function mappedGetter () {\n\t      if (!(val in this.$store.getters)) {\n\t        console.error((\"[vuex] unknown getter: \" + val))\n\t      }\n\t      return this.$store.getters[val]\n\t    }\n\t  })\n\t  return res\n\t})\n\t\n\tvar mapActions = normalizeNamespace(function (namespace, actions) {\n\t  var res = {}\n\t  normalizeMap(actions).forEach(function (ref) {\n\t    var key = ref.key;\n\t    var val = ref.val;\n\t\n\t    val = namespace + val\n\t    res[key] = function mappedAction () {\n\t      var args = [], len = arguments.length;\n\t      while ( len-- ) args[ len ] = arguments[ len ];\n\t\n\t      return this.$store.dispatch.apply(this.$store, [val].concat(args))\n\t    }\n\t  })\n\t  return res\n\t})\n\t\n\tfunction normalizeMap (map) {\n\t  return Array.isArray(map)\n\t    ? map.map(function (key) { return ({ key: key, val: key }); })\n\t    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })\n\t}\n\t\n\tfunction normalizeNamespace (fn) {\n\t  return function (namespace, map) {\n\t    if (typeof namespace !== 'string') {\n\t      map = namespace\n\t      namespace = ''\n\t    } else if (namespace.charAt(namespace.length - 1) !== '/') {\n\t      namespace += '/'\n\t    }\n\t    return fn(namespace, map)\n\t  }\n\t}\n\t\n\tfunction warnNamespace (helper, namespace) {\n\t  console.error((\"[vuex] module namespace not found in \" + helper + \"(): \" + namespace))\n\t}\n\t\n\t/**\n\t * forEach for object\n\t */\n\tfunction forEachValue (obj, fn) {\n\t  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); })\n\t}\n\t\n\tfunction isObject (obj) {\n\t  return obj !== null && typeof obj === 'object'\n\t}\n\t\n\tfunction isPromise (val) {\n\t  return val && typeof val.then === 'function'\n\t}\n\t\n\tfunction assert (condition, msg) {\n\t  if (!condition) { throw new Error((\"[vuex] \" + msg)) }\n\t}\n\t\n\tvar Module = function Module (rawModule, runtime) {\n\t  this.runtime = runtime\n\t  this._children = Object.create(null)\n\t  this._rawModule = rawModule\n\t};\n\t\n\tvar prototypeAccessors$1 = { state: {},namespaced: {} };\n\t\n\tprototypeAccessors$1.state.get = function () {\n\t  return this._rawModule.state || {}\n\t};\n\t\n\tprototypeAccessors$1.namespaced.get = function () {\n\t  return !!this._rawModule.namespaced\n\t};\n\t\n\tModule.prototype.addChild = function addChild (key, module) {\n\t  this._children[key] = module\n\t};\n\t\n\tModule.prototype.removeChild = function removeChild (key) {\n\t  delete this._children[key]\n\t};\n\t\n\tModule.prototype.getChild = function getChild (key) {\n\t  return this._children[key]\n\t};\n\t\n\tModule.prototype.update = function update (rawModule) {\n\t  this._rawModule.namespaced = rawModule.namespaced\n\t  if (rawModule.actions) {\n\t    this._rawModule.actions = rawModule.actions\n\t  }\n\t  if (rawModule.mutations) {\n\t    this._rawModule.mutations = rawModule.mutations\n\t  }\n\t  if (rawModule.getters) {\n\t    this._rawModule.getters = rawModule.getters\n\t  }\n\t};\n\t\n\tModule.prototype.forEachChild = function forEachChild (fn) {\n\t  forEachValue(this._children, fn)\n\t};\n\t\n\tModule.prototype.forEachGetter = function forEachGetter (fn) {\n\t  if (this._rawModule.getters) {\n\t    forEachValue(this._rawModule.getters, fn)\n\t  }\n\t};\n\t\n\tModule.prototype.forEachAction = function forEachAction (fn) {\n\t  if (this._rawModule.actions) {\n\t    forEachValue(this._rawModule.actions, fn)\n\t  }\n\t};\n\t\n\tModule.prototype.forEachMutation = function forEachMutation (fn) {\n\t  if (this._rawModule.mutations) {\n\t    forEachValue(this._rawModule.mutations, fn)\n\t  }\n\t};\n\t\n\tObject.defineProperties( Module.prototype, prototypeAccessors$1 );\n\t\n\tvar ModuleCollection = function ModuleCollection (rawRootModule) {\n\t  var this$1 = this;\n\t\n\t  // register root module (Vuex.Store options)\n\t  this.root = new Module(rawRootModule, false)\n\t\n\t  // register all nested modules\n\t  if (rawRootModule.modules) {\n\t    forEachValue(rawRootModule.modules, function (rawModule, key) {\n\t      this$1.register([key], rawModule, false)\n\t    })\n\t  }\n\t};\n\t\n\tModuleCollection.prototype.get = function get (path) {\n\t  return path.reduce(function (module, key) {\n\t    return module.getChild(key)\n\t  }, this.root)\n\t};\n\t\n\tModuleCollection.prototype.getNamespace = function getNamespace (path) {\n\t  var module = this.root\n\t  return path.reduce(function (namespace, key) {\n\t    module = module.getChild(key)\n\t    return namespace + (module.namespaced ? key + '/' : '')\n\t  }, '')\n\t};\n\t\n\tModuleCollection.prototype.update = function update$1 (rawRootModule) {\n\t  update(this.root, rawRootModule)\n\t};\n\t\n\tModuleCollection.prototype.register = function register (path, rawModule, runtime) {\n\t    var this$1 = this;\n\t    if ( runtime === void 0 ) runtime = true;\n\t\n\t  var parent = this.get(path.slice(0, -1))\n\t  var newModule = new Module(rawModule, runtime)\n\t  parent.addChild(path[path.length - 1], newModule)\n\t\n\t  // register nested modules\n\t  if (rawModule.modules) {\n\t    forEachValue(rawModule.modules, function (rawChildModule, key) {\n\t      this$1.register(path.concat(key), rawChildModule, runtime)\n\t    })\n\t  }\n\t};\n\t\n\tModuleCollection.prototype.unregister = function unregister (path) {\n\t  var parent = this.get(path.slice(0, -1))\n\t  var key = path[path.length - 1]\n\t  if (!parent.getChild(key).runtime) { return }\n\t\n\t  parent.removeChild(key)\n\t};\n\t\n\tfunction update (targetModule, newModule) {\n\t  // update target module\n\t  targetModule.update(newModule)\n\t\n\t  // update nested modules\n\t  if (newModule.modules) {\n\t    for (var key in newModule.modules) {\n\t      if (!targetModule.getChild(key)) {\n\t        console.warn(\n\t          \"[vuex] trying to add a new module '\" + key + \"' on hot reloading, \" +\n\t          'manual reload is needed'\n\t        )\n\t        return\n\t      }\n\t      update(targetModule.getChild(key), newModule.modules[key])\n\t    }\n\t  }\n\t}\n\t\n\tvar Vue // bind on install\n\t\n\tvar Store = function Store (options) {\n\t  var this$1 = this;\n\t  if ( options === void 0 ) options = {};\n\t\n\t  assert(Vue, \"must call Vue.use(Vuex) before creating a store instance.\")\n\t  assert(typeof Promise !== 'undefined', \"vuex requires a Promise polyfill in this browser.\")\n\t\n\t  var state = options.state; if ( state === void 0 ) state = {};\n\t  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];\n\t  var strict = options.strict; if ( strict === void 0 ) strict = false;\n\t\n\t  // store internal state\n\t  this._committing = false\n\t  this._actions = Object.create(null)\n\t  this._mutations = Object.create(null)\n\t  this._wrappedGetters = Object.create(null)\n\t  this._modules = new ModuleCollection(options)\n\t  this._modulesNamespaceMap = Object.create(null)\n\t  this._subscribers = []\n\t  this._watcherVM = new Vue()\n\t\n\t  // bind commit and dispatch to self\n\t  var store = this\n\t  var ref = this;\n\t  var dispatch = ref.dispatch;\n\t  var commit = ref.commit;\n\t    this.dispatch = function boundDispatch (type, payload) {\n\t    return dispatch.call(store, type, payload)\n\t  }\n\t  this.commit = function boundCommit (type, payload, options) {\n\t    return commit.call(store, type, payload, options)\n\t    }\n\t\n\t    // strict mode\n\t  this.strict = strict\n\t\n\t  // init root module.\n\t  // this also recursively registers all sub-modules\n\t  // and collects all module getters inside this._wrappedGetters\n\t  installModule(this, state, [], this._modules.root)\n\t\n\t  // initialize the store vm, which is responsible for the reactivity\n\t  // (also registers _wrappedGetters as computed properties)\n\t  resetStoreVM(this, state)\n\t\n\t  // apply plugins\n\t  plugins.concat(devtoolPlugin).forEach(function (plugin) { return plugin(this$1); })\n\t};\n\t\n\tvar prototypeAccessors = { state: {} };\n\t\n\tprototypeAccessors.state.get = function () {\n\t  return this._vm.$data.state\n\t};\n\t\n\tprototypeAccessors.state.set = function (v) {\n\t  assert(false, \"Use store.replaceState() to explicit replace store state.\")\n\t};\n\t\n\tStore.prototype.commit = function commit (_type, _payload, _options) {\n\t    var this$1 = this;\n\t\n\t  // check object-style commit\n\t  var ref = unifyObjectStyle(_type, _payload, _options);\n\t    var type = ref.type;\n\t    var payload = ref.payload;\n\t    var options = ref.options;\n\t\n\t  var mutation = { type: type, payload: payload }\n\t  var entry = this._mutations[type]\n\t  if (!entry) {\n\t    console.error((\"[vuex] unknown mutation type: \" + type))\n\t    return\n\t  }\n\t  this._withCommit(function () {\n\t    entry.forEach(function commitIterator (handler) {\n\t      handler(payload)\n\t    })\n\t  })\n\t  this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); })\n\t\n\t  if (options && options.silent) {\n\t    console.warn(\n\t      \"[vuex] mutation type: \" + type + \". Silent option has been removed. \" +\n\t      'Use the filter functionality in the vue-devtools'\n\t    )\n\t  }\n\t};\n\t\n\tStore.prototype.dispatch = function dispatch (_type, _payload) {\n\t  // check object-style dispatch\n\t  var ref = unifyObjectStyle(_type, _payload);\n\t    var type = ref.type;\n\t    var payload = ref.payload;\n\t\n\t  var entry = this._actions[type]\n\t  if (!entry) {\n\t    console.error((\"[vuex] unknown action type: \" + type))\n\t    return\n\t  }\n\t  return entry.length > 1\n\t    ? Promise.all(entry.map(function (handler) { return handler(payload); }))\n\t    : entry[0](payload)\n\t};\n\t\n\tStore.prototype.subscribe = function subscribe (fn) {\n\t  var subs = this._subscribers\n\t  if (subs.indexOf(fn) < 0) {\n\t    subs.push(fn)\n\t  }\n\t  return function () {\n\t    var i = subs.indexOf(fn)\n\t    if (i > -1) {\n\t      subs.splice(i, 1)\n\t    }\n\t  }\n\t};\n\t\n\tStore.prototype.watch = function watch (getter, cb, options) {\n\t    var this$1 = this;\n\t\n\t  assert(typeof getter === 'function', \"store.watch only accepts a function.\")\n\t  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)\n\t};\n\t\n\tStore.prototype.replaceState = function replaceState (state) {\n\t    var this$1 = this;\n\t\n\t  this._withCommit(function () {\n\t    this$1._vm.state = state\n\t  })\n\t};\n\t\n\tStore.prototype.registerModule = function registerModule (path, rawModule) {\n\t  if (typeof path === 'string') { path = [path] }\n\t  assert(Array.isArray(path), \"module path must be a string or an Array.\")\n\t  this._modules.register(path, rawModule)\n\t  installModule(this, this.state, path, this._modules.get(path))\n\t  // reset store to update getters...\n\t  resetStoreVM(this, this.state)\n\t};\n\t\n\tStore.prototype.unregisterModule = function unregisterModule (path) {\n\t    var this$1 = this;\n\t\n\t  if (typeof path === 'string') { path = [path] }\n\t  assert(Array.isArray(path), \"module path must be a string or an Array.\")\n\t    this._modules.unregister(path)\n\t  this._withCommit(function () {\n\t    var parentState = getNestedState(this$1.state, path.slice(0, -1))\n\t    Vue.delete(parentState, path[path.length - 1])\n\t  })\n\t  resetStore(this)\n\t};\n\t\n\tStore.prototype.hotUpdate = function hotUpdate (newOptions) {\n\t  this._modules.update(newOptions)\n\t  resetStore(this)\n\t};\n\t\n\tStore.prototype._withCommit = function _withCommit (fn) {\n\t  var committing = this._committing\n\t  this._committing = true\n\t  fn()\n\t  this._committing = committing\n\t};\n\t\n\tObject.defineProperties( Store.prototype, prototypeAccessors );\n\t\n\tfunction resetStore (store) {\n\t  store._actions = Object.create(null)\n\t  store._mutations = Object.create(null)\n\t  store._wrappedGetters = Object.create(null)\n\t  store._modulesNamespaceMap = Object.create(null)\n\t  var state = store.state\n\t  // init all modules\n\t  installModule(store, state, [], store._modules.root, true)\n\t  // reset vm\n\t  resetStoreVM(store, state)\n\t}\n\t\n\tfunction resetStoreVM (store, state) {\n\t  var oldVm = store._vm\n\t\n\t  // bind store public getters\n\t  store.getters = {}\n\t  var wrappedGetters = store._wrappedGetters\n\t  var computed = {}\n\t  forEachValue(wrappedGetters, function (fn, key) {\n\t    // use computed to leverage its lazy-caching mechanism\n\t    computed[key] = function () { return fn(store); }\n\t    Object.defineProperty(store.getters, key, {\n\t      get: function () { return store._vm[key]; },\n\t      enumerable: true // for local getters\n\t    })\n\t  })\n\t\n\t  // use a Vue instance to store the state tree\n\t  // suppress warnings just in case the user has added\n\t  // some funky global mixins\n\t  var silent = Vue.config.silent\n\t  Vue.config.silent = true\n\t  store._vm = new Vue({\n\t    data: { state: state },\n\t    computed: computed\n\t  })\n\t  Vue.config.silent = silent\n\t\n\t  // enable strict mode for new vm\n\t  if (store.strict) {\n\t    enableStrictMode(store)\n\t  }\n\t\n\t  if (oldVm) {\n\t    // dispatch changes in all subscribed watchers\n\t    // to force getter re-evaluation.\n\t    store._withCommit(function () {\n\t      oldVm.state = null\n\t    })\n\t    Vue.nextTick(function () { return oldVm.$destroy(); })\n\t  }\n\t}\n\t\n\tfunction installModule (store, rootState, path, module, hot) {\n\t  var isRoot = !path.length\n\t  var namespace = store._modules.getNamespace(path)\n\t\n\t  // register in namespace map\n\t  if (namespace) {\n\t    store._modulesNamespaceMap[namespace] = module\n\t  }\n\t\n\t  // set state\n\t  if (!isRoot && !hot) {\n\t    var parentState = getNestedState(rootState, path.slice(0, -1))\n\t    var moduleName = path[path.length - 1]\n\t    store._withCommit(function () {\n\t      Vue.set(parentState, moduleName, module.state)\n\t    })\n\t  }\n\t\n\t  var local = module.context = makeLocalContext(store, namespace)\n\t\n\t  module.forEachMutation(function (mutation, key) {\n\t    var namespacedType = namespace + key\n\t    registerMutation(store, namespacedType, mutation, path)\n\t  })\n\t\n\t  module.forEachAction(function (action, key) {\n\t    var namespacedType = namespace + key\n\t    registerAction(store, namespacedType, action, local, path)\n\t  })\n\t\n\t  module.forEachGetter(function (getter, key) {\n\t    var namespacedType = namespace + key\n\t    registerGetter(store, namespacedType, getter, local, path)\n\t  })\n\t\n\t  module.forEachChild(function (child, key) {\n\t    installModule(store, rootState, path.concat(key), child, hot)\n\t  })\n\t}\n\t\n\t/**\n\t * make localized dispatch, commit and getters\n\t * if there is no namespace, just use root ones\n\t */\n\tfunction makeLocalContext (store, namespace) {\n\t  var noNamespace = namespace === ''\n\t\n\t  var local = {\n\t    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {\n\t      var args = unifyObjectStyle(_type, _payload, _options)\n\t      var payload = args.payload;\n\t      var options = args.options;\n\t      var type = args.type;\n\t\n\t      if (!options || !options.root) {\n\t        type = namespace + type\n\t        if (!store._actions[type]) {\n\t          console.error((\"[vuex] unknown local action type: \" + (args.type) + \", global type: \" + type))\n\t          return\n\t        }\n\t      }\n\t\n\t      return store.dispatch(type, payload)\n\t    },\n\t\n\t    commit: noNamespace ? store.commit : function (_type, _payload, _options) {\n\t      var args = unifyObjectStyle(_type, _payload, _options)\n\t      var payload = args.payload;\n\t      var options = args.options;\n\t      var type = args.type;\n\t\n\t      if (!options || !options.root) {\n\t        type = namespace + type\n\t        if (!store._mutations[type]) {\n\t          console.error((\"[vuex] unknown local mutation type: \" + (args.type) + \", global type: \" + type))\n\t          return\n\t        }\n\t      }\n\t\n\t      store.commit(type, payload, options)\n\t    }\n\t  }\n\t\n\t  // getters object must be gotten lazily\n\t  // because store.getters will be changed by vm update\n\t  Object.defineProperty(local, 'getters', {\n\t    get: noNamespace ? function () { return store.getters; } : function () { return makeLocalGetters(store, namespace); }\n\t  })\n\t\n\t  return local\n\t}\n\t\n\tfunction makeLocalGetters (store, namespace) {\n\t  var gettersProxy = {}\n\t\n\t  var splitPos = namespace.length\n\t  Object.keys(store.getters).forEach(function (type) {\n\t    // skip if the target getter is not match this namespace\n\t    if (type.slice(0, splitPos) !== namespace) { return }\n\t\n\t    // extract local getter type\n\t    var localType = type.slice(splitPos)\n\t\n\t    // Add a port to the getters proxy.\n\t    // Define as getter property because\n\t    // we do not want to evaluate the getters in this time.\n\t    Object.defineProperty(gettersProxy, localType, {\n\t      get: function () { return store.getters[type]; },\n\t      enumerable: true\n\t    })\n\t  })\n\t\n\t  return gettersProxy\n\t}\n\t\n\tfunction registerMutation (store, type, handler, path) {\n\t  var entry = store._mutations[type] || (store._mutations[type] = [])\n\t  entry.push(function wrappedMutationHandler (payload) {\n\t    handler(getNestedState(store.state, path), payload)\n\t  })\n\t}\n\t\n\tfunction registerAction (store, type, handler, local, path) {\n\t  var entry = store._actions[type] || (store._actions[type] = [])\n\t  entry.push(function wrappedActionHandler (payload, cb) {\n\t    var res = handler({\n\t      dispatch: local.dispatch,\n\t      commit: local.commit,\n\t      getters: local.getters,\n\t      state: getNestedState(store.state, path),\n\t      rootGetters: store.getters,\n\t      rootState: store.state\n\t    }, payload, cb)\n\t    if (!isPromise(res)) {\n\t      res = Promise.resolve(res)\n\t    }\n\t    if (store._devtoolHook) {\n\t      return res.catch(function (err) {\n\t        store._devtoolHook.emit('vuex:error', err)\n\t        throw err\n\t      })\n\t    } else {\n\t      return res\n\t    }\n\t  })\n\t}\n\t\n\tfunction registerGetter (store, type, rawGetter, local, path) {\n\t  if (store._wrappedGetters[type]) {\n\t    console.error((\"[vuex] duplicate getter key: \" + type))\n\t    return\n\t  }\n\t  store._wrappedGetters[type] = function wrappedGetter (store) {\n\t    return rawGetter(\n\t      getNestedState(store.state, path), // local state\n\t      local.getters, // local getters\n\t      store.state, // root state\n\t      store.getters // root getters\n\t    )\n\t  }\n\t}\n\t\n\tfunction enableStrictMode (store) {\n\t  store._vm.$watch('state', function () {\n\t    assert(store._committing, \"Do not mutate vuex store state outside mutation handlers.\")\n\t  }, { deep: true, sync: true })\n\t}\n\t\n\tfunction getNestedState (state, path) {\n\t  return path.length\n\t    ? path.reduce(function (state, key) { return state[key]; }, state)\n\t    : state\n\t}\n\t\n\tfunction unifyObjectStyle (type, payload, options) {\n\t  if (isObject(type) && type.type) {\n\t    options = payload\n\t    payload = type\n\t    type = type.type\n\t  }\n\t  return { type: type, payload: payload, options: options }\n\t}\n\t\n\tfunction install (_Vue) {\n\t  if (Vue) {\n\t    console.error(\n\t      '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n\t    )\n\t    return\n\t  }\n\t  Vue = _Vue\n\t  applyMixin(Vue)\n\t}\n\t\n\t// auto install in dist mode\n\tif (typeof window !== 'undefined' && window.Vue) {\n\t  install(window.Vue)\n\t}\n\t\n\tvar index = {\n\t  Store: Store,\n\t  install: install,\n\t  version: '2.1.1',\n\t  mapState: mapState,\n\t  mapMutations: mapMutations,\n\t  mapGetters: mapGetters,\n\t  mapActions: mapActions\n\t}\n\t\n\treturn index;\n\t\n\t})));\n\n/***/ },\n/* 32 */,\n/* 33 */,\n/* 34 */,\n/* 35 */,\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(39), __esModule: true };\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(40), __esModule: true };\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _from = __webpack_require__(36);\n\t\n\tvar _from2 = _interopRequireDefault(_from);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function (arr) {\n\t  if (Array.isArray(arr)) {\n\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n\t      arr2[i] = arr[i];\n\t    }\n\t\n\t    return arr2;\n\t  } else {\n\t    return (0, _from2.default)(arr);\n\t  }\n\t};\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(67);\n\t__webpack_require__(65);\n\tmodule.exports = __webpack_require__(4).Array.from;\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(66);\n\tmodule.exports = __webpack_require__(4).Object.assign;\n\n/***/ },\n/* 41 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// false -> Array#indexOf\n\t// true  -> Array#includes\n\tvar toIObject = __webpack_require__(27)\n\t  , toLength  = __webpack_require__(28)\n\t  , toIndex   = __webpack_require__(62);\n\tmodule.exports = function(IS_INCLUDES){\n\t  return function($this, el, fromIndex){\n\t    var O      = toIObject($this)\n\t      , length = toLength(O.length)\n\t      , index  = toIndex(fromIndex, length)\n\t      , value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    if(IS_INCLUDES && el != el)while(length > index){\n\t      value = O[index++];\n\t      if(value != value)return true;\n\t    // Array#toIndex ignores holes, Array#includes - not\n\t    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n\t      if(O[index] === el)return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// getting tag from 19.1.3.6 Object.prototype.toString()\n\tvar cof = __webpack_require__(19)\n\t  , TAG = __webpack_require__(1)('toStringTag')\n\t  // ES3 wrong here\n\t  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\t\n\t// fallback for IE11 Script Access Denied error\n\tvar tryGet = function(it, key){\n\t  try {\n\t    return it[key];\n\t  } catch(e){ /* empty */ }\n\t};\n\t\n\tmodule.exports = function(it){\n\t  var O, T, B;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n\t    // builtinTag case\n\t    : ARG ? cof(O)\n\t    // ES3 arguments fallback\n\t    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n\t};\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $defineProperty = __webpack_require__(8)\n\t  , createDesc      = __webpack_require__(14);\n\t\n\tmodule.exports = function(object, index, value){\n\t  if(index in object)$defineProperty.f(object, index, createDesc(0, value));\n\t  else object[index] = value;\n\t};\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2).document && document.documentElement;\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = !__webpack_require__(5) && !__webpack_require__(11)(function(){\n\t  return Object.defineProperty(__webpack_require__(21)('div'), 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// check on default Array iterator\n\tvar Iterators  = __webpack_require__(13)\n\t  , ITERATOR   = __webpack_require__(1)('iterator')\n\t  , ArrayProto = Array.prototype;\n\t\n\tmodule.exports = function(it){\n\t  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n\t};\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// call something on iterator step with safe closing on error\n\tvar anObject = __webpack_require__(3);\n\tmodule.exports = function(iterator, fn, value, entries){\n\t  try {\n\t    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n\t  // 7.4.6 IteratorClose(iterator, completion)\n\t  } catch(e){\n\t    var ret = iterator['return'];\n\t    if(ret !== undefined)anObject(ret.call(iterator));\n\t    throw e;\n\t  }\n\t};\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar create         = __webpack_require__(54)\n\t  , descriptor     = __webpack_require__(14)\n\t  , setToStringTag = __webpack_require__(25)\n\t  , IteratorPrototype = {};\n\t\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\t__webpack_require__(7)(IteratorPrototype, __webpack_require__(1)('iterator'), function(){ return this; });\n\t\n\tmodule.exports = function(Constructor, NAME, next){\n\t  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n\t  setToStringTag(Constructor, NAME + ' Iterator');\n\t};\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY        = __webpack_require__(52)\n\t  , $export        = __webpack_require__(10)\n\t  , redefine       = __webpack_require__(60)\n\t  , hide           = __webpack_require__(7)\n\t  , has            = __webpack_require__(6)\n\t  , Iterators      = __webpack_require__(13)\n\t  , $iterCreate    = __webpack_require__(49)\n\t  , setToStringTag = __webpack_require__(25)\n\t  , getPrototypeOf = __webpack_require__(57)\n\t  , ITERATOR       = __webpack_require__(1)('iterator')\n\t  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n\t  , FF_ITERATOR    = '@@iterator'\n\t  , KEYS           = 'keys'\n\t  , VALUES         = 'values';\n\t\n\tvar returnThis = function(){ return this; };\n\t\n\tmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n\t  $iterCreate(Constructor, NAME, next);\n\t  var getMethod = function(kind){\n\t    if(!BUGGY && kind in proto)return proto[kind];\n\t    switch(kind){\n\t      case KEYS: return function keys(){ return new Constructor(this, kind); };\n\t      case VALUES: return function values(){ return new Constructor(this, kind); };\n\t    } return function entries(){ return new Constructor(this, kind); };\n\t  };\n\t  var TAG        = NAME + ' Iterator'\n\t    , DEF_VALUES = DEFAULT == VALUES\n\t    , VALUES_BUG = false\n\t    , proto      = Base.prototype\n\t    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n\t    , $default   = $native || getMethod(DEFAULT)\n\t    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n\t    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n\t    , methods, key, IteratorPrototype;\n\t  // Fix native\n\t  if($anyNative){\n\t    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n\t    if(IteratorPrototype !== Object.prototype){\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(IteratorPrototype, TAG, true);\n\t      // fix for some old engines\n\t      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n\t    }\n\t  }\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if(DEF_VALUES && $native && $native.name !== VALUES){\n\t    VALUES_BUG = true;\n\t    $default = function values(){ return $native.call(this); };\n\t  }\n\t  // Define iterator\n\t  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n\t    hide(proto, ITERATOR, $default);\n\t  }\n\t  // Plug for library\n\t  Iterators[NAME] = $default;\n\t  Iterators[TAG]  = returnThis;\n\t  if(DEFAULT){\n\t    methods = {\n\t      values:  DEF_VALUES ? $default : getMethod(VALUES),\n\t      keys:    IS_SET     ? $default : getMethod(KEYS),\n\t      entries: $entries\n\t    };\n\t    if(FORCED)for(key in methods){\n\t      if(!(key in proto))redefine(proto, key, methods[key]);\n\t    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n\t  }\n\t  return methods;\n\t};\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ITERATOR     = __webpack_require__(1)('iterator')\n\t  , SAFE_CLOSING = false;\n\t\n\ttry {\n\t  var riter = [7][ITERATOR]();\n\t  riter['return'] = function(){ SAFE_CLOSING = true; };\n\t  Array.from(riter, function(){ throw 2; });\n\t} catch(e){ /* empty */ }\n\t\n\tmodule.exports = function(exec, skipClosing){\n\t  if(!skipClosing && !SAFE_CLOSING)return false;\n\t  var safe = false;\n\t  try {\n\t    var arr  = [7]\n\t      , iter = arr[ITERATOR]();\n\t    iter.next = function(){ return {done: safe = true}; };\n\t    arr[ITERATOR] = function(){ return iter; };\n\t    exec(arr);\n\t  } catch(e){ /* empty */ }\n\t  return safe;\n\t};\n\n/***/ },\n/* 52 */\n/***/ function(module, exports) {\n\n\tmodule.exports = true;\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// 19.1.2.1 Object.assign(target, source, ...)\n\tvar getKeys  = __webpack_require__(24)\n\t  , gOPS     = __webpack_require__(56)\n\t  , pIE      = __webpack_require__(59)\n\t  , toObject = __webpack_require__(17)\n\t  , IObject  = __webpack_require__(23)\n\t  , $assign  = Object.assign;\n\t\n\t// should work with symbols and should have deterministic property order (V8 bug)\n\tmodule.exports = !$assign || __webpack_require__(11)(function(){\n\t  var A = {}\n\t    , B = {}\n\t    , S = Symbol()\n\t    , K = 'abcdefghijklmnopqrst';\n\t  A[S] = 7;\n\t  K.split('').forEach(function(k){ B[k] = k; });\n\t  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n\t}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n\t  var T     = toObject(target)\n\t    , aLen  = arguments.length\n\t    , index = 1\n\t    , getSymbols = gOPS.f\n\t    , isEnum     = pIE.f;\n\t  while(aLen > index){\n\t    var S      = IObject(arguments[index++])\n\t      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n\t      , length = keys.length\n\t      , j      = 0\n\t      , key;\n\t    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n\t  } return T;\n\t} : $assign;\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n\tvar anObject    = __webpack_require__(3)\n\t  , dPs         = __webpack_require__(55)\n\t  , enumBugKeys = __webpack_require__(22)\n\t  , IE_PROTO    = __webpack_require__(15)('IE_PROTO')\n\t  , Empty       = function(){ /* empty */ }\n\t  , PROTOTYPE   = 'prototype';\n\t\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\n\tvar createDict = function(){\n\t  // Thrash, waste and sodomy: IE GC bug\n\t  var iframe = __webpack_require__(21)('iframe')\n\t    , i      = enumBugKeys.length\n\t    , lt     = '<'\n\t    , gt     = '>'\n\t    , iframeDocument;\n\t  iframe.style.display = 'none';\n\t  __webpack_require__(45).appendChild(iframe);\n\t  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n\t  // createDict = iframe.contentWindow.Object;\n\t  // html.removeChild(iframe);\n\t  iframeDocument = iframe.contentWindow.document;\n\t  iframeDocument.open();\n\t  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n\t  iframeDocument.close();\n\t  createDict = iframeDocument.F;\n\t  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n\t  return createDict();\n\t};\n\t\n\tmodule.exports = Object.create || function create(O, Properties){\n\t  var result;\n\t  if(O !== null){\n\t    Empty[PROTOTYPE] = anObject(O);\n\t    result = new Empty;\n\t    Empty[PROTOTYPE] = null;\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\n\t    result[IE_PROTO] = O;\n\t  } else result = createDict();\n\t  return Properties === undefined ? result : dPs(result, Properties);\n\t};\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP       = __webpack_require__(8)\n\t  , anObject = __webpack_require__(3)\n\t  , getKeys  = __webpack_require__(24);\n\t\n\tmodule.exports = __webpack_require__(5) ? Object.defineProperties : function defineProperties(O, Properties){\n\t  anObject(O);\n\t  var keys   = getKeys(Properties)\n\t    , length = keys.length\n\t    , i = 0\n\t    , P;\n\t  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n\t  return O;\n\t};\n\n/***/ },\n/* 56 */\n/***/ function(module, exports) {\n\n\texports.f = Object.getOwnPropertySymbols;\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\n\tvar has         = __webpack_require__(6)\n\t  , toObject    = __webpack_require__(17)\n\t  , IE_PROTO    = __webpack_require__(15)('IE_PROTO')\n\t  , ObjectProto = Object.prototype;\n\t\n\tmodule.exports = Object.getPrototypeOf || function(O){\n\t  O = toObject(O);\n\t  if(has(O, IE_PROTO))return O[IE_PROTO];\n\t  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n\t    return O.constructor.prototype;\n\t  } return O instanceof Object ? ObjectProto : null;\n\t};\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar has          = __webpack_require__(6)\n\t  , toIObject    = __webpack_require__(27)\n\t  , arrayIndexOf = __webpack_require__(42)(false)\n\t  , IE_PROTO     = __webpack_require__(15)('IE_PROTO');\n\t\n\tmodule.exports = function(object, names){\n\t  var O      = toIObject(object)\n\t    , i      = 0\n\t    , result = []\n\t    , key;\n\t  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n\t  // Don't enum bug & hidden keys\n\t  while(names.length > i)if(has(O, key = names[i++])){\n\t    ~arrayIndexOf(result, key) || result.push(key);\n\t  }\n\t  return result;\n\t};\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\n\texports.f = {}.propertyIsEnumerable;\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(7);\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(16)\n\t  , defined   = __webpack_require__(9);\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tmodule.exports = function(TO_STRING){\n\t  return function(that, pos){\n\t    var s = String(defined(that))\n\t      , i = toInteger(pos)\n\t      , l = s.length\n\t      , a, b;\n\t    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(16)\n\t  , max       = Math.max\n\t  , min       = Math.min;\n\tmodule.exports = function(index, length){\n\t  index = toInteger(index);\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\n\t};\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.1 ToPrimitive(input [, PreferredType])\n\tvar isObject = __webpack_require__(12);\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tmodule.exports = function(it, S){\n\t  if(!isObject(it))return it;\n\t  var fn, val;\n\t  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar classof   = __webpack_require__(43)\n\t  , ITERATOR  = __webpack_require__(1)('iterator')\n\t  , Iterators = __webpack_require__(13);\n\tmodule.exports = __webpack_require__(4).getIteratorMethod = function(it){\n\t  if(it != undefined)return it[ITERATOR]\n\t    || it['@@iterator']\n\t    || Iterators[classof(it)];\n\t};\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar ctx            = __webpack_require__(20)\n\t  , $export        = __webpack_require__(10)\n\t  , toObject       = __webpack_require__(17)\n\t  , call           = __webpack_require__(48)\n\t  , isArrayIter    = __webpack_require__(47)\n\t  , toLength       = __webpack_require__(28)\n\t  , createProperty = __webpack_require__(44)\n\t  , getIterFn      = __webpack_require__(64);\n\t\n\t$export($export.S + $export.F * !__webpack_require__(51)(function(iter){ Array.from(iter); }), 'Array', {\n\t  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n\t  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\n\t    var O       = toObject(arrayLike)\n\t      , C       = typeof this == 'function' ? this : Array\n\t      , aLen    = arguments.length\n\t      , mapfn   = aLen > 1 ? arguments[1] : undefined\n\t      , mapping = mapfn !== undefined\n\t      , index   = 0\n\t      , iterFn  = getIterFn(O)\n\t      , length, result, step, iterator;\n\t    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n\t    // if object isn't iterable or it's array with default iterator - use simple case\n\t    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){\n\t      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){\n\t        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n\t      }\n\t    } else {\n\t      length = toLength(O.length);\n\t      for(result = new C(length); length > index; index++){\n\t        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n\t      }\n\t    }\n\t    result.length = index;\n\t    return result;\n\t  }\n\t});\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.3.1 Object.assign(target, source)\n\tvar $export = __webpack_require__(10);\n\t\n\t$export($export.S + $export.F, 'Object', {assign: __webpack_require__(53)});\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $at  = __webpack_require__(61)(true);\n\t\n\t// 21.1.3.27 String.prototype[@@iterator]()\n\t__webpack_require__(50)(String, 'String', function(iterated){\n\t  this._t = String(iterated); // target\n\t  this._i = 0;                // next index\n\t// 21.1.5.2.1 %StringIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , index = this._i\n\t    , point;\n\t  if(index >= O.length)return {value: undefined, done: true};\n\t  point = $at(O, index);\n\t  this._i += point.length;\n\t  return {value: point, done: false};\n\t});\n\n/***/ },\n/* 68 */,\n/* 69 */,\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;// Fine Uploader 5.11.10 - (c) 2013-present Widen Enterprises, Inc. MIT licensed. http://fineuploader.com\n\t(function(global) {\n\t    var qq = function(element) {\n\t        \"use strict\";\n\t        return {\n\t            hide: function() {\n\t                element.style.display = \"none\";\n\t                return this;\n\t            },\n\t            attach: function(type, fn) {\n\t                if (element.addEventListener) {\n\t                    element.addEventListener(type, fn, false);\n\t                } else if (element.attachEvent) {\n\t                    element.attachEvent(\"on\" + type, fn);\n\t                }\n\t                return function() {\n\t                    qq(element).detach(type, fn);\n\t                };\n\t            },\n\t            detach: function(type, fn) {\n\t                if (element.removeEventListener) {\n\t                    element.removeEventListener(type, fn, false);\n\t                } else if (element.attachEvent) {\n\t                    element.detachEvent(\"on\" + type, fn);\n\t                }\n\t                return this;\n\t            },\n\t            contains: function(descendant) {\n\t                if (!descendant) {\n\t                    return false;\n\t                }\n\t                if (element === descendant) {\n\t                    return true;\n\t                }\n\t                if (element.contains) {\n\t                    return element.contains(descendant);\n\t                } else {\n\t                    return !!(descendant.compareDocumentPosition(element) & 8);\n\t                }\n\t            },\n\t            insertBefore: function(elementB) {\n\t                elementB.parentNode.insertBefore(element, elementB);\n\t                return this;\n\t            },\n\t            remove: function() {\n\t                element.parentNode.removeChild(element);\n\t                return this;\n\t            },\n\t            css: function(styles) {\n\t                if (element.style == null) {\n\t                    throw new qq.Error(\"Can't apply style to node as it is not on the HTMLElement prototype chain!\");\n\t                }\n\t                if (styles.opacity != null) {\n\t                    if (typeof element.style.opacity !== \"string\" && typeof element.filters !== \"undefined\") {\n\t                        styles.filter = \"alpha(opacity=\" + Math.round(100 * styles.opacity) + \")\";\n\t                    }\n\t                }\n\t                qq.extend(element.style, styles);\n\t                return this;\n\t            },\n\t            hasClass: function(name, considerParent) {\n\t                var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n\t                return re.test(element.className) || !!(considerParent && re.test(element.parentNode.className));\n\t            },\n\t            addClass: function(name) {\n\t                if (!qq(element).hasClass(name)) {\n\t                    element.className += \" \" + name;\n\t                }\n\t                return this;\n\t            },\n\t            removeClass: function(name) {\n\t                var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n\t                element.className = element.className.replace(re, \" \").replace(/^\\s+|\\s+$/g, \"\");\n\t                return this;\n\t            },\n\t            getByClass: function(className, first) {\n\t                var candidates, result = [];\n\t                if (first && element.querySelector) {\n\t                    return element.querySelector(\".\" + className);\n\t                } else if (element.querySelectorAll) {\n\t                    return element.querySelectorAll(\".\" + className);\n\t                }\n\t                candidates = element.getElementsByTagName(\"*\");\n\t                qq.each(candidates, function(idx, val) {\n\t                    if (qq(val).hasClass(className)) {\n\t                        result.push(val);\n\t                    }\n\t                });\n\t                return first ? result[0] : result;\n\t            },\n\t            getFirstByClass: function(className) {\n\t                return qq(element).getByClass(className, true);\n\t            },\n\t            children: function() {\n\t                var children = [], child = element.firstChild;\n\t                while (child) {\n\t                    if (child.nodeType === 1) {\n\t                        children.push(child);\n\t                    }\n\t                    child = child.nextSibling;\n\t                }\n\t                return children;\n\t            },\n\t            setText: function(text) {\n\t                element.innerText = text;\n\t                element.textContent = text;\n\t                return this;\n\t            },\n\t            clearText: function() {\n\t                return qq(element).setText(\"\");\n\t            },\n\t            hasAttribute: function(attrName) {\n\t                var attrVal;\n\t                if (element.hasAttribute) {\n\t                    if (!element.hasAttribute(attrName)) {\n\t                        return false;\n\t                    }\n\t                    return /^false$/i.exec(element.getAttribute(attrName)) == null;\n\t                } else {\n\t                    attrVal = element[attrName];\n\t                    if (attrVal === undefined) {\n\t                        return false;\n\t                    }\n\t                    return /^false$/i.exec(attrVal) == null;\n\t                }\n\t            }\n\t        };\n\t    };\n\t    (function() {\n\t        \"use strict\";\n\t        qq.canvasToBlob = function(canvas, mime, quality) {\n\t            return qq.dataUriToBlob(canvas.toDataURL(mime, quality));\n\t        };\n\t        qq.dataUriToBlob = function(dataUri) {\n\t            var arrayBuffer, byteString, createBlob = function(data, mime) {\n\t                var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, blobBuilder = BlobBuilder && new BlobBuilder();\n\t                if (blobBuilder) {\n\t                    blobBuilder.append(data);\n\t                    return blobBuilder.getBlob(mime);\n\t                } else {\n\t                    return new Blob([ data ], {\n\t                        type: mime\n\t                    });\n\t                }\n\t            }, intArray, mimeString;\n\t            if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n\t                byteString = atob(dataUri.split(\",\")[1]);\n\t            } else {\n\t                byteString = decodeURI(dataUri.split(\",\")[1]);\n\t            }\n\t            mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n\t            arrayBuffer = new ArrayBuffer(byteString.length);\n\t            intArray = new Uint8Array(arrayBuffer);\n\t            qq.each(byteString, function(idx, character) {\n\t                intArray[idx] = character.charCodeAt(0);\n\t            });\n\t            return createBlob(arrayBuffer, mimeString);\n\t        };\n\t        qq.log = function(message, level) {\n\t            if (window.console) {\n\t                if (!level || level === \"info\") {\n\t                    window.console.log(message);\n\t                } else {\n\t                    if (window.console[level]) {\n\t                        window.console[level](message);\n\t                    } else {\n\t                        window.console.log(\"<\" + level + \"> \" + message);\n\t                    }\n\t                }\n\t            }\n\t        };\n\t        qq.isObject = function(variable) {\n\t            return variable && !variable.nodeType && Object.prototype.toString.call(variable) === \"[object Object]\";\n\t        };\n\t        qq.isFunction = function(variable) {\n\t            return typeof variable === \"function\";\n\t        };\n\t        qq.isArray = function(value) {\n\t            return Object.prototype.toString.call(value) === \"[object Array]\" || value && window.ArrayBuffer && value.buffer && value.buffer.constructor === ArrayBuffer;\n\t        };\n\t        qq.isItemList = function(maybeItemList) {\n\t            return Object.prototype.toString.call(maybeItemList) === \"[object DataTransferItemList]\";\n\t        };\n\t        qq.isNodeList = function(maybeNodeList) {\n\t            return Object.prototype.toString.call(maybeNodeList) === \"[object NodeList]\" || maybeNodeList.item && maybeNodeList.namedItem;\n\t        };\n\t        qq.isString = function(maybeString) {\n\t            return Object.prototype.toString.call(maybeString) === \"[object String]\";\n\t        };\n\t        qq.trimStr = function(string) {\n\t            if (String.prototype.trim) {\n\t                return string.trim();\n\t            }\n\t            return string.replace(/^\\s+|\\s+$/g, \"\");\n\t        };\n\t        qq.format = function(str) {\n\t            var args = Array.prototype.slice.call(arguments, 1), newStr = str, nextIdxToReplace = newStr.indexOf(\"{}\");\n\t            qq.each(args, function(idx, val) {\n\t                var strBefore = newStr.substring(0, nextIdxToReplace), strAfter = newStr.substring(nextIdxToReplace + 2);\n\t                newStr = strBefore + val + strAfter;\n\t                nextIdxToReplace = newStr.indexOf(\"{}\", nextIdxToReplace + val.length);\n\t                if (nextIdxToReplace < 0) {\n\t                    return false;\n\t                }\n\t            });\n\t            return newStr;\n\t        };\n\t        qq.isFile = function(maybeFile) {\n\t            return window.File && Object.prototype.toString.call(maybeFile) === \"[object File]\";\n\t        };\n\t        qq.isFileList = function(maybeFileList) {\n\t            return window.FileList && Object.prototype.toString.call(maybeFileList) === \"[object FileList]\";\n\t        };\n\t        qq.isFileOrInput = function(maybeFileOrInput) {\n\t            return qq.isFile(maybeFileOrInput) || qq.isInput(maybeFileOrInput);\n\t        };\n\t        qq.isInput = function(maybeInput, notFile) {\n\t            var evaluateType = function(type) {\n\t                var normalizedType = type.toLowerCase();\n\t                if (notFile) {\n\t                    return normalizedType !== \"file\";\n\t                }\n\t                return normalizedType === \"file\";\n\t            };\n\t            if (window.HTMLInputElement) {\n\t                if (Object.prototype.toString.call(maybeInput) === \"[object HTMLInputElement]\") {\n\t                    if (maybeInput.type && evaluateType(maybeInput.type)) {\n\t                        return true;\n\t                    }\n\t                }\n\t            }\n\t            if (maybeInput.tagName) {\n\t                if (maybeInput.tagName.toLowerCase() === \"input\") {\n\t                    if (maybeInput.type && evaluateType(maybeInput.type)) {\n\t                        return true;\n\t                    }\n\t                }\n\t            }\n\t            return false;\n\t        };\n\t        qq.isBlob = function(maybeBlob) {\n\t            if (window.Blob && Object.prototype.toString.call(maybeBlob) === \"[object Blob]\") {\n\t                return true;\n\t            }\n\t        };\n\t        qq.isXhrUploadSupported = function() {\n\t            var input = document.createElement(\"input\");\n\t            input.type = \"file\";\n\t            return input.multiple !== undefined && typeof File !== \"undefined\" && typeof FormData !== \"undefined\" && typeof qq.createXhrInstance().upload !== \"undefined\";\n\t        };\n\t        qq.createXhrInstance = function() {\n\t            if (window.XMLHttpRequest) {\n\t                return new XMLHttpRequest();\n\t            }\n\t            try {\n\t                return new ActiveXObject(\"MSXML2.XMLHTTP.3.0\");\n\t            } catch (error) {\n\t                qq.log(\"Neither XHR or ActiveX are supported!\", \"error\");\n\t                return null;\n\t            }\n\t        };\n\t        qq.isFolderDropSupported = function(dataTransfer) {\n\t            return dataTransfer.items && dataTransfer.items.length > 0 && dataTransfer.items[0].webkitGetAsEntry;\n\t        };\n\t        qq.isFileChunkingSupported = function() {\n\t            return !qq.androidStock() && qq.isXhrUploadSupported() && (File.prototype.slice !== undefined || File.prototype.webkitSlice !== undefined || File.prototype.mozSlice !== undefined);\n\t        };\n\t        qq.sliceBlob = function(fileOrBlob, start, end) {\n\t            var slicer = fileOrBlob.slice || fileOrBlob.mozSlice || fileOrBlob.webkitSlice;\n\t            return slicer.call(fileOrBlob, start, end);\n\t        };\n\t        qq.arrayBufferToHex = function(buffer) {\n\t            var bytesAsHex = \"\", bytes = new Uint8Array(buffer);\n\t            qq.each(bytes, function(idx, byt) {\n\t                var byteAsHexStr = byt.toString(16);\n\t                if (byteAsHexStr.length < 2) {\n\t                    byteAsHexStr = \"0\" + byteAsHexStr;\n\t                }\n\t                bytesAsHex += byteAsHexStr;\n\t            });\n\t            return bytesAsHex;\n\t        };\n\t        qq.readBlobToHex = function(blob, startOffset, length) {\n\t            var initialBlob = qq.sliceBlob(blob, startOffset, startOffset + length), fileReader = new FileReader(), promise = new qq.Promise();\n\t            fileReader.onload = function() {\n\t                promise.success(qq.arrayBufferToHex(fileReader.result));\n\t            };\n\t            fileReader.onerror = promise.failure;\n\t            fileReader.readAsArrayBuffer(initialBlob);\n\t            return promise;\n\t        };\n\t        qq.extend = function(first, second, extendNested) {\n\t            qq.each(second, function(prop, val) {\n\t                if (extendNested && qq.isObject(val)) {\n\t                    if (first[prop] === undefined) {\n\t                        first[prop] = {};\n\t                    }\n\t                    qq.extend(first[prop], val, true);\n\t                } else {\n\t                    first[prop] = val;\n\t                }\n\t            });\n\t            return first;\n\t        };\n\t        qq.override = function(target, sourceFn) {\n\t            var super_ = {}, source = sourceFn(super_);\n\t            qq.each(source, function(srcPropName, srcPropVal) {\n\t                if (target[srcPropName] !== undefined) {\n\t                    super_[srcPropName] = target[srcPropName];\n\t                }\n\t                target[srcPropName] = srcPropVal;\n\t            });\n\t            return target;\n\t        };\n\t        qq.indexOf = function(arr, elt, from) {\n\t            if (arr.indexOf) {\n\t                return arr.indexOf(elt, from);\n\t            }\n\t            from = from || 0;\n\t            var len = arr.length;\n\t            if (from < 0) {\n\t                from += len;\n\t            }\n\t            for (;from < len; from += 1) {\n\t                if (arr.hasOwnProperty(from) && arr[from] === elt) {\n\t                    return from;\n\t                }\n\t            }\n\t            return -1;\n\t        };\n\t        qq.getUniqueId = function() {\n\t            return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n\t                var r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 3 | 8;\n\t                return v.toString(16);\n\t            });\n\t        };\n\t        qq.ie = function() {\n\t            return navigator.userAgent.indexOf(\"MSIE\") !== -1 || navigator.userAgent.indexOf(\"Trident\") !== -1;\n\t        };\n\t        qq.ie7 = function() {\n\t            return navigator.userAgent.indexOf(\"MSIE 7\") !== -1;\n\t        };\n\t        qq.ie8 = function() {\n\t            return navigator.userAgent.indexOf(\"MSIE 8\") !== -1;\n\t        };\n\t        qq.ie10 = function() {\n\t            return navigator.userAgent.indexOf(\"MSIE 10\") !== -1;\n\t        };\n\t        qq.ie11 = function() {\n\t            return qq.ie() && navigator.userAgent.indexOf(\"rv:11\") !== -1;\n\t        };\n\t        qq.edge = function() {\n\t            return navigator.userAgent.indexOf(\"Edge\") >= 0;\n\t        };\n\t        qq.safari = function() {\n\t            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Apple\") !== -1;\n\t        };\n\t        qq.chrome = function() {\n\t            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Google\") !== -1;\n\t        };\n\t        qq.opera = function() {\n\t            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Opera\") !== -1;\n\t        };\n\t        qq.firefox = function() {\n\t            return !qq.edge() && !qq.ie11() && navigator.userAgent.indexOf(\"Mozilla\") !== -1 && navigator.vendor !== undefined && navigator.vendor === \"\";\n\t        };\n\t        qq.windows = function() {\n\t            return navigator.platform === \"Win32\";\n\t        };\n\t        qq.android = function() {\n\t            return navigator.userAgent.toLowerCase().indexOf(\"android\") !== -1;\n\t        };\n\t        qq.androidStock = function() {\n\t            return qq.android() && navigator.userAgent.toLowerCase().indexOf(\"chrome\") < 0;\n\t        };\n\t        qq.ios6 = function() {\n\t            return qq.ios() && navigator.userAgent.indexOf(\" OS 6_\") !== -1;\n\t        };\n\t        qq.ios7 = function() {\n\t            return qq.ios() && navigator.userAgent.indexOf(\" OS 7_\") !== -1;\n\t        };\n\t        qq.ios8 = function() {\n\t            return qq.ios() && navigator.userAgent.indexOf(\" OS 8_\") !== -1;\n\t        };\n\t        qq.ios800 = function() {\n\t            return qq.ios() && navigator.userAgent.indexOf(\" OS 8_0 \") !== -1;\n\t        };\n\t        qq.ios = function() {\n\t            return navigator.userAgent.indexOf(\"iPad\") !== -1 || navigator.userAgent.indexOf(\"iPod\") !== -1 || navigator.userAgent.indexOf(\"iPhone\") !== -1;\n\t        };\n\t        qq.iosChrome = function() {\n\t            return qq.ios() && navigator.userAgent.indexOf(\"CriOS\") !== -1;\n\t        };\n\t        qq.iosSafari = function() {\n\t            return qq.ios() && !qq.iosChrome() && navigator.userAgent.indexOf(\"Safari\") !== -1;\n\t        };\n\t        qq.iosSafariWebView = function() {\n\t            return qq.ios() && !qq.iosChrome() && !qq.iosSafari();\n\t        };\n\t        qq.preventDefault = function(e) {\n\t            if (e.preventDefault) {\n\t                e.preventDefault();\n\t            } else {\n\t                e.returnValue = false;\n\t            }\n\t        };\n\t        qq.toElement = function() {\n\t            var div = document.createElement(\"div\");\n\t            return function(html) {\n\t                div.innerHTML = html;\n\t                var element = div.firstChild;\n\t                div.removeChild(element);\n\t                return element;\n\t            };\n\t        }();\n\t        qq.each = function(iterableItem, callback) {\n\t            var keyOrIndex, retVal;\n\t            if (iterableItem) {\n\t                if (window.Storage && iterableItem.constructor === window.Storage) {\n\t                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n\t                        retVal = callback(iterableItem.key(keyOrIndex), iterableItem.getItem(iterableItem.key(keyOrIndex)));\n\t                        if (retVal === false) {\n\t                            break;\n\t                        }\n\t                    }\n\t                } else if (qq.isArray(iterableItem) || qq.isItemList(iterableItem) || qq.isNodeList(iterableItem)) {\n\t                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n\t                        retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n\t                        if (retVal === false) {\n\t                            break;\n\t                        }\n\t                    }\n\t                } else if (qq.isString(iterableItem)) {\n\t                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n\t                        retVal = callback(keyOrIndex, iterableItem.charAt(keyOrIndex));\n\t                        if (retVal === false) {\n\t                            break;\n\t                        }\n\t                    }\n\t                } else {\n\t                    for (keyOrIndex in iterableItem) {\n\t                        if (Object.prototype.hasOwnProperty.call(iterableItem, keyOrIndex)) {\n\t                            retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n\t                            if (retVal === false) {\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        };\n\t        qq.bind = function(oldFunc, context) {\n\t            if (qq.isFunction(oldFunc)) {\n\t                var args = Array.prototype.slice.call(arguments, 2);\n\t                return function() {\n\t                    var newArgs = qq.extend([], args);\n\t                    if (arguments.length) {\n\t                        newArgs = newArgs.concat(Array.prototype.slice.call(arguments));\n\t                    }\n\t                    return oldFunc.apply(context, newArgs);\n\t                };\n\t            }\n\t            throw new Error(\"first parameter must be a function!\");\n\t        };\n\t        qq.obj2url = function(obj, temp, prefixDone) {\n\t            var uristrings = [], prefix = \"&\", add = function(nextObj, i) {\n\t                var nextTemp = temp ? /\\[\\]$/.test(temp) ? temp : temp + \"[\" + i + \"]\" : i;\n\t                if (nextTemp !== \"undefined\" && i !== \"undefined\") {\n\t                    uristrings.push(typeof nextObj === \"object\" ? qq.obj2url(nextObj, nextTemp, true) : Object.prototype.toString.call(nextObj) === \"[object Function]\" ? encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj()) : encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj));\n\t                }\n\t            };\n\t            if (!prefixDone && temp) {\n\t                prefix = /\\?/.test(temp) ? /\\?$/.test(temp) ? \"\" : \"&\" : \"?\";\n\t                uristrings.push(temp);\n\t                uristrings.push(qq.obj2url(obj));\n\t            } else if (Object.prototype.toString.call(obj) === \"[object Array]\" && typeof obj !== \"undefined\") {\n\t                qq.each(obj, function(idx, val) {\n\t                    add(val, idx);\n\t                });\n\t            } else if (typeof obj !== \"undefined\" && obj !== null && typeof obj === \"object\") {\n\t                qq.each(obj, function(prop, val) {\n\t                    add(val, prop);\n\t                });\n\t            } else {\n\t                uristrings.push(encodeURIComponent(temp) + \"=\" + encodeURIComponent(obj));\n\t            }\n\t            if (temp) {\n\t                return uristrings.join(prefix);\n\t            } else {\n\t                return uristrings.join(prefix).replace(/^&/, \"\").replace(/%20/g, \"+\");\n\t            }\n\t        };\n\t        qq.obj2FormData = function(obj, formData, arrayKeyName) {\n\t            if (!formData) {\n\t                formData = new FormData();\n\t            }\n\t            qq.each(obj, function(key, val) {\n\t                key = arrayKeyName ? arrayKeyName + \"[\" + key + \"]\" : key;\n\t                if (qq.isObject(val)) {\n\t                    qq.obj2FormData(val, formData, key);\n\t                } else if (qq.isFunction(val)) {\n\t                    formData.append(key, val());\n\t                } else {\n\t                    formData.append(key, val);\n\t                }\n\t            });\n\t            return formData;\n\t        };\n\t        qq.obj2Inputs = function(obj, form) {\n\t            var input;\n\t            if (!form) {\n\t                form = document.createElement(\"form\");\n\t            }\n\t            qq.obj2FormData(obj, {\n\t                append: function(key, val) {\n\t                    input = document.createElement(\"input\");\n\t                    input.setAttribute(\"name\", key);\n\t                    input.setAttribute(\"value\", val);\n\t                    form.appendChild(input);\n\t                }\n\t            });\n\t            return form;\n\t        };\n\t        qq.parseJson = function(json) {\n\t            if (window.JSON && qq.isFunction(JSON.parse)) {\n\t                return JSON.parse(json);\n\t            } else {\n\t                return eval(\"(\" + json + \")\");\n\t            }\n\t        };\n\t        qq.getExtension = function(filename) {\n\t            var extIdx = filename.lastIndexOf(\".\") + 1;\n\t            if (extIdx > 0) {\n\t                return filename.substr(extIdx, filename.length - extIdx);\n\t            }\n\t        };\n\t        qq.getFilename = function(blobOrFileInput) {\n\t            if (qq.isInput(blobOrFileInput)) {\n\t                return blobOrFileInput.value.replace(/.*(\\/|\\\\)/, \"\");\n\t            } else if (qq.isFile(blobOrFileInput)) {\n\t                if (blobOrFileInput.fileName !== null && blobOrFileInput.fileName !== undefined) {\n\t                    return blobOrFileInput.fileName;\n\t                }\n\t            }\n\t            return blobOrFileInput.name;\n\t        };\n\t        qq.DisposeSupport = function() {\n\t            var disposers = [];\n\t            return {\n\t                dispose: function() {\n\t                    var disposer;\n\t                    do {\n\t                        disposer = disposers.shift();\n\t                        if (disposer) {\n\t                            disposer();\n\t                        }\n\t                    } while (disposer);\n\t                },\n\t                attach: function() {\n\t                    var args = arguments;\n\t                    this.addDisposer(qq(args[0]).attach.apply(this, Array.prototype.slice.call(arguments, 1)));\n\t                },\n\t                addDisposer: function(disposeFunction) {\n\t                    disposers.push(disposeFunction);\n\t                }\n\t            };\n\t        };\n\t    })();\n\t    (function() {\n\t        \"use strict\";\n\t        if (true) {\n\t            !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t                return qq;\n\t            }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t        } else if (typeof module !== \"undefined\" && module.exports) {\n\t            module.exports = qq;\n\t        } else {\n\t            global.qq = qq;\n\t        }\n\t    })();\n\t    (function() {\n\t        \"use strict\";\n\t        qq.Error = function(message) {\n\t            this.message = \"[Fine Uploader \" + qq.version + \"] \" + message;\n\t        };\n\t        qq.Error.prototype = new Error();\n\t    })();\n\t    qq.version = \"5.11.10\";\n\t    qq.supportedFeatures = function() {\n\t        \"use strict\";\n\t        var supportsUploading, supportsUploadingBlobs, supportsFileDrop, supportsAjaxFileUploading, supportsFolderDrop, supportsChunking, supportsResume, supportsUploadViaPaste, supportsUploadCors, supportsDeleteFileXdr, supportsDeleteFileCorsXhr, supportsDeleteFileCors, supportsFolderSelection, supportsImagePreviews, supportsUploadProgress;\n\t        function testSupportsFileInputElement() {\n\t            var supported = true, tempInput;\n\t            try {\n\t                tempInput = document.createElement(\"input\");\n\t                tempInput.type = \"file\";\n\t                qq(tempInput).hide();\n\t                if (tempInput.disabled) {\n\t                    supported = false;\n\t                }\n\t            } catch (ex) {\n\t                supported = false;\n\t            }\n\t            return supported;\n\t        }\n\t        function isChrome21OrHigher() {\n\t            return (qq.chrome() || qq.opera()) && navigator.userAgent.match(/Chrome\\/[2][1-9]|Chrome\\/[3-9][0-9]/) !== undefined;\n\t        }\n\t        function isChrome14OrHigher() {\n\t            return (qq.chrome() || qq.opera()) && navigator.userAgent.match(/Chrome\\/[1][4-9]|Chrome\\/[2-9][0-9]/) !== undefined;\n\t        }\n\t        function isCrossOriginXhrSupported() {\n\t            if (window.XMLHttpRequest) {\n\t                var xhr = qq.createXhrInstance();\n\t                return xhr.withCredentials !== undefined;\n\t            }\n\t            return false;\n\t        }\n\t        function isXdrSupported() {\n\t            return window.XDomainRequest !== undefined;\n\t        }\n\t        function isCrossOriginAjaxSupported() {\n\t            if (isCrossOriginXhrSupported()) {\n\t                return true;\n\t            }\n\t            return isXdrSupported();\n\t        }\n\t        function isFolderSelectionSupported() {\n\t            return document.createElement(\"input\").webkitdirectory !== undefined;\n\t        }\n\t        function isLocalStorageSupported() {\n\t            try {\n\t                return !!window.localStorage && qq.isFunction(window.localStorage.setItem);\n\t            } catch (error) {\n\t                return false;\n\t            }\n\t        }\n\t        function isDragAndDropSupported() {\n\t            var span = document.createElement(\"span\");\n\t            return (\"draggable\" in span || \"ondragstart\" in span && \"ondrop\" in span) && !qq.android() && !qq.ios();\n\t        }\n\t        supportsUploading = testSupportsFileInputElement();\n\t        supportsAjaxFileUploading = supportsUploading && qq.isXhrUploadSupported();\n\t        supportsUploadingBlobs = supportsAjaxFileUploading && !qq.androidStock();\n\t        supportsFileDrop = supportsAjaxFileUploading && isDragAndDropSupported();\n\t        supportsFolderDrop = supportsFileDrop && isChrome21OrHigher();\n\t        supportsChunking = supportsAjaxFileUploading && qq.isFileChunkingSupported();\n\t        supportsResume = supportsAjaxFileUploading && supportsChunking && isLocalStorageSupported();\n\t        supportsUploadViaPaste = supportsAjaxFileUploading && isChrome14OrHigher();\n\t        supportsUploadCors = supportsUploading && (window.postMessage !== undefined || supportsAjaxFileUploading);\n\t        supportsDeleteFileCorsXhr = isCrossOriginXhrSupported();\n\t        supportsDeleteFileXdr = isXdrSupported();\n\t        supportsDeleteFileCors = isCrossOriginAjaxSupported();\n\t        supportsFolderSelection = isFolderSelectionSupported();\n\t        supportsImagePreviews = supportsAjaxFileUploading && window.FileReader !== undefined;\n\t        supportsUploadProgress = function() {\n\t            if (supportsAjaxFileUploading) {\n\t                return !qq.androidStock() && !qq.iosChrome();\n\t            }\n\t            return false;\n\t        }();\n\t        return {\n\t            ajaxUploading: supportsAjaxFileUploading,\n\t            blobUploading: supportsUploadingBlobs,\n\t            canDetermineSize: supportsAjaxFileUploading,\n\t            chunking: supportsChunking,\n\t            deleteFileCors: supportsDeleteFileCors,\n\t            deleteFileCorsXdr: supportsDeleteFileXdr,\n\t            deleteFileCorsXhr: supportsDeleteFileCorsXhr,\n\t            dialogElement: !!window.HTMLDialogElement,\n\t            fileDrop: supportsFileDrop,\n\t            folderDrop: supportsFolderDrop,\n\t            folderSelection: supportsFolderSelection,\n\t            imagePreviews: supportsImagePreviews,\n\t            imageValidation: supportsImagePreviews,\n\t            itemSizeValidation: supportsAjaxFileUploading,\n\t            pause: supportsChunking,\n\t            progressBar: supportsUploadProgress,\n\t            resume: supportsResume,\n\t            scaling: supportsImagePreviews && supportsUploadingBlobs,\n\t            tiffPreviews: qq.safari(),\n\t            unlimitedScaledImageSize: !qq.ios(),\n\t            uploading: supportsUploading,\n\t            uploadCors: supportsUploadCors,\n\t            uploadCustomHeaders: supportsAjaxFileUploading,\n\t            uploadNonMultipart: supportsAjaxFileUploading,\n\t            uploadViaPaste: supportsUploadViaPaste\n\t        };\n\t    }();\n\t    qq.isGenericPromise = function(maybePromise) {\n\t        \"use strict\";\n\t        return !!(maybePromise && maybePromise.then && qq.isFunction(maybePromise.then));\n\t    };\n\t    qq.Promise = function() {\n\t        \"use strict\";\n\t        var successArgs, failureArgs, successCallbacks = [], failureCallbacks = [], doneCallbacks = [], state = 0;\n\t        qq.extend(this, {\n\t            then: function(onSuccess, onFailure) {\n\t                if (state === 0) {\n\t                    if (onSuccess) {\n\t                        successCallbacks.push(onSuccess);\n\t                    }\n\t                    if (onFailure) {\n\t                        failureCallbacks.push(onFailure);\n\t                    }\n\t                } else if (state === -1) {\n\t                    onFailure && onFailure.apply(null, failureArgs);\n\t                } else if (onSuccess) {\n\t                    onSuccess.apply(null, successArgs);\n\t                }\n\t                return this;\n\t            },\n\t            done: function(callback) {\n\t                if (state === 0) {\n\t                    doneCallbacks.push(callback);\n\t                } else {\n\t                    callback.apply(null, failureArgs === undefined ? successArgs : failureArgs);\n\t                }\n\t                return this;\n\t            },\n\t            success: function() {\n\t                state = 1;\n\t                successArgs = arguments;\n\t                if (successCallbacks.length) {\n\t                    qq.each(successCallbacks, function(idx, callback) {\n\t                        callback.apply(null, successArgs);\n\t                    });\n\t                }\n\t                if (doneCallbacks.length) {\n\t                    qq.each(doneCallbacks, function(idx, callback) {\n\t                        callback.apply(null, successArgs);\n\t                    });\n\t                }\n\t                return this;\n\t            },\n\t            failure: function() {\n\t                state = -1;\n\t                failureArgs = arguments;\n\t                if (failureCallbacks.length) {\n\t                    qq.each(failureCallbacks, function(idx, callback) {\n\t                        callback.apply(null, failureArgs);\n\t                    });\n\t                }\n\t                if (doneCallbacks.length) {\n\t                    qq.each(doneCallbacks, function(idx, callback) {\n\t                        callback.apply(null, failureArgs);\n\t                    });\n\t                }\n\t                return this;\n\t            }\n\t        });\n\t    };\n\t    qq.BlobProxy = function(referenceBlob, onCreate) {\n\t        \"use strict\";\n\t        qq.extend(this, {\n\t            referenceBlob: referenceBlob,\n\t            create: function() {\n\t                return onCreate(referenceBlob);\n\t            }\n\t        });\n\t    };\n\t    qq.UploadButton = function(o) {\n\t        \"use strict\";\n\t        var self = this, disposeSupport = new qq.DisposeSupport(), options = {\n\t            acceptFiles: null,\n\t            element: null,\n\t            focusClass: \"qq-upload-button-focus\",\n\t            folders: false,\n\t            hoverClass: \"qq-upload-button-hover\",\n\t            ios8BrowserCrashWorkaround: false,\n\t            multiple: false,\n\t            name: \"qqfile\",\n\t            onChange: function(input) {},\n\t            title: null\n\t        }, input, buttonId;\n\t        qq.extend(options, o);\n\t        buttonId = qq.getUniqueId();\n\t        function createInput() {\n\t            var input = document.createElement(\"input\");\n\t            input.setAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME, buttonId);\n\t            input.setAttribute(\"title\", options.title);\n\t            self.setMultiple(options.multiple, input);\n\t            if (options.folders && qq.supportedFeatures.folderSelection) {\n\t                input.setAttribute(\"webkitdirectory\", \"\");\n\t            }\n\t            if (options.acceptFiles) {\n\t                input.setAttribute(\"accept\", options.acceptFiles);\n\t            }\n\t            input.setAttribute(\"type\", \"file\");\n\t            input.setAttribute(\"name\", options.name);\n\t            qq(input).css({\n\t                position: \"absolute\",\n\t                right: 0,\n\t                top: 0,\n\t                fontFamily: \"Arial\",\n\t                fontSize: qq.ie() && !qq.ie8() ? \"3500px\" : \"118px\",\n\t                margin: 0,\n\t                padding: 0,\n\t                cursor: \"pointer\",\n\t                opacity: 0\n\t            });\n\t            !qq.ie7() && qq(input).css({\n\t                height: \"100%\"\n\t            });\n\t            options.element.appendChild(input);\n\t            disposeSupport.attach(input, \"change\", function() {\n\t                options.onChange(input);\n\t            });\n\t            disposeSupport.attach(input, \"mouseover\", function() {\n\t                qq(options.element).addClass(options.hoverClass);\n\t            });\n\t            disposeSupport.attach(input, \"mouseout\", function() {\n\t                qq(options.element).removeClass(options.hoverClass);\n\t            });\n\t            disposeSupport.attach(input, \"focus\", function() {\n\t                qq(options.element).addClass(options.focusClass);\n\t            });\n\t            disposeSupport.attach(input, \"blur\", function() {\n\t                qq(options.element).removeClass(options.focusClass);\n\t            });\n\t            return input;\n\t        }\n\t        qq(options.element).css({\n\t            position: \"relative\",\n\t            overflow: \"hidden\",\n\t            direction: \"ltr\"\n\t        });\n\t        qq.extend(this, {\n\t            getInput: function() {\n\t                return input;\n\t            },\n\t            getButtonId: function() {\n\t                return buttonId;\n\t            },\n\t            setMultiple: function(isMultiple, optInput) {\n\t                var input = optInput || this.getInput();\n\t                if (options.ios8BrowserCrashWorkaround && qq.ios8() && (qq.iosChrome() || qq.iosSafariWebView())) {\n\t                    input.setAttribute(\"multiple\", \"\");\n\t                } else {\n\t                    if (isMultiple) {\n\t                        input.setAttribute(\"multiple\", \"\");\n\t                    } else {\n\t                        input.removeAttribute(\"multiple\");\n\t                    }\n\t                }\n\t            },\n\t            setAcceptFiles: function(acceptFiles) {\n\t                if (acceptFiles !== options.acceptFiles) {\n\t                    input.setAttribute(\"accept\", acceptFiles);\n\t                }\n\t            },\n\t            reset: function() {\n\t                if (input.parentNode) {\n\t                    qq(input).remove();\n\t                }\n\t                qq(options.element).removeClass(options.focusClass);\n\t                input = null;\n\t                input = createInput();\n\t            }\n\t        });\n\t        input = createInput();\n\t    };\n\t    qq.UploadButton.BUTTON_ID_ATTR_NAME = \"qq-button-id\";\n\t    qq.UploadData = function(uploaderProxy) {\n\t        \"use strict\";\n\t        var data = [], byUuid = {}, byStatus = {}, byProxyGroupId = {}, byBatchId = {};\n\t        function getDataByIds(idOrIds) {\n\t            if (qq.isArray(idOrIds)) {\n\t                var entries = [];\n\t                qq.each(idOrIds, function(idx, id) {\n\t                    entries.push(data[id]);\n\t                });\n\t                return entries;\n\t            }\n\t            return data[idOrIds];\n\t        }\n\t        function getDataByUuids(uuids) {\n\t            if (qq.isArray(uuids)) {\n\t                var entries = [];\n\t                qq.each(uuids, function(idx, uuid) {\n\t                    entries.push(data[byUuid[uuid]]);\n\t                });\n\t                return entries;\n\t            }\n\t            return data[byUuid[uuids]];\n\t        }\n\t        function getDataByStatus(status) {\n\t            var statusResults = [], statuses = [].concat(status);\n\t            qq.each(statuses, function(index, statusEnum) {\n\t                var statusResultIndexes = byStatus[statusEnum];\n\t                if (statusResultIndexes !== undefined) {\n\t                    qq.each(statusResultIndexes, function(i, dataIndex) {\n\t                        statusResults.push(data[dataIndex]);\n\t                    });\n\t                }\n\t            });\n\t            return statusResults;\n\t        }\n\t        qq.extend(this, {\n\t            addFile: function(spec) {\n\t                var status = spec.status || qq.status.SUBMITTING, id = data.push({\n\t                    name: spec.name,\n\t                    originalName: spec.name,\n\t                    uuid: spec.uuid,\n\t                    size: spec.size == null ? -1 : spec.size,\n\t                    status: status\n\t                }) - 1;\n\t                if (spec.batchId) {\n\t                    data[id].batchId = spec.batchId;\n\t                    if (byBatchId[spec.batchId] === undefined) {\n\t                        byBatchId[spec.batchId] = [];\n\t                    }\n\t                    byBatchId[spec.batchId].push(id);\n\t                }\n\t                if (spec.proxyGroupId) {\n\t                    data[id].proxyGroupId = spec.proxyGroupId;\n\t                    if (byProxyGroupId[spec.proxyGroupId] === undefined) {\n\t                        byProxyGroupId[spec.proxyGroupId] = [];\n\t                    }\n\t                    byProxyGroupId[spec.proxyGroupId].push(id);\n\t                }\n\t                data[id].id = id;\n\t                byUuid[spec.uuid] = id;\n\t                if (byStatus[status] === undefined) {\n\t                    byStatus[status] = [];\n\t                }\n\t                byStatus[status].push(id);\n\t                uploaderProxy.onStatusChange(id, null, status);\n\t                return id;\n\t            },\n\t            retrieve: function(optionalFilter) {\n\t                if (qq.isObject(optionalFilter) && data.length) {\n\t                    if (optionalFilter.id !== undefined) {\n\t                        return getDataByIds(optionalFilter.id);\n\t                    } else if (optionalFilter.uuid !== undefined) {\n\t                        return getDataByUuids(optionalFilter.uuid);\n\t                    } else if (optionalFilter.status) {\n\t                        return getDataByStatus(optionalFilter.status);\n\t                    }\n\t                } else {\n\t                    return qq.extend([], data, true);\n\t                }\n\t            },\n\t            reset: function() {\n\t                data = [];\n\t                byUuid = {};\n\t                byStatus = {};\n\t                byBatchId = {};\n\t            },\n\t            setStatus: function(id, newStatus) {\n\t                var oldStatus = data[id].status, byStatusOldStatusIndex = qq.indexOf(byStatus[oldStatus], id);\n\t                byStatus[oldStatus].splice(byStatusOldStatusIndex, 1);\n\t                data[id].status = newStatus;\n\t                if (byStatus[newStatus] === undefined) {\n\t                    byStatus[newStatus] = [];\n\t                }\n\t                byStatus[newStatus].push(id);\n\t                uploaderProxy.onStatusChange(id, oldStatus, newStatus);\n\t            },\n\t            uuidChanged: function(id, newUuid) {\n\t                var oldUuid = data[id].uuid;\n\t                data[id].uuid = newUuid;\n\t                byUuid[newUuid] = id;\n\t                delete byUuid[oldUuid];\n\t            },\n\t            updateName: function(id, newName) {\n\t                data[id].name = newName;\n\t            },\n\t            updateSize: function(id, newSize) {\n\t                data[id].size = newSize;\n\t            },\n\t            setParentId: function(targetId, parentId) {\n\t                data[targetId].parentId = parentId;\n\t            },\n\t            getIdsInProxyGroup: function(id) {\n\t                var proxyGroupId = data[id].proxyGroupId;\n\t                if (proxyGroupId) {\n\t                    return byProxyGroupId[proxyGroupId];\n\t                }\n\t                return [];\n\t            },\n\t            getIdsInBatch: function(id) {\n\t                var batchId = data[id].batchId;\n\t                return byBatchId[batchId];\n\t            }\n\t        });\n\t    };\n\t    qq.status = {\n\t        SUBMITTING: \"submitting\",\n\t        SUBMITTED: \"submitted\",\n\t        REJECTED: \"rejected\",\n\t        QUEUED: \"queued\",\n\t        CANCELED: \"canceled\",\n\t        PAUSED: \"paused\",\n\t        UPLOADING: \"uploading\",\n\t        UPLOAD_RETRYING: \"retrying upload\",\n\t        UPLOAD_SUCCESSFUL: \"upload successful\",\n\t        UPLOAD_FAILED: \"upload failed\",\n\t        DELETE_FAILED: \"delete failed\",\n\t        DELETING: \"deleting\",\n\t        DELETED: \"deleted\"\n\t    };\n\t    (function() {\n\t        \"use strict\";\n\t        qq.basePublicApi = {\n\t            addBlobs: function(blobDataOrArray, params, endpoint) {\n\t                this.addFiles(blobDataOrArray, params, endpoint);\n\t            },\n\t            addInitialFiles: function(cannedFileList) {\n\t                var self = this;\n\t                qq.each(cannedFileList, function(index, cannedFile) {\n\t                    self._addCannedFile(cannedFile);\n\t                });\n\t            },\n\t            addFiles: function(data, params, endpoint) {\n\t                this._maybeHandleIos8SafariWorkaround();\n\t                var batchId = this._storedIds.length === 0 ? qq.getUniqueId() : this._currentBatchId, processBlob = qq.bind(function(blob) {\n\t                    this._handleNewFile({\n\t                        blob: blob,\n\t                        name: this._options.blobs.defaultName\n\t                    }, batchId, verifiedFiles);\n\t                }, this), processBlobData = qq.bind(function(blobData) {\n\t                    this._handleNewFile(blobData, batchId, verifiedFiles);\n\t                }, this), processCanvas = qq.bind(function(canvas) {\n\t                    var blob = qq.canvasToBlob(canvas);\n\t                    this._handleNewFile({\n\t                        blob: blob,\n\t                        name: this._options.blobs.defaultName + \".png\"\n\t                    }, batchId, verifiedFiles);\n\t                }, this), processCanvasData = qq.bind(function(canvasData) {\n\t                    var normalizedQuality = canvasData.quality && canvasData.quality / 100, blob = qq.canvasToBlob(canvasData.canvas, canvasData.type, normalizedQuality);\n\t                    this._handleNewFile({\n\t                        blob: blob,\n\t                        name: canvasData.name\n\t                    }, batchId, verifiedFiles);\n\t                }, this), processFileOrInput = qq.bind(function(fileOrInput) {\n\t                    if (qq.isInput(fileOrInput) && qq.supportedFeatures.ajaxUploading) {\n\t                        var files = Array.prototype.slice.call(fileOrInput.files), self = this;\n\t                        qq.each(files, function(idx, file) {\n\t                            self._handleNewFile(file, batchId, verifiedFiles);\n\t                        });\n\t                    } else {\n\t                        this._handleNewFile(fileOrInput, batchId, verifiedFiles);\n\t                    }\n\t                }, this), normalizeData = function() {\n\t                    if (qq.isFileList(data)) {\n\t                        data = Array.prototype.slice.call(data);\n\t                    }\n\t                    data = [].concat(data);\n\t                }, self = this, verifiedFiles = [];\n\t                this._currentBatchId = batchId;\n\t                if (data) {\n\t                    normalizeData();\n\t                    qq.each(data, function(idx, fileContainer) {\n\t                        if (qq.isFileOrInput(fileContainer)) {\n\t                            processFileOrInput(fileContainer);\n\t                        } else if (qq.isBlob(fileContainer)) {\n\t                            processBlob(fileContainer);\n\t                        } else if (qq.isObject(fileContainer)) {\n\t                            if (fileContainer.blob && fileContainer.name) {\n\t                                processBlobData(fileContainer);\n\t                            } else if (fileContainer.canvas && fileContainer.name) {\n\t                                processCanvasData(fileContainer);\n\t                            }\n\t                        } else if (fileContainer.tagName && fileContainer.tagName.toLowerCase() === \"canvas\") {\n\t                            processCanvas(fileContainer);\n\t                        } else {\n\t                            self.log(fileContainer + \" is not a valid file container!  Ignoring!\", \"warn\");\n\t                        }\n\t                    });\n\t                    this.log(\"Received \" + verifiedFiles.length + \" files.\");\n\t                    this._prepareItemsForUpload(verifiedFiles, params, endpoint);\n\t                }\n\t            },\n\t            cancel: function(id) {\n\t                this._handler.cancel(id);\n\t            },\n\t            cancelAll: function() {\n\t                var storedIdsCopy = [], self = this;\n\t                qq.extend(storedIdsCopy, this._storedIds);\n\t                qq.each(storedIdsCopy, function(idx, storedFileId) {\n\t                    self.cancel(storedFileId);\n\t                });\n\t                this._handler.cancelAll();\n\t            },\n\t            clearStoredFiles: function() {\n\t                this._storedIds = [];\n\t            },\n\t            continueUpload: function(id) {\n\t                var uploadData = this._uploadData.retrieve({\n\t                    id: id\n\t                });\n\t                if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n\t                    return false;\n\t                }\n\t                if (uploadData.status === qq.status.PAUSED) {\n\t                    this.log(qq.format(\"Paused file ID {} ({}) will be continued.  Not paused.\", id, this.getName(id)));\n\t                    this._uploadFile(id);\n\t                    return true;\n\t                } else {\n\t                    this.log(qq.format(\"Ignoring continue for file ID {} ({}).  Not paused.\", id, this.getName(id)), \"error\");\n\t                }\n\t                return false;\n\t            },\n\t            deleteFile: function(id) {\n\t                return this._onSubmitDelete(id);\n\t            },\n\t            doesExist: function(fileOrBlobId) {\n\t                return this._handler.isValid(fileOrBlobId);\n\t            },\n\t            drawThumbnail: function(fileId, imgOrCanvas, maxSize, fromServer, customResizeFunction) {\n\t                var promiseToReturn = new qq.Promise(), fileOrUrl, options;\n\t                if (this._imageGenerator) {\n\t                    fileOrUrl = this._thumbnailUrls[fileId];\n\t                    options = {\n\t                        customResizeFunction: customResizeFunction,\n\t                        maxSize: maxSize > 0 ? maxSize : null,\n\t                        scale: maxSize > 0\n\t                    };\n\t                    if (!fromServer && qq.supportedFeatures.imagePreviews) {\n\t                        fileOrUrl = this.getFile(fileId);\n\t                    }\n\t                    if (fileOrUrl == null) {\n\t                        promiseToReturn.failure({\n\t                            container: imgOrCanvas,\n\t                            error: \"File or URL not found.\"\n\t                        });\n\t                    } else {\n\t                        this._imageGenerator.generate(fileOrUrl, imgOrCanvas, options).then(function success(modifiedContainer) {\n\t                            promiseToReturn.success(modifiedContainer);\n\t                        }, function failure(container, reason) {\n\t                            promiseToReturn.failure({\n\t                                container: container,\n\t                                error: reason || \"Problem generating thumbnail\"\n\t                            });\n\t                        });\n\t                    }\n\t                } else {\n\t                    promiseToReturn.failure({\n\t                        container: imgOrCanvas,\n\t                        error: \"Missing image generator module\"\n\t                    });\n\t                }\n\t                return promiseToReturn;\n\t            },\n\t            getButton: function(fileId) {\n\t                return this._getButton(this._buttonIdsForFileIds[fileId]);\n\t            },\n\t            getEndpoint: function(fileId) {\n\t                return this._endpointStore.get(fileId);\n\t            },\n\t            getFile: function(fileOrBlobId) {\n\t                return this._handler.getFile(fileOrBlobId) || null;\n\t            },\n\t            getInProgress: function() {\n\t                return this._uploadData.retrieve({\n\t                    status: [ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED ]\n\t                }).length;\n\t            },\n\t            getName: function(id) {\n\t                return this._uploadData.retrieve({\n\t                    id: id\n\t                }).name;\n\t            },\n\t            getParentId: function(id) {\n\t                var uploadDataEntry = this.getUploads({\n\t                    id: id\n\t                }), parentId = null;\n\t                if (uploadDataEntry) {\n\t                    if (uploadDataEntry.parentId !== undefined) {\n\t                        parentId = uploadDataEntry.parentId;\n\t                    }\n\t                }\n\t                return parentId;\n\t            },\n\t            getResumableFilesData: function() {\n\t                return this._handler.getResumableFilesData();\n\t            },\n\t            getSize: function(id) {\n\t                return this._uploadData.retrieve({\n\t                    id: id\n\t                }).size;\n\t            },\n\t            getNetUploads: function() {\n\t                return this._netUploaded;\n\t            },\n\t            getRemainingAllowedItems: function() {\n\t                var allowedItems = this._currentItemLimit;\n\t                if (allowedItems > 0) {\n\t                    return allowedItems - this._netUploadedOrQueued;\n\t                }\n\t                return null;\n\t            },\n\t            getUploads: function(optionalFilter) {\n\t                return this._uploadData.retrieve(optionalFilter);\n\t            },\n\t            getUuid: function(id) {\n\t                return this._uploadData.retrieve({\n\t                    id: id\n\t                }).uuid;\n\t            },\n\t            log: function(str, level) {\n\t                if (this._options.debug && (!level || level === \"info\")) {\n\t                    qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str);\n\t                } else if (level && level !== \"info\") {\n\t                    qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str, level);\n\t                }\n\t            },\n\t            pauseUpload: function(id) {\n\t                var uploadData = this._uploadData.retrieve({\n\t                    id: id\n\t                });\n\t                if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n\t                    return false;\n\t                }\n\t                if (qq.indexOf([ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING ], uploadData.status) >= 0) {\n\t                    if (this._handler.pause(id)) {\n\t                        this._uploadData.setStatus(id, qq.status.PAUSED);\n\t                        return true;\n\t                    } else {\n\t                        this.log(qq.format(\"Unable to pause file ID {} ({}).\", id, this.getName(id)), \"error\");\n\t                    }\n\t                } else {\n\t                    this.log(qq.format(\"Ignoring pause for file ID {} ({}).  Not in progress.\", id, this.getName(id)), \"error\");\n\t                }\n\t                return false;\n\t            },\n\t            reset: function() {\n\t                this.log(\"Resetting uploader...\");\n\t                this._handler.reset();\n\t                this._storedIds = [];\n\t                this._autoRetries = [];\n\t                this._retryTimeouts = [];\n\t                this._preventRetries = [];\n\t                this._thumbnailUrls = [];\n\t                qq.each(this._buttons, function(idx, button) {\n\t                    button.reset();\n\t                });\n\t                this._paramsStore.reset();\n\t                this._endpointStore.reset();\n\t                this._netUploadedOrQueued = 0;\n\t                this._netUploaded = 0;\n\t                this._uploadData.reset();\n\t                this._buttonIdsForFileIds = [];\n\t                this._pasteHandler && this._pasteHandler.reset();\n\t                this._options.session.refreshOnReset && this._refreshSessionData();\n\t                this._succeededSinceLastAllComplete = [];\n\t                this._failedSinceLastAllComplete = [];\n\t                this._totalProgress && this._totalProgress.reset();\n\t            },\n\t            retry: function(id) {\n\t                return this._manualRetry(id);\n\t            },\n\t            scaleImage: function(id, specs) {\n\t                var self = this;\n\t                return qq.Scaler.prototype.scaleImage(id, specs, {\n\t                    log: qq.bind(self.log, self),\n\t                    getFile: qq.bind(self.getFile, self),\n\t                    uploadData: self._uploadData\n\t                });\n\t            },\n\t            setCustomHeaders: function(headers, id) {\n\t                this._customHeadersStore.set(headers, id);\n\t            },\n\t            setDeleteFileCustomHeaders: function(headers, id) {\n\t                this._deleteFileCustomHeadersStore.set(headers, id);\n\t            },\n\t            setDeleteFileEndpoint: function(endpoint, id) {\n\t                this._deleteFileEndpointStore.set(endpoint, id);\n\t            },\n\t            setDeleteFileParams: function(params, id) {\n\t                this._deleteFileParamsStore.set(params, id);\n\t            },\n\t            setEndpoint: function(endpoint, id) {\n\t                this._endpointStore.set(endpoint, id);\n\t            },\n\t            setForm: function(elementOrId) {\n\t                this._updateFormSupportAndParams(elementOrId);\n\t            },\n\t            setItemLimit: function(newItemLimit) {\n\t                this._currentItemLimit = newItemLimit;\n\t            },\n\t            setName: function(id, newName) {\n\t                this._uploadData.updateName(id, newName);\n\t            },\n\t            setParams: function(params, id) {\n\t                this._paramsStore.set(params, id);\n\t            },\n\t            setUuid: function(id, newUuid) {\n\t                return this._uploadData.uuidChanged(id, newUuid);\n\t            },\n\t            uploadStoredFiles: function() {\n\t                if (this._storedIds.length === 0) {\n\t                    this._itemError(\"noFilesError\");\n\t                } else {\n\t                    this._uploadStoredFiles();\n\t                }\n\t            }\n\t        };\n\t        qq.basePrivateApi = {\n\t            _addCannedFile: function(sessionData) {\n\t                var id = this._uploadData.addFile({\n\t                    uuid: sessionData.uuid,\n\t                    name: sessionData.name,\n\t                    size: sessionData.size,\n\t                    status: qq.status.UPLOAD_SUCCESSFUL\n\t                });\n\t                sessionData.deleteFileEndpoint && this.setDeleteFileEndpoint(sessionData.deleteFileEndpoint, id);\n\t                sessionData.deleteFileParams && this.setDeleteFileParams(sessionData.deleteFileParams, id);\n\t                if (sessionData.thumbnailUrl) {\n\t                    this._thumbnailUrls[id] = sessionData.thumbnailUrl;\n\t                }\n\t                this._netUploaded++;\n\t                this._netUploadedOrQueued++;\n\t                return id;\n\t            },\n\t            _annotateWithButtonId: function(file, associatedInput) {\n\t                if (qq.isFile(file)) {\n\t                    file.qqButtonId = this._getButtonId(associatedInput);\n\t                }\n\t            },\n\t            _batchError: function(message) {\n\t                this._options.callbacks.onError(null, null, message, undefined);\n\t            },\n\t            _createDeleteHandler: function() {\n\t                var self = this;\n\t                return new qq.DeleteFileAjaxRequester({\n\t                    method: this._options.deleteFile.method.toUpperCase(),\n\t                    maxConnections: this._options.maxConnections,\n\t                    uuidParamName: this._options.request.uuidName,\n\t                    customHeaders: this._deleteFileCustomHeadersStore,\n\t                    paramsStore: this._deleteFileParamsStore,\n\t                    endpointStore: this._deleteFileEndpointStore,\n\t                    cors: this._options.cors,\n\t                    log: qq.bind(self.log, self),\n\t                    onDelete: function(id) {\n\t                        self._onDelete(id);\n\t                        self._options.callbacks.onDelete(id);\n\t                    },\n\t                    onDeleteComplete: function(id, xhrOrXdr, isError) {\n\t                        self._onDeleteComplete(id, xhrOrXdr, isError);\n\t                        self._options.callbacks.onDeleteComplete(id, xhrOrXdr, isError);\n\t                    }\n\t                });\n\t            },\n\t            _createPasteHandler: function() {\n\t                var self = this;\n\t                return new qq.PasteSupport({\n\t                    targetElement: this._options.paste.targetElement,\n\t                    callbacks: {\n\t                        log: qq.bind(self.log, self),\n\t                        pasteReceived: function(blob) {\n\t                            self._handleCheckedCallback({\n\t                                name: \"onPasteReceived\",\n\t                                callback: qq.bind(self._options.callbacks.onPasteReceived, self, blob),\n\t                                onSuccess: qq.bind(self._handlePasteSuccess, self, blob),\n\t                                identifier: \"pasted image\"\n\t                            });\n\t                        }\n\t                    }\n\t                });\n\t            },\n\t            _createStore: function(initialValue, _readOnlyValues_) {\n\t                var store = {}, catchall = initialValue, perIdReadOnlyValues = {}, readOnlyValues = _readOnlyValues_, copy = function(orig) {\n\t                    if (qq.isObject(orig)) {\n\t                        return qq.extend({}, orig);\n\t                    }\n\t                    return orig;\n\t                }, getReadOnlyValues = function() {\n\t                    if (qq.isFunction(readOnlyValues)) {\n\t                        return readOnlyValues();\n\t                    }\n\t                    return readOnlyValues;\n\t                }, includeReadOnlyValues = function(id, existing) {\n\t                    if (readOnlyValues && qq.isObject(existing)) {\n\t                        qq.extend(existing, getReadOnlyValues());\n\t                    }\n\t                    if (perIdReadOnlyValues[id]) {\n\t                        qq.extend(existing, perIdReadOnlyValues[id]);\n\t                    }\n\t                };\n\t                return {\n\t                    set: function(val, id) {\n\t                        if (id == null) {\n\t                            store = {};\n\t                            catchall = copy(val);\n\t                        } else {\n\t                            store[id] = copy(val);\n\t                        }\n\t                    },\n\t                    get: function(id) {\n\t                        var values;\n\t                        if (id != null && store[id]) {\n\t                            values = store[id];\n\t                        } else {\n\t                            values = copy(catchall);\n\t                        }\n\t                        includeReadOnlyValues(id, values);\n\t                        return copy(values);\n\t                    },\n\t                    addReadOnly: function(id, values) {\n\t                        if (qq.isObject(store)) {\n\t                            if (id === null) {\n\t                                if (qq.isFunction(values)) {\n\t                                    readOnlyValues = values;\n\t                                } else {\n\t                                    readOnlyValues = readOnlyValues || {};\n\t                                    qq.extend(readOnlyValues, values);\n\t                                }\n\t                            } else {\n\t                                perIdReadOnlyValues[id] = perIdReadOnlyValues[id] || {};\n\t                                qq.extend(perIdReadOnlyValues[id], values);\n\t                            }\n\t                        }\n\t                    },\n\t                    remove: function(fileId) {\n\t                        return delete store[fileId];\n\t                    },\n\t                    reset: function() {\n\t                        store = {};\n\t                        perIdReadOnlyValues = {};\n\t                        catchall = initialValue;\n\t                    }\n\t                };\n\t            },\n\t            _createUploadDataTracker: function() {\n\t                var self = this;\n\t                return new qq.UploadData({\n\t                    getName: function(id) {\n\t                        return self.getName(id);\n\t                    },\n\t                    getUuid: function(id) {\n\t                        return self.getUuid(id);\n\t                    },\n\t                    getSize: function(id) {\n\t                        return self.getSize(id);\n\t                    },\n\t                    onStatusChange: function(id, oldStatus, newStatus) {\n\t                        self._onUploadStatusChange(id, oldStatus, newStatus);\n\t                        self._options.callbacks.onStatusChange(id, oldStatus, newStatus);\n\t                        self._maybeAllComplete(id, newStatus);\n\t                        if (self._totalProgress) {\n\t                            setTimeout(function() {\n\t                                self._totalProgress.onStatusChange(id, oldStatus, newStatus);\n\t                            }, 0);\n\t                        }\n\t                    }\n\t                });\n\t            },\n\t            _createUploadButton: function(spec) {\n\t                var self = this, acceptFiles = spec.accept || this._options.validation.acceptFiles, allowedExtensions = spec.allowedExtensions || this._options.validation.allowedExtensions, button;\n\t                function allowMultiple() {\n\t                    if (qq.supportedFeatures.ajaxUploading) {\n\t                        if (self._options.workarounds.iosEmptyVideos && qq.ios() && !qq.ios6() && self._isAllowedExtension(allowedExtensions, \".mov\")) {\n\t                            return false;\n\t                        }\n\t                        if (spec.multiple === undefined) {\n\t                            return self._options.multiple;\n\t                        }\n\t                        return spec.multiple;\n\t                    }\n\t                    return false;\n\t                }\n\t                button = new qq.UploadButton({\n\t                    acceptFiles: acceptFiles,\n\t                    element: spec.element,\n\t                    focusClass: this._options.classes.buttonFocus,\n\t                    folders: spec.folders,\n\t                    hoverClass: this._options.classes.buttonHover,\n\t                    ios8BrowserCrashWorkaround: this._options.workarounds.ios8BrowserCrash,\n\t                    multiple: allowMultiple(),\n\t                    name: this._options.request.inputName,\n\t                    onChange: function(input) {\n\t                        self._onInputChange(input);\n\t                    },\n\t                    title: spec.title == null ? this._options.text.fileInputTitle : spec.title\n\t                });\n\t                this._disposeSupport.addDisposer(function() {\n\t                    button.dispose();\n\t                });\n\t                self._buttons.push(button);\n\t                return button;\n\t            },\n\t            _createUploadHandler: function(additionalOptions, namespace) {\n\t                var self = this, lastOnProgress = {}, options = {\n\t                    debug: this._options.debug,\n\t                    maxConnections: this._options.maxConnections,\n\t                    cors: this._options.cors,\n\t                    paramsStore: this._paramsStore,\n\t                    endpointStore: this._endpointStore,\n\t                    chunking: this._options.chunking,\n\t                    resume: this._options.resume,\n\t                    blobs: this._options.blobs,\n\t                    log: qq.bind(self.log, self),\n\t                    preventRetryParam: this._options.retry.preventRetryResponseProperty,\n\t                    onProgress: function(id, name, loaded, total) {\n\t                        if (loaded < 0 || total < 0) {\n\t                            return;\n\t                        }\n\t                        if (lastOnProgress[id]) {\n\t                            if (lastOnProgress[id].loaded !== loaded || lastOnProgress[id].total !== total) {\n\t                                self._onProgress(id, name, loaded, total);\n\t                                self._options.callbacks.onProgress(id, name, loaded, total);\n\t                            }\n\t                        } else {\n\t                            self._onProgress(id, name, loaded, total);\n\t                            self._options.callbacks.onProgress(id, name, loaded, total);\n\t                        }\n\t                        lastOnProgress[id] = {\n\t                            loaded: loaded,\n\t                            total: total\n\t                        };\n\t                    },\n\t                    onComplete: function(id, name, result, xhr) {\n\t                        delete lastOnProgress[id];\n\t                        var status = self.getUploads({\n\t                            id: id\n\t                        }).status, retVal;\n\t                        if (status === qq.status.UPLOAD_SUCCESSFUL || status === qq.status.UPLOAD_FAILED) {\n\t                            return;\n\t                        }\n\t                        retVal = self._onComplete(id, name, result, xhr);\n\t                        if (retVal instanceof qq.Promise) {\n\t                            retVal.done(function() {\n\t                                self._options.callbacks.onComplete(id, name, result, xhr);\n\t                            });\n\t                        } else {\n\t                            self._options.callbacks.onComplete(id, name, result, xhr);\n\t                        }\n\t                    },\n\t                    onCancel: function(id, name, cancelFinalizationEffort) {\n\t                        var promise = new qq.Promise();\n\t                        self._handleCheckedCallback({\n\t                            name: \"onCancel\",\n\t                            callback: qq.bind(self._options.callbacks.onCancel, self, id, name),\n\t                            onFailure: promise.failure,\n\t                            onSuccess: function() {\n\t                                cancelFinalizationEffort.then(function() {\n\t                                    self._onCancel(id, name);\n\t                                });\n\t                                promise.success();\n\t                            },\n\t                            identifier: id\n\t                        });\n\t                        return promise;\n\t                    },\n\t                    onUploadPrep: qq.bind(this._onUploadPrep, this),\n\t                    onUpload: function(id, name) {\n\t                        self._onUpload(id, name);\n\t                        self._options.callbacks.onUpload(id, name);\n\t                    },\n\t                    onUploadChunk: function(id, name, chunkData) {\n\t                        self._onUploadChunk(id, chunkData);\n\t                        self._options.callbacks.onUploadChunk(id, name, chunkData);\n\t                    },\n\t                    onUploadChunkSuccess: function(id, chunkData, result, xhr) {\n\t                        self._options.callbacks.onUploadChunkSuccess.apply(self, arguments);\n\t                    },\n\t                    onResume: function(id, name, chunkData) {\n\t                        return self._options.callbacks.onResume(id, name, chunkData);\n\t                    },\n\t                    onAutoRetry: function(id, name, responseJSON, xhr) {\n\t                        return self._onAutoRetry.apply(self, arguments);\n\t                    },\n\t                    onUuidChanged: function(id, newUuid) {\n\t                        self.log(\"Server requested UUID change from '\" + self.getUuid(id) + \"' to '\" + newUuid + \"'\");\n\t                        self.setUuid(id, newUuid);\n\t                    },\n\t                    getName: qq.bind(self.getName, self),\n\t                    getUuid: qq.bind(self.getUuid, self),\n\t                    getSize: qq.bind(self.getSize, self),\n\t                    setSize: qq.bind(self._setSize, self),\n\t                    getDataByUuid: function(uuid) {\n\t                        return self.getUploads({\n\t                            uuid: uuid\n\t                        });\n\t                    },\n\t                    isQueued: function(id) {\n\t                        var status = self.getUploads({\n\t                            id: id\n\t                        }).status;\n\t                        return status === qq.status.QUEUED || status === qq.status.SUBMITTED || status === qq.status.UPLOAD_RETRYING || status === qq.status.PAUSED;\n\t                    },\n\t                    getIdsInProxyGroup: self._uploadData.getIdsInProxyGroup,\n\t                    getIdsInBatch: self._uploadData.getIdsInBatch\n\t                };\n\t                qq.each(this._options.request, function(prop, val) {\n\t                    options[prop] = val;\n\t                });\n\t                options.customHeaders = this._customHeadersStore;\n\t                if (additionalOptions) {\n\t                    qq.each(additionalOptions, function(key, val) {\n\t                        options[key] = val;\n\t                    });\n\t                }\n\t                return new qq.UploadHandlerController(options, namespace);\n\t            },\n\t            _fileOrBlobRejected: function(id) {\n\t                this._netUploadedOrQueued--;\n\t                this._uploadData.setStatus(id, qq.status.REJECTED);\n\t            },\n\t            _formatSize: function(bytes) {\n\t                var i = -1;\n\t                do {\n\t                    bytes = bytes / 1e3;\n\t                    i++;\n\t                } while (bytes > 999);\n\t                return Math.max(bytes, .1).toFixed(1) + this._options.text.sizeSymbols[i];\n\t            },\n\t            _generateExtraButtonSpecs: function() {\n\t                var self = this;\n\t                this._extraButtonSpecs = {};\n\t                qq.each(this._options.extraButtons, function(idx, extraButtonOptionEntry) {\n\t                    var multiple = extraButtonOptionEntry.multiple, validation = qq.extend({}, self._options.validation, true), extraButtonSpec = qq.extend({}, extraButtonOptionEntry);\n\t                    if (multiple === undefined) {\n\t                        multiple = self._options.multiple;\n\t                    }\n\t                    if (extraButtonSpec.validation) {\n\t                        qq.extend(validation, extraButtonOptionEntry.validation, true);\n\t                    }\n\t                    qq.extend(extraButtonSpec, {\n\t                        multiple: multiple,\n\t                        validation: validation\n\t                    }, true);\n\t                    self._initExtraButton(extraButtonSpec);\n\t                });\n\t            },\n\t            _getButton: function(buttonId) {\n\t                var extraButtonsSpec = this._extraButtonSpecs[buttonId];\n\t                if (extraButtonsSpec) {\n\t                    return extraButtonsSpec.element;\n\t                } else if (buttonId === this._defaultButtonId) {\n\t                    return this._options.button;\n\t                }\n\t            },\n\t            _getButtonId: function(buttonOrFileInputOrFile) {\n\t                var inputs, fileInput, fileBlobOrInput = buttonOrFileInputOrFile;\n\t                if (fileBlobOrInput instanceof qq.BlobProxy) {\n\t                    fileBlobOrInput = fileBlobOrInput.referenceBlob;\n\t                }\n\t                if (fileBlobOrInput && !qq.isBlob(fileBlobOrInput)) {\n\t                    if (qq.isFile(fileBlobOrInput)) {\n\t                        return fileBlobOrInput.qqButtonId;\n\t                    } else if (fileBlobOrInput.tagName.toLowerCase() === \"input\" && fileBlobOrInput.type.toLowerCase() === \"file\") {\n\t                        return fileBlobOrInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n\t                    }\n\t                    inputs = fileBlobOrInput.getElementsByTagName(\"input\");\n\t                    qq.each(inputs, function(idx, input) {\n\t                        if (input.getAttribute(\"type\") === \"file\") {\n\t                            fileInput = input;\n\t                            return false;\n\t                        }\n\t                    });\n\t                    if (fileInput) {\n\t                        return fileInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n\t                    }\n\t                }\n\t            },\n\t            _getNotFinished: function() {\n\t                return this._uploadData.retrieve({\n\t                    status: [ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED, qq.status.SUBMITTING, qq.status.SUBMITTED, qq.status.PAUSED ]\n\t                }).length;\n\t            },\n\t            _getValidationBase: function(buttonId) {\n\t                var extraButtonSpec = this._extraButtonSpecs[buttonId];\n\t                return extraButtonSpec ? extraButtonSpec.validation : this._options.validation;\n\t            },\n\t            _getValidationDescriptor: function(fileWrapper) {\n\t                if (fileWrapper.file instanceof qq.BlobProxy) {\n\t                    return {\n\t                        name: qq.getFilename(fileWrapper.file.referenceBlob),\n\t                        size: fileWrapper.file.referenceBlob.size\n\t                    };\n\t                }\n\t                return {\n\t                    name: this.getUploads({\n\t                        id: fileWrapper.id\n\t                    }).name,\n\t                    size: this.getUploads({\n\t                        id: fileWrapper.id\n\t                    }).size\n\t                };\n\t            },\n\t            _getValidationDescriptors: function(fileWrappers) {\n\t                var self = this, fileDescriptors = [];\n\t                qq.each(fileWrappers, function(idx, fileWrapper) {\n\t                    fileDescriptors.push(self._getValidationDescriptor(fileWrapper));\n\t                });\n\t                return fileDescriptors;\n\t            },\n\t            _handleCameraAccess: function() {\n\t                if (this._options.camera.ios && qq.ios()) {\n\t                    var acceptIosCamera = \"image/*;capture=camera\", button = this._options.camera.button, buttonId = button ? this._getButtonId(button) : this._defaultButtonId, optionRoot = this._options;\n\t                    if (buttonId && buttonId !== this._defaultButtonId) {\n\t                        optionRoot = this._extraButtonSpecs[buttonId];\n\t                    }\n\t                    optionRoot.multiple = false;\n\t                    if (optionRoot.validation.acceptFiles === null) {\n\t                        optionRoot.validation.acceptFiles = acceptIosCamera;\n\t                    } else {\n\t                        optionRoot.validation.acceptFiles += \",\" + acceptIosCamera;\n\t                    }\n\t                    qq.each(this._buttons, function(idx, button) {\n\t                        if (button.getButtonId() === buttonId) {\n\t                            button.setMultiple(optionRoot.multiple);\n\t                            button.setAcceptFiles(optionRoot.acceptFiles);\n\t                            return false;\n\t                        }\n\t                    });\n\t                }\n\t            },\n\t            _handleCheckedCallback: function(details) {\n\t                var self = this, callbackRetVal = details.callback();\n\t                if (qq.isGenericPromise(callbackRetVal)) {\n\t                    this.log(details.name + \" - waiting for \" + details.name + \" promise to be fulfilled for \" + details.identifier);\n\t                    return callbackRetVal.then(function(successParam) {\n\t                        self.log(details.name + \" promise success for \" + details.identifier);\n\t                        details.onSuccess(successParam);\n\t                    }, function() {\n\t                        if (details.onFailure) {\n\t                            self.log(details.name + \" promise failure for \" + details.identifier);\n\t                            details.onFailure();\n\t                        } else {\n\t                            self.log(details.name + \" promise failure for \" + details.identifier);\n\t                        }\n\t                    });\n\t                }\n\t                if (callbackRetVal !== false) {\n\t                    details.onSuccess(callbackRetVal);\n\t                } else {\n\t                    if (details.onFailure) {\n\t                        this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Invoking failure callback.\");\n\t                        details.onFailure();\n\t                    } else {\n\t                        this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Will not proceed.\");\n\t                    }\n\t                }\n\t                return callbackRetVal;\n\t            },\n\t            _handleNewFile: function(file, batchId, newFileWrapperList) {\n\t                var self = this, uuid = qq.getUniqueId(), size = -1, name = qq.getFilename(file), actualFile = file.blob || file, handler = this._customNewFileHandler ? this._customNewFileHandler : qq.bind(self._handleNewFileGeneric, self);\n\t                if (!qq.isInput(actualFile) && actualFile.size >= 0) {\n\t                    size = actualFile.size;\n\t                }\n\t                handler(actualFile, name, uuid, size, newFileWrapperList, batchId, this._options.request.uuidName, {\n\t                    uploadData: self._uploadData,\n\t                    paramsStore: self._paramsStore,\n\t                    addFileToHandler: function(id, file) {\n\t                        self._handler.add(id, file);\n\t                        self._netUploadedOrQueued++;\n\t                        self._trackButton(id);\n\t                    }\n\t                });\n\t            },\n\t            _handleNewFileGeneric: function(file, name, uuid, size, fileList, batchId) {\n\t                var id = this._uploadData.addFile({\n\t                    uuid: uuid,\n\t                    name: name,\n\t                    size: size,\n\t                    batchId: batchId\n\t                });\n\t                this._handler.add(id, file);\n\t                this._trackButton(id);\n\t                this._netUploadedOrQueued++;\n\t                fileList.push({\n\t                    id: id,\n\t                    file: file\n\t                });\n\t            },\n\t            _handlePasteSuccess: function(blob, extSuppliedName) {\n\t                var extension = blob.type.split(\"/\")[1], name = extSuppliedName;\n\t                if (name == null) {\n\t                    name = this._options.paste.defaultName;\n\t                }\n\t                name += \".\" + extension;\n\t                this.addFiles({\n\t                    name: name,\n\t                    blob: blob\n\t                });\n\t            },\n\t            _initExtraButton: function(spec) {\n\t                var button = this._createUploadButton({\n\t                    accept: spec.validation.acceptFiles,\n\t                    allowedExtensions: spec.validation.allowedExtensions,\n\t                    element: spec.element,\n\t                    folders: spec.folders,\n\t                    multiple: spec.multiple,\n\t                    title: spec.fileInputTitle\n\t                });\n\t                this._extraButtonSpecs[button.getButtonId()] = spec;\n\t            },\n\t            _initFormSupportAndParams: function() {\n\t                this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n\t                if (this._formSupport && this._formSupport.attachedToForm) {\n\t                    this._paramsStore = this._createStore(this._options.request.params, this._formSupport.getFormInputsAsObject);\n\t                    this._options.autoUpload = this._formSupport.newAutoUpload;\n\t                    if (this._formSupport.newEndpoint) {\n\t                        this._options.request.endpoint = this._formSupport.newEndpoint;\n\t                    }\n\t                } else {\n\t                    this._paramsStore = this._createStore(this._options.request.params);\n\t                }\n\t            },\n\t            _isDeletePossible: function() {\n\t                if (!qq.DeleteFileAjaxRequester || !this._options.deleteFile.enabled) {\n\t                    return false;\n\t                }\n\t                if (this._options.cors.expected) {\n\t                    if (qq.supportedFeatures.deleteFileCorsXhr) {\n\t                        return true;\n\t                    }\n\t                    if (qq.supportedFeatures.deleteFileCorsXdr && this._options.cors.allowXdr) {\n\t                        return true;\n\t                    }\n\t                    return false;\n\t                }\n\t                return true;\n\t            },\n\t            _isAllowedExtension: function(allowed, fileName) {\n\t                var valid = false;\n\t                if (!allowed.length) {\n\t                    return true;\n\t                }\n\t                qq.each(allowed, function(idx, allowedExt) {\n\t                    if (qq.isString(allowedExt)) {\n\t                        var extRegex = new RegExp(\"\\\\.\" + allowedExt + \"$\", \"i\");\n\t                        if (fileName.match(extRegex) != null) {\n\t                            valid = true;\n\t                            return false;\n\t                        }\n\t                    }\n\t                });\n\t                return valid;\n\t            },\n\t            _itemError: function(code, maybeNameOrNames, item) {\n\t                var message = this._options.messages[code], allowedExtensions = [], names = [].concat(maybeNameOrNames), name = names[0], buttonId = this._getButtonId(item), validationBase = this._getValidationBase(buttonId), extensionsForMessage, placeholderMatch;\n\t                function r(name, replacement) {\n\t                    message = message.replace(name, replacement);\n\t                }\n\t                qq.each(validationBase.allowedExtensions, function(idx, allowedExtension) {\n\t                    if (qq.isString(allowedExtension)) {\n\t                        allowedExtensions.push(allowedExtension);\n\t                    }\n\t                });\n\t                extensionsForMessage = allowedExtensions.join(\", \").toLowerCase();\n\t                r(\"{file}\", this._options.formatFileName(name));\n\t                r(\"{extensions}\", extensionsForMessage);\n\t                r(\"{sizeLimit}\", this._formatSize(validationBase.sizeLimit));\n\t                r(\"{minSizeLimit}\", this._formatSize(validationBase.minSizeLimit));\n\t                placeholderMatch = message.match(/(\\{\\w+\\})/g);\n\t                if (placeholderMatch !== null) {\n\t                    qq.each(placeholderMatch, function(idx, placeholder) {\n\t                        r(placeholder, names[idx]);\n\t                    });\n\t                }\n\t                this._options.callbacks.onError(null, name, message, undefined);\n\t                return message;\n\t            },\n\t            _manualRetry: function(id, callback) {\n\t                if (this._onBeforeManualRetry(id)) {\n\t                    this._netUploadedOrQueued++;\n\t                    this._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n\t                    if (callback) {\n\t                        callback(id);\n\t                    } else {\n\t                        this._handler.retry(id);\n\t                    }\n\t                    return true;\n\t                }\n\t            },\n\t            _maybeAllComplete: function(id, status) {\n\t                var self = this, notFinished = this._getNotFinished();\n\t                if (status === qq.status.UPLOAD_SUCCESSFUL) {\n\t                    this._succeededSinceLastAllComplete.push(id);\n\t                } else if (status === qq.status.UPLOAD_FAILED) {\n\t                    this._failedSinceLastAllComplete.push(id);\n\t                }\n\t                if (notFinished === 0 && (this._succeededSinceLastAllComplete.length || this._failedSinceLastAllComplete.length)) {\n\t                    setTimeout(function() {\n\t                        self._onAllComplete(self._succeededSinceLastAllComplete, self._failedSinceLastAllComplete);\n\t                    }, 0);\n\t                }\n\t            },\n\t            _maybeHandleIos8SafariWorkaround: function() {\n\t                var self = this;\n\t                if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n\t                    setTimeout(function() {\n\t                        window.alert(self._options.messages.unsupportedBrowserIos8Safari);\n\t                    }, 0);\n\t                    throw new qq.Error(this._options.messages.unsupportedBrowserIos8Safari);\n\t                }\n\t            },\n\t            _maybeParseAndSendUploadError: function(id, name, response, xhr) {\n\t                if (!response.success) {\n\t                    if (xhr && xhr.status !== 200 && !response.error) {\n\t                        this._options.callbacks.onError(id, name, \"XHR returned response code \" + xhr.status, xhr);\n\t                    } else {\n\t                        var errorReason = response.error ? response.error : this._options.text.defaultResponseError;\n\t                        this._options.callbacks.onError(id, name, errorReason, xhr);\n\t                    }\n\t                }\n\t            },\n\t            _maybeProcessNextItemAfterOnValidateCallback: function(validItem, items, index, params, endpoint) {\n\t                var self = this;\n\t                if (items.length > index) {\n\t                    if (validItem || !this._options.validation.stopOnFirstInvalidFile) {\n\t                        setTimeout(function() {\n\t                            var validationDescriptor = self._getValidationDescriptor(items[index]), buttonId = self._getButtonId(items[index].file), button = self._getButton(buttonId);\n\t                            self._handleCheckedCallback({\n\t                                name: \"onValidate\",\n\t                                callback: qq.bind(self._options.callbacks.onValidate, self, validationDescriptor, button),\n\t                                onSuccess: qq.bind(self._onValidateCallbackSuccess, self, items, index, params, endpoint),\n\t                                onFailure: qq.bind(self._onValidateCallbackFailure, self, items, index, params, endpoint),\n\t                                identifier: \"Item '\" + validationDescriptor.name + \"', size: \" + validationDescriptor.size\n\t                            });\n\t                        }, 0);\n\t                    } else if (!validItem) {\n\t                        for (;index < items.length; index++) {\n\t                            self._fileOrBlobRejected(items[index].id);\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            _onAllComplete: function(successful, failed) {\n\t                this._totalProgress && this._totalProgress.onAllComplete(successful, failed, this._preventRetries);\n\t                this._options.callbacks.onAllComplete(qq.extend([], successful), qq.extend([], failed));\n\t                this._succeededSinceLastAllComplete = [];\n\t                this._failedSinceLastAllComplete = [];\n\t            },\n\t            _onAutoRetry: function(id, name, responseJSON, xhr, callback) {\n\t                var self = this;\n\t                self._preventRetries[id] = responseJSON[self._options.retry.preventRetryResponseProperty];\n\t                if (self._shouldAutoRetry(id, name, responseJSON)) {\n\t                    var retryWaitPeriod = self._options.retry.autoAttemptDelay * 1e3;\n\t                    self._maybeParseAndSendUploadError.apply(self, arguments);\n\t                    self._options.callbacks.onAutoRetry(id, name, self._autoRetries[id]);\n\t                    self._onBeforeAutoRetry(id, name);\n\t                    self._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n\t                    self._retryTimeouts[id] = setTimeout(function() {\n\t                        self.log(\"Starting retry for \" + name + \"...\");\n\t                        if (callback) {\n\t                            callback(id);\n\t                        } else {\n\t                            self._handler.retry(id);\n\t                        }\n\t                    }, retryWaitPeriod);\n\t                    return true;\n\t                }\n\t            },\n\t            _onBeforeAutoRetry: function(id, name) {\n\t                this.log(\"Waiting \" + this._options.retry.autoAttemptDelay + \" seconds before retrying \" + name + \"...\");\n\t            },\n\t            _onBeforeManualRetry: function(id) {\n\t                var itemLimit = this._currentItemLimit, fileName;\n\t                if (this._preventRetries[id]) {\n\t                    this.log(\"Retries are forbidden for id \" + id, \"warn\");\n\t                    return false;\n\t                } else if (this._handler.isValid(id)) {\n\t                    fileName = this.getName(id);\n\t                    if (this._options.callbacks.onManualRetry(id, fileName) === false) {\n\t                        return false;\n\t                    }\n\t                    if (itemLimit > 0 && this._netUploadedOrQueued + 1 > itemLimit) {\n\t                        this._itemError(\"retryFailTooManyItems\");\n\t                        return false;\n\t                    }\n\t                    this.log(\"Retrying upload for '\" + fileName + \"' (id: \" + id + \")...\");\n\t                    return true;\n\t                } else {\n\t                    this.log(\"'\" + id + \"' is not a valid file ID\", \"error\");\n\t                    return false;\n\t                }\n\t            },\n\t            _onCancel: function(id, name) {\n\t                this._netUploadedOrQueued--;\n\t                clearTimeout(this._retryTimeouts[id]);\n\t                var storedItemIndex = qq.indexOf(this._storedIds, id);\n\t                if (!this._options.autoUpload && storedItemIndex >= 0) {\n\t                    this._storedIds.splice(storedItemIndex, 1);\n\t                }\n\t                this._uploadData.setStatus(id, qq.status.CANCELED);\n\t            },\n\t            _onComplete: function(id, name, result, xhr) {\n\t                if (!result.success) {\n\t                    this._netUploadedOrQueued--;\n\t                    this._uploadData.setStatus(id, qq.status.UPLOAD_FAILED);\n\t                    if (result[this._options.retry.preventRetryResponseProperty] === true) {\n\t                        this._preventRetries[id] = true;\n\t                    }\n\t                } else {\n\t                    if (result.thumbnailUrl) {\n\t                        this._thumbnailUrls[id] = result.thumbnailUrl;\n\t                    }\n\t                    this._netUploaded++;\n\t                    this._uploadData.setStatus(id, qq.status.UPLOAD_SUCCESSFUL);\n\t                }\n\t                this._maybeParseAndSendUploadError(id, name, result, xhr);\n\t                return result.success ? true : false;\n\t            },\n\t            _onDelete: function(id) {\n\t                this._uploadData.setStatus(id, qq.status.DELETING);\n\t            },\n\t            _onDeleteComplete: function(id, xhrOrXdr, isError) {\n\t                var name = this.getName(id);\n\t                if (isError) {\n\t                    this._uploadData.setStatus(id, qq.status.DELETE_FAILED);\n\t                    this.log(\"Delete request for '\" + name + \"' has failed.\", \"error\");\n\t                    if (xhrOrXdr.withCredentials === undefined) {\n\t                        this._options.callbacks.onError(id, name, \"Delete request failed\", xhrOrXdr);\n\t                    } else {\n\t                        this._options.callbacks.onError(id, name, \"Delete request failed with response code \" + xhrOrXdr.status, xhrOrXdr);\n\t                    }\n\t                } else {\n\t                    this._netUploadedOrQueued--;\n\t                    this._netUploaded--;\n\t                    this._handler.expunge(id);\n\t                    this._uploadData.setStatus(id, qq.status.DELETED);\n\t                    this.log(\"Delete request for '\" + name + \"' has succeeded.\");\n\t                }\n\t            },\n\t            _onInputChange: function(input) {\n\t                var fileIndex;\n\t                if (qq.supportedFeatures.ajaxUploading) {\n\t                    for (fileIndex = 0; fileIndex < input.files.length; fileIndex++) {\n\t                        this._annotateWithButtonId(input.files[fileIndex], input);\n\t                    }\n\t                    this.addFiles(input.files);\n\t                } else if (input.value.length > 0) {\n\t                    this.addFiles(input);\n\t                }\n\t                qq.each(this._buttons, function(idx, button) {\n\t                    button.reset();\n\t                });\n\t            },\n\t            _onProgress: function(id, name, loaded, total) {\n\t                this._totalProgress && this._totalProgress.onIndividualProgress(id, loaded, total);\n\t            },\n\t            _onSubmit: function(id, name) {},\n\t            _onSubmitCallbackSuccess: function(id, name) {\n\t                this._onSubmit.apply(this, arguments);\n\t                this._uploadData.setStatus(id, qq.status.SUBMITTED);\n\t                this._onSubmitted.apply(this, arguments);\n\t                if (this._options.autoUpload) {\n\t                    this._options.callbacks.onSubmitted.apply(this, arguments);\n\t                    this._uploadFile(id);\n\t                } else {\n\t                    this._storeForLater(id);\n\t                    this._options.callbacks.onSubmitted.apply(this, arguments);\n\t                }\n\t            },\n\t            _onSubmitDelete: function(id, onSuccessCallback, additionalMandatedParams) {\n\t                var uuid = this.getUuid(id), adjustedOnSuccessCallback;\n\t                if (onSuccessCallback) {\n\t                    adjustedOnSuccessCallback = qq.bind(onSuccessCallback, this, id, uuid, additionalMandatedParams);\n\t                }\n\t                if (this._isDeletePossible()) {\n\t                    this._handleCheckedCallback({\n\t                        name: \"onSubmitDelete\",\n\t                        callback: qq.bind(this._options.callbacks.onSubmitDelete, this, id),\n\t                        onSuccess: adjustedOnSuccessCallback || qq.bind(this._deleteHandler.sendDelete, this, id, uuid, additionalMandatedParams),\n\t                        identifier: id\n\t                    });\n\t                    return true;\n\t                } else {\n\t                    this.log(\"Delete request ignored for ID \" + id + \", delete feature is disabled or request not possible \" + \"due to CORS on a user agent that does not support pre-flighting.\", \"warn\");\n\t                    return false;\n\t                }\n\t            },\n\t            _onSubmitted: function(id) {},\n\t            _onTotalProgress: function(loaded, total) {\n\t                this._options.callbacks.onTotalProgress(loaded, total);\n\t            },\n\t            _onUploadPrep: function(id) {},\n\t            _onUpload: function(id, name) {\n\t                this._uploadData.setStatus(id, qq.status.UPLOADING);\n\t            },\n\t            _onUploadChunk: function(id, chunkData) {},\n\t            _onUploadStatusChange: function(id, oldStatus, newStatus) {\n\t                if (newStatus === qq.status.PAUSED) {\n\t                    clearTimeout(this._retryTimeouts[id]);\n\t                }\n\t            },\n\t            _onValidateBatchCallbackFailure: function(fileWrappers) {\n\t                var self = this;\n\t                qq.each(fileWrappers, function(idx, fileWrapper) {\n\t                    self._fileOrBlobRejected(fileWrapper.id);\n\t                });\n\t            },\n\t            _onValidateBatchCallbackSuccess: function(validationDescriptors, items, params, endpoint, button) {\n\t                var errorMessage, itemLimit = this._currentItemLimit, proposedNetFilesUploadedOrQueued = this._netUploadedOrQueued;\n\t                if (itemLimit === 0 || proposedNetFilesUploadedOrQueued <= itemLimit) {\n\t                    if (items.length > 0) {\n\t                        this._handleCheckedCallback({\n\t                            name: \"onValidate\",\n\t                            callback: qq.bind(this._options.callbacks.onValidate, this, validationDescriptors[0], button),\n\t                            onSuccess: qq.bind(this._onValidateCallbackSuccess, this, items, 0, params, endpoint),\n\t                            onFailure: qq.bind(this._onValidateCallbackFailure, this, items, 0, params, endpoint),\n\t                            identifier: \"Item '\" + items[0].file.name + \"', size: \" + items[0].file.size\n\t                        });\n\t                    } else {\n\t                        this._itemError(\"noFilesError\");\n\t                    }\n\t                } else {\n\t                    this._onValidateBatchCallbackFailure(items);\n\t                    errorMessage = this._options.messages.tooManyItemsError.replace(/\\{netItems\\}/g, proposedNetFilesUploadedOrQueued).replace(/\\{itemLimit\\}/g, itemLimit);\n\t                    this._batchError(errorMessage);\n\t                }\n\t            },\n\t            _onValidateCallbackFailure: function(items, index, params, endpoint) {\n\t                var nextIndex = index + 1;\n\t                this._fileOrBlobRejected(items[index].id, items[index].file.name);\n\t                this._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n\t            },\n\t            _onValidateCallbackSuccess: function(items, index, params, endpoint) {\n\t                var self = this, nextIndex = index + 1, validationDescriptor = this._getValidationDescriptor(items[index]);\n\t                this._validateFileOrBlobData(items[index], validationDescriptor).then(function() {\n\t                    self._upload(items[index].id, params, endpoint);\n\t                    self._maybeProcessNextItemAfterOnValidateCallback(true, items, nextIndex, params, endpoint);\n\t                }, function() {\n\t                    self._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n\t                });\n\t            },\n\t            _prepareItemsForUpload: function(items, params, endpoint) {\n\t                if (items.length === 0) {\n\t                    this._itemError(\"noFilesError\");\n\t                    return;\n\t                }\n\t                var validationDescriptors = this._getValidationDescriptors(items), buttonId = this._getButtonId(items[0].file), button = this._getButton(buttonId);\n\t                this._handleCheckedCallback({\n\t                    name: \"onValidateBatch\",\n\t                    callback: qq.bind(this._options.callbacks.onValidateBatch, this, validationDescriptors, button),\n\t                    onSuccess: qq.bind(this._onValidateBatchCallbackSuccess, this, validationDescriptors, items, params, endpoint, button),\n\t                    onFailure: qq.bind(this._onValidateBatchCallbackFailure, this, items),\n\t                    identifier: \"batch validation\"\n\t                });\n\t            },\n\t            _preventLeaveInProgress: function() {\n\t                var self = this;\n\t                this._disposeSupport.attach(window, \"beforeunload\", function(e) {\n\t                    if (self.getInProgress()) {\n\t                        e = e || window.event;\n\t                        e.returnValue = self._options.messages.onLeave;\n\t                        return self._options.messages.onLeave;\n\t                    }\n\t                });\n\t            },\n\t            _refreshSessionData: function() {\n\t                var self = this, options = this._options.session;\n\t                if (qq.Session && this._options.session.endpoint != null) {\n\t                    if (!this._session) {\n\t                        qq.extend(options, {\n\t                            cors: this._options.cors\n\t                        });\n\t                        options.log = qq.bind(this.log, this);\n\t                        options.addFileRecord = qq.bind(this._addCannedFile, this);\n\t                        this._session = new qq.Session(options);\n\t                    }\n\t                    setTimeout(function() {\n\t                        self._session.refresh().then(function(response, xhrOrXdr) {\n\t                            self._sessionRequestComplete();\n\t                            self._options.callbacks.onSessionRequestComplete(response, true, xhrOrXdr);\n\t                        }, function(response, xhrOrXdr) {\n\t                            self._options.callbacks.onSessionRequestComplete(response, false, xhrOrXdr);\n\t                        });\n\t                    }, 0);\n\t                }\n\t            },\n\t            _sessionRequestComplete: function() {},\n\t            _setSize: function(id, newSize) {\n\t                this._uploadData.updateSize(id, newSize);\n\t                this._totalProgress && this._totalProgress.onNewSize(id);\n\t            },\n\t            _shouldAutoRetry: function(id, name, responseJSON) {\n\t                var uploadData = this._uploadData.retrieve({\n\t                    id: id\n\t                });\n\t                if (!this._preventRetries[id] && this._options.retry.enableAuto && uploadData.status !== qq.status.PAUSED) {\n\t                    if (this._autoRetries[id] === undefined) {\n\t                        this._autoRetries[id] = 0;\n\t                    }\n\t                    if (this._autoRetries[id] < this._options.retry.maxAutoAttempts) {\n\t                        this._autoRetries[id] += 1;\n\t                        return true;\n\t                    }\n\t                }\n\t                return false;\n\t            },\n\t            _storeForLater: function(id) {\n\t                this._storedIds.push(id);\n\t            },\n\t            _trackButton: function(id) {\n\t                var buttonId;\n\t                if (qq.supportedFeatures.ajaxUploading) {\n\t                    buttonId = this._handler.getFile(id).qqButtonId;\n\t                } else {\n\t                    buttonId = this._getButtonId(this._handler.getInput(id));\n\t                }\n\t                if (buttonId) {\n\t                    this._buttonIdsForFileIds[id] = buttonId;\n\t                }\n\t            },\n\t            _updateFormSupportAndParams: function(formElementOrId) {\n\t                this._options.form.element = formElementOrId;\n\t                this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n\t                if (this._formSupport && this._formSupport.attachedToForm) {\n\t                    this._paramsStore.addReadOnly(null, this._formSupport.getFormInputsAsObject);\n\t                    this._options.autoUpload = this._formSupport.newAutoUpload;\n\t                    if (this._formSupport.newEndpoint) {\n\t                        this.setEndpoint(this._formSupport.newEndpoint);\n\t                    }\n\t                }\n\t            },\n\t            _upload: function(id, params, endpoint) {\n\t                var name = this.getName(id);\n\t                if (params) {\n\t                    this.setParams(params, id);\n\t                }\n\t                if (endpoint) {\n\t                    this.setEndpoint(endpoint, id);\n\t                }\n\t                this._handleCheckedCallback({\n\t                    name: \"onSubmit\",\n\t                    callback: qq.bind(this._options.callbacks.onSubmit, this, id, name),\n\t                    onSuccess: qq.bind(this._onSubmitCallbackSuccess, this, id, name),\n\t                    onFailure: qq.bind(this._fileOrBlobRejected, this, id, name),\n\t                    identifier: id\n\t                });\n\t            },\n\t            _uploadFile: function(id) {\n\t                if (!this._handler.upload(id)) {\n\t                    this._uploadData.setStatus(id, qq.status.QUEUED);\n\t                }\n\t            },\n\t            _uploadStoredFiles: function() {\n\t                var idToUpload, stillSubmitting, self = this;\n\t                while (this._storedIds.length) {\n\t                    idToUpload = this._storedIds.shift();\n\t                    this._uploadFile(idToUpload);\n\t                }\n\t                stillSubmitting = this.getUploads({\n\t                    status: qq.status.SUBMITTING\n\t                }).length;\n\t                if (stillSubmitting) {\n\t                    qq.log(\"Still waiting for \" + stillSubmitting + \" files to clear submit queue. Will re-parse stored IDs array shortly.\");\n\t                    setTimeout(function() {\n\t                        self._uploadStoredFiles();\n\t                    }, 1e3);\n\t                }\n\t            },\n\t            _validateFileOrBlobData: function(fileWrapper, validationDescriptor) {\n\t                var self = this, file = function() {\n\t                    if (fileWrapper.file instanceof qq.BlobProxy) {\n\t                        return fileWrapper.file.referenceBlob;\n\t                    }\n\t                    return fileWrapper.file;\n\t                }(), name = validationDescriptor.name, size = validationDescriptor.size, buttonId = this._getButtonId(fileWrapper.file), validationBase = this._getValidationBase(buttonId), validityChecker = new qq.Promise();\n\t                validityChecker.then(function() {}, function() {\n\t                    self._fileOrBlobRejected(fileWrapper.id, name);\n\t                });\n\t                if (qq.isFileOrInput(file) && !this._isAllowedExtension(validationBase.allowedExtensions, name)) {\n\t                    this._itemError(\"typeError\", name, file);\n\t                    return validityChecker.failure();\n\t                }\n\t                if (size === 0) {\n\t                    this._itemError(\"emptyError\", name, file);\n\t                    return validityChecker.failure();\n\t                }\n\t                if (size > 0 && validationBase.sizeLimit && size > validationBase.sizeLimit) {\n\t                    this._itemError(\"sizeError\", name, file);\n\t                    return validityChecker.failure();\n\t                }\n\t                if (size > 0 && size < validationBase.minSizeLimit) {\n\t                    this._itemError(\"minSizeError\", name, file);\n\t                    return validityChecker.failure();\n\t                }\n\t                if (qq.ImageValidation && qq.supportedFeatures.imagePreviews && qq.isFile(file)) {\n\t                    new qq.ImageValidation(file, qq.bind(self.log, self)).validate(validationBase.image).then(validityChecker.success, function(errorCode) {\n\t                        self._itemError(errorCode + \"ImageError\", name, file);\n\t                        validityChecker.failure();\n\t                    });\n\t                } else {\n\t                    validityChecker.success();\n\t                }\n\t                return validityChecker;\n\t            },\n\t            _wrapCallbacks: function() {\n\t                var self, safeCallback, prop;\n\t                self = this;\n\t                safeCallback = function(name, callback, args) {\n\t                    var errorMsg;\n\t                    try {\n\t                        return callback.apply(self, args);\n\t                    } catch (exception) {\n\t                        errorMsg = exception.message || exception.toString();\n\t                        self.log(\"Caught exception in '\" + name + \"' callback - \" + errorMsg, \"error\");\n\t                    }\n\t                };\n\t                for (prop in this._options.callbacks) {\n\t                    (function() {\n\t                        var callbackName, callbackFunc;\n\t                        callbackName = prop;\n\t                        callbackFunc = self._options.callbacks[callbackName];\n\t                        self._options.callbacks[callbackName] = function() {\n\t                            return safeCallback(callbackName, callbackFunc, arguments);\n\t                        };\n\t                    })();\n\t                }\n\t            }\n\t        };\n\t    })();\n\t    (function() {\n\t        \"use strict\";\n\t        qq.FineUploaderBasic = function(o) {\n\t            var self = this;\n\t            this._options = {\n\t                debug: false,\n\t                button: null,\n\t                multiple: true,\n\t                maxConnections: 3,\n\t                disableCancelForFormUploads: false,\n\t                autoUpload: true,\n\t                request: {\n\t                    customHeaders: {},\n\t                    endpoint: \"/server/upload\",\n\t                    filenameParam: \"qqfilename\",\n\t                    forceMultipart: true,\n\t                    inputName: \"qqfile\",\n\t                    method: \"POST\",\n\t                    params: {},\n\t                    paramsInBody: true,\n\t                    totalFileSizeName: \"qqtotalfilesize\",\n\t                    uuidName: \"qquuid\"\n\t                },\n\t                validation: {\n\t                    allowedExtensions: [],\n\t                    sizeLimit: 0,\n\t                    minSizeLimit: 0,\n\t                    itemLimit: 0,\n\t                    stopOnFirstInvalidFile: true,\n\t                    acceptFiles: null,\n\t                    image: {\n\t                        maxHeight: 0,\n\t                        maxWidth: 0,\n\t                        minHeight: 0,\n\t                        minWidth: 0\n\t                    }\n\t                },\n\t                callbacks: {\n\t                    onSubmit: function(id, name) {},\n\t                    onSubmitted: function(id, name) {},\n\t                    onComplete: function(id, name, responseJSON, maybeXhr) {},\n\t                    onAllComplete: function(successful, failed) {},\n\t                    onCancel: function(id, name) {},\n\t                    onUpload: function(id, name) {},\n\t                    onUploadChunk: function(id, name, chunkData) {},\n\t                    onUploadChunkSuccess: function(id, chunkData, responseJSON, xhr) {},\n\t                    onResume: function(id, fileName, chunkData) {},\n\t                    onProgress: function(id, name, loaded, total) {},\n\t                    onTotalProgress: function(loaded, total) {},\n\t                    onError: function(id, name, reason, maybeXhrOrXdr) {},\n\t                    onAutoRetry: function(id, name, attemptNumber) {},\n\t                    onManualRetry: function(id, name) {},\n\t                    onValidateBatch: function(fileOrBlobData) {},\n\t                    onValidate: function(fileOrBlobData) {},\n\t                    onSubmitDelete: function(id) {},\n\t                    onDelete: function(id) {},\n\t                    onDeleteComplete: function(id, xhrOrXdr, isError) {},\n\t                    onPasteReceived: function(blob) {},\n\t                    onStatusChange: function(id, oldStatus, newStatus) {},\n\t                    onSessionRequestComplete: function(response, success, xhrOrXdr) {}\n\t                },\n\t                messages: {\n\t                    typeError: \"{file} has an invalid extension. Valid extension(s): {extensions}.\",\n\t                    sizeError: \"{file} is too large, maximum file size is {sizeLimit}.\",\n\t                    minSizeError: \"{file} is too small, minimum file size is {minSizeLimit}.\",\n\t                    emptyError: \"{file} is empty, please select files again without it.\",\n\t                    noFilesError: \"No files to upload.\",\n\t                    tooManyItemsError: \"Too many items ({netItems}) would be uploaded.  Item limit is {itemLimit}.\",\n\t                    maxHeightImageError: \"Image is too tall.\",\n\t                    maxWidthImageError: \"Image is too wide.\",\n\t                    minHeightImageError: \"Image is not tall enough.\",\n\t                    minWidthImageError: \"Image is not wide enough.\",\n\t                    retryFailTooManyItems: \"Retry failed - you have reached your file limit.\",\n\t                    onLeave: \"The files are being uploaded, if you leave now the upload will be canceled.\",\n\t                    unsupportedBrowserIos8Safari: \"Unrecoverable error - this browser does not permit file uploading of any kind due to serious bugs in iOS8 Safari.  Please use iOS8 Chrome until Apple fixes these issues.\"\n\t                },\n\t                retry: {\n\t                    enableAuto: false,\n\t                    maxAutoAttempts: 3,\n\t                    autoAttemptDelay: 5,\n\t                    preventRetryResponseProperty: \"preventRetry\"\n\t                },\n\t                classes: {\n\t                    buttonHover: \"qq-upload-button-hover\",\n\t                    buttonFocus: \"qq-upload-button-focus\"\n\t                },\n\t                chunking: {\n\t                    enabled: false,\n\t                    concurrent: {\n\t                        enabled: false\n\t                    },\n\t                    mandatory: false,\n\t                    paramNames: {\n\t                        partIndex: \"qqpartindex\",\n\t                        partByteOffset: \"qqpartbyteoffset\",\n\t                        chunkSize: \"qqchunksize\",\n\t                        totalFileSize: \"qqtotalfilesize\",\n\t                        totalParts: \"qqtotalparts\"\n\t                    },\n\t                    partSize: 2e6,\n\t                    success: {\n\t                        endpoint: null\n\t                    }\n\t                },\n\t                resume: {\n\t                    enabled: false,\n\t                    recordsExpireIn: 7,\n\t                    paramNames: {\n\t                        resuming: \"qqresume\"\n\t                    }\n\t                },\n\t                formatFileName: function(fileOrBlobName) {\n\t                    return fileOrBlobName;\n\t                },\n\t                text: {\n\t                    defaultResponseError: \"Upload failure reason unknown\",\n\t                    fileInputTitle: \"file input\",\n\t                    sizeSymbols: [ \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\" ]\n\t                },\n\t                deleteFile: {\n\t                    enabled: false,\n\t                    method: \"DELETE\",\n\t                    endpoint: \"/server/upload\",\n\t                    customHeaders: {},\n\t                    params: {}\n\t                },\n\t                cors: {\n\t                    expected: false,\n\t                    sendCredentials: false,\n\t                    allowXdr: false\n\t                },\n\t                blobs: {\n\t                    defaultName: \"misc_data\"\n\t                },\n\t                paste: {\n\t                    targetElement: null,\n\t                    defaultName: \"pasted_image\"\n\t                },\n\t                camera: {\n\t                    ios: false,\n\t                    button: null\n\t                },\n\t                extraButtons: [],\n\t                session: {\n\t                    endpoint: null,\n\t                    params: {},\n\t                    customHeaders: {},\n\t                    refreshOnReset: true\n\t                },\n\t                form: {\n\t                    element: \"qq-form\",\n\t                    autoUpload: false,\n\t                    interceptSubmit: true\n\t                },\n\t                scaling: {\n\t                    customResizer: null,\n\t                    sendOriginal: true,\n\t                    orient: true,\n\t                    defaultType: null,\n\t                    defaultQuality: 80,\n\t                    failureText: \"Failed to scale\",\n\t                    includeExif: false,\n\t                    sizes: []\n\t                },\n\t                workarounds: {\n\t                    iosEmptyVideos: true,\n\t                    ios8SafariUploads: true,\n\t                    ios8BrowserCrash: false\n\t                }\n\t            };\n\t            qq.extend(this._options, o, true);\n\t            this._buttons = [];\n\t            this._extraButtonSpecs = {};\n\t            this._buttonIdsForFileIds = [];\n\t            this._wrapCallbacks();\n\t            this._disposeSupport = new qq.DisposeSupport();\n\t            this._storedIds = [];\n\t            this._autoRetries = [];\n\t            this._retryTimeouts = [];\n\t            this._preventRetries = [];\n\t            this._thumbnailUrls = [];\n\t            this._netUploadedOrQueued = 0;\n\t            this._netUploaded = 0;\n\t            this._uploadData = this._createUploadDataTracker();\n\t            this._initFormSupportAndParams();\n\t            this._customHeadersStore = this._createStore(this._options.request.customHeaders);\n\t            this._deleteFileCustomHeadersStore = this._createStore(this._options.deleteFile.customHeaders);\n\t            this._deleteFileParamsStore = this._createStore(this._options.deleteFile.params);\n\t            this._endpointStore = this._createStore(this._options.request.endpoint);\n\t            this._deleteFileEndpointStore = this._createStore(this._options.deleteFile.endpoint);\n\t            this._handler = this._createUploadHandler();\n\t            this._deleteHandler = qq.DeleteFileAjaxRequester && this._createDeleteHandler();\n\t            if (this._options.button) {\n\t                this._defaultButtonId = this._createUploadButton({\n\t                    element: this._options.button,\n\t                    title: this._options.text.fileInputTitle\n\t                }).getButtonId();\n\t            }\n\t            this._generateExtraButtonSpecs();\n\t            this._handleCameraAccess();\n\t            if (this._options.paste.targetElement) {\n\t                if (qq.PasteSupport) {\n\t                    this._pasteHandler = this._createPasteHandler();\n\t                } else {\n\t                    this.log(\"Paste support module not found\", \"error\");\n\t                }\n\t            }\n\t            this._preventLeaveInProgress();\n\t            this._imageGenerator = qq.ImageGenerator && new qq.ImageGenerator(qq.bind(this.log, this));\n\t            this._refreshSessionData();\n\t            this._succeededSinceLastAllComplete = [];\n\t            this._failedSinceLastAllComplete = [];\n\t            this._scaler = qq.Scaler && new qq.Scaler(this._options.scaling, qq.bind(this.log, this)) || {};\n\t            if (this._scaler.enabled) {\n\t                this._customNewFileHandler = qq.bind(this._scaler.handleNewFile, this._scaler);\n\t            }\n\t            if (qq.TotalProgress && qq.supportedFeatures.progressBar) {\n\t                this._totalProgress = new qq.TotalProgress(qq.bind(this._onTotalProgress, this), function(id) {\n\t                    var entry = self._uploadData.retrieve({\n\t                        id: id\n\t                    });\n\t                    return entry && entry.size || 0;\n\t                });\n\t            }\n\t            this._currentItemLimit = this._options.validation.itemLimit;\n\t        };\n\t        qq.FineUploaderBasic.prototype = qq.basePublicApi;\n\t        qq.extend(qq.FineUploaderBasic.prototype, qq.basePrivateApi);\n\t    })();\n\t    qq.AjaxRequester = function(o) {\n\t        \"use strict\";\n\t        var log, shouldParamsBeInQueryString, queue = [], requestData = {}, options = {\n\t            acceptHeader: null,\n\t            validMethods: [ \"PATCH\", \"POST\", \"PUT\" ],\n\t            method: \"POST\",\n\t            contentType: \"application/x-www-form-urlencoded\",\n\t            maxConnections: 3,\n\t            customHeaders: {},\n\t            endpointStore: {},\n\t            paramsStore: {},\n\t            mandatedParams: {},\n\t            allowXRequestedWithAndCacheControl: true,\n\t            successfulResponseCodes: {\n\t                DELETE: [ 200, 202, 204 ],\n\t                PATCH: [ 200, 201, 202, 203, 204 ],\n\t                POST: [ 200, 201, 202, 203, 204 ],\n\t                PUT: [ 200, 201, 202, 203, 204 ],\n\t                GET: [ 200 ]\n\t            },\n\t            cors: {\n\t                expected: false,\n\t                sendCredentials: false\n\t            },\n\t            log: function(str, level) {},\n\t            onSend: function(id) {},\n\t            onComplete: function(id, xhrOrXdr, isError) {},\n\t            onProgress: null\n\t        };\n\t        qq.extend(options, o);\n\t        log = options.log;\n\t        if (qq.indexOf(options.validMethods, options.method) < 0) {\n\t            throw new Error(\"'\" + options.method + \"' is not a supported method for this type of request!\");\n\t        }\n\t        function isSimpleMethod() {\n\t            return qq.indexOf([ \"GET\", \"POST\", \"HEAD\" ], options.method) >= 0;\n\t        }\n\t        function containsNonSimpleHeaders(headers) {\n\t            var containsNonSimple = false;\n\t            qq.each(containsNonSimple, function(idx, header) {\n\t                if (qq.indexOf([ \"Accept\", \"Accept-Language\", \"Content-Language\", \"Content-Type\" ], header) < 0) {\n\t                    containsNonSimple = true;\n\t                    return false;\n\t                }\n\t            });\n\t            return containsNonSimple;\n\t        }\n\t        function isXdr(xhr) {\n\t            return options.cors.expected && xhr.withCredentials === undefined;\n\t        }\n\t        function getCorsAjaxTransport() {\n\t            var xhrOrXdr;\n\t            if (window.XMLHttpRequest || window.ActiveXObject) {\n\t                xhrOrXdr = qq.createXhrInstance();\n\t                if (xhrOrXdr.withCredentials === undefined) {\n\t                    xhrOrXdr = new XDomainRequest();\n\t                    xhrOrXdr.onload = function() {};\n\t                    xhrOrXdr.onerror = function() {};\n\t                    xhrOrXdr.ontimeout = function() {};\n\t                    xhrOrXdr.onprogress = function() {};\n\t                }\n\t            }\n\t            return xhrOrXdr;\n\t        }\n\t        function getXhrOrXdr(id, suppliedXhr) {\n\t            var xhrOrXdr = requestData[id].xhr;\n\t            if (!xhrOrXdr) {\n\t                if (suppliedXhr) {\n\t                    xhrOrXdr = suppliedXhr;\n\t                } else {\n\t                    if (options.cors.expected) {\n\t                        xhrOrXdr = getCorsAjaxTransport();\n\t                    } else {\n\t                        xhrOrXdr = qq.createXhrInstance();\n\t                    }\n\t                }\n\t                requestData[id].xhr = xhrOrXdr;\n\t            }\n\t            return xhrOrXdr;\n\t        }\n\t        function dequeue(id) {\n\t            var i = qq.indexOf(queue, id), max = options.maxConnections, nextId;\n\t            delete requestData[id];\n\t            queue.splice(i, 1);\n\t            if (queue.length >= max && i < max) {\n\t                nextId = queue[max - 1];\n\t                sendRequest(nextId);\n\t            }\n\t        }\n\t        function onComplete(id, xdrError) {\n\t            var xhr = getXhrOrXdr(id), method = options.method, isError = xdrError === true;\n\t            dequeue(id);\n\t            if (isError) {\n\t                log(method + \" request for \" + id + \" has failed\", \"error\");\n\t            } else if (!isXdr(xhr) && !isResponseSuccessful(xhr.status)) {\n\t                isError = true;\n\t                log(method + \" request for \" + id + \" has failed - response code \" + xhr.status, \"error\");\n\t            }\n\t            options.onComplete(id, xhr, isError);\n\t        }\n\t        function getParams(id) {\n\t            var onDemandParams = requestData[id].additionalParams, mandatedParams = options.mandatedParams, params;\n\t            if (options.paramsStore.get) {\n\t                params = options.paramsStore.get(id);\n\t            }\n\t            if (onDemandParams) {\n\t                qq.each(onDemandParams, function(name, val) {\n\t                    params = params || {};\n\t                    params[name] = val;\n\t                });\n\t            }\n\t            if (mandatedParams) {\n\t                qq.each(mandatedParams, function(name, val) {\n\t                    params = params || {};\n\t                    params[name] = val;\n\t                });\n\t            }\n\t            return params;\n\t        }\n\t        function sendRequest(id, optXhr) {\n\t            var xhr = getXhrOrXdr(id, optXhr), method = options.method, params = getParams(id), payload = requestData[id].payload, url;\n\t            options.onSend(id);\n\t            url = createUrl(id, params, requestData[id].additionalQueryParams);\n\t            if (isXdr(xhr)) {\n\t                xhr.onload = getXdrLoadHandler(id);\n\t                xhr.onerror = getXdrErrorHandler(id);\n\t            } else {\n\t                xhr.onreadystatechange = getXhrReadyStateChangeHandler(id);\n\t            }\n\t            registerForUploadProgress(id);\n\t            xhr.open(method, url, true);\n\t            if (options.cors.expected && options.cors.sendCredentials && !isXdr(xhr)) {\n\t                xhr.withCredentials = true;\n\t            }\n\t            setHeaders(id);\n\t            log(\"Sending \" + method + \" request for \" + id);\n\t            if (payload) {\n\t                xhr.send(payload);\n\t            } else if (shouldParamsBeInQueryString || !params) {\n\t                xhr.send();\n\t            } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/x-www-form-urlencoded\") >= 0) {\n\t                xhr.send(qq.obj2url(params, \"\"));\n\t            } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/json\") >= 0) {\n\t                xhr.send(JSON.stringify(params));\n\t            } else {\n\t                xhr.send(params);\n\t            }\n\t            return xhr;\n\t        }\n\t        function createUrl(id, params, additionalQueryParams) {\n\t            var endpoint = options.endpointStore.get(id), addToPath = requestData[id].addToPath;\n\t            if (addToPath != undefined) {\n\t                endpoint += \"/\" + addToPath;\n\t            }\n\t            if (shouldParamsBeInQueryString && params) {\n\t                endpoint = qq.obj2url(params, endpoint);\n\t            }\n\t            if (additionalQueryParams) {\n\t                endpoint = qq.obj2url(additionalQueryParams, endpoint);\n\t            }\n\t            return endpoint;\n\t        }\n\t        function getXhrReadyStateChangeHandler(id) {\n\t            return function() {\n\t                if (getXhrOrXdr(id).readyState === 4) {\n\t                    onComplete(id);\n\t                }\n\t            };\n\t        }\n\t        function registerForUploadProgress(id) {\n\t            var onProgress = options.onProgress;\n\t            if (onProgress) {\n\t                getXhrOrXdr(id).upload.onprogress = function(e) {\n\t                    if (e.lengthComputable) {\n\t                        onProgress(id, e.loaded, e.total);\n\t                    }\n\t                };\n\t            }\n\t        }\n\t        function getXdrLoadHandler(id) {\n\t            return function() {\n\t                onComplete(id);\n\t            };\n\t        }\n\t        function getXdrErrorHandler(id) {\n\t            return function() {\n\t                onComplete(id, true);\n\t            };\n\t        }\n\t        function setHeaders(id) {\n\t            var xhr = getXhrOrXdr(id), customHeaders = options.customHeaders, onDemandHeaders = requestData[id].additionalHeaders || {}, method = options.method, allHeaders = {};\n\t            if (!isXdr(xhr)) {\n\t                options.acceptHeader && xhr.setRequestHeader(\"Accept\", options.acceptHeader);\n\t                if (options.allowXRequestedWithAndCacheControl) {\n\t                    if (!options.cors.expected || (!isSimpleMethod() || containsNonSimpleHeaders(customHeaders))) {\n\t                        xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n\t                        xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n\t                    }\n\t                }\n\t                if (options.contentType && (method === \"POST\" || method === \"PUT\")) {\n\t                    xhr.setRequestHeader(\"Content-Type\", options.contentType);\n\t                }\n\t                qq.extend(allHeaders, qq.isFunction(customHeaders) ? customHeaders(id) : customHeaders);\n\t                qq.extend(allHeaders, onDemandHeaders);\n\t                qq.each(allHeaders, function(name, val) {\n\t                    xhr.setRequestHeader(name, val);\n\t                });\n\t            }\n\t        }\n\t        function isResponseSuccessful(responseCode) {\n\t            return qq.indexOf(options.successfulResponseCodes[options.method], responseCode) >= 0;\n\t        }\n\t        function prepareToSend(id, optXhr, addToPath, additionalParams, additionalQueryParams, additionalHeaders, payload) {\n\t            requestData[id] = {\n\t                addToPath: addToPath,\n\t                additionalParams: additionalParams,\n\t                additionalQueryParams: additionalQueryParams,\n\t                additionalHeaders: additionalHeaders,\n\t                payload: payload\n\t            };\n\t            var len = queue.push(id);\n\t            if (len <= options.maxConnections) {\n\t                return sendRequest(id, optXhr);\n\t            }\n\t        }\n\t        shouldParamsBeInQueryString = options.method === \"GET\" || options.method === \"DELETE\";\n\t        qq.extend(this, {\n\t            initTransport: function(id) {\n\t                var path, params, headers, payload, cacheBuster, additionalQueryParams;\n\t                return {\n\t                    withPath: function(appendToPath) {\n\t                        path = appendToPath;\n\t                        return this;\n\t                    },\n\t                    withParams: function(additionalParams) {\n\t                        params = additionalParams;\n\t                        return this;\n\t                    },\n\t                    withQueryParams: function(_additionalQueryParams_) {\n\t                        additionalQueryParams = _additionalQueryParams_;\n\t                        return this;\n\t                    },\n\t                    withHeaders: function(additionalHeaders) {\n\t                        headers = additionalHeaders;\n\t                        return this;\n\t                    },\n\t                    withPayload: function(thePayload) {\n\t                        payload = thePayload;\n\t                        return this;\n\t                    },\n\t                    withCacheBuster: function() {\n\t                        cacheBuster = true;\n\t                        return this;\n\t                    },\n\t                    send: function(optXhr) {\n\t                        if (cacheBuster && qq.indexOf([ \"GET\", \"DELETE\" ], options.method) >= 0) {\n\t                            params.qqtimestamp = new Date().getTime();\n\t                        }\n\t                        return prepareToSend(id, optXhr, path, params, additionalQueryParams, headers, payload);\n\t                    }\n\t                };\n\t            },\n\t            canceled: function(id) {\n\t                dequeue(id);\n\t            }\n\t        });\n\t    };\n\t    qq.UploadHandler = function(spec) {\n\t        \"use strict\";\n\t        var proxy = spec.proxy, fileState = {}, onCancel = proxy.onCancel, getName = proxy.getName;\n\t        qq.extend(this, {\n\t            add: function(id, fileItem) {\n\t                fileState[id] = fileItem;\n\t                fileState[id].temp = {};\n\t            },\n\t            cancel: function(id) {\n\t                var self = this, cancelFinalizationEffort = new qq.Promise(), onCancelRetVal = onCancel(id, getName(id), cancelFinalizationEffort);\n\t                onCancelRetVal.then(function() {\n\t                    if (self.isValid(id)) {\n\t                        fileState[id].canceled = true;\n\t                        self.expunge(id);\n\t                    }\n\t                    cancelFinalizationEffort.success();\n\t                });\n\t            },\n\t            expunge: function(id) {\n\t                delete fileState[id];\n\t            },\n\t            getThirdPartyFileId: function(id) {\n\t                return fileState[id].key;\n\t            },\n\t            isValid: function(id) {\n\t                return fileState[id] !== undefined;\n\t            },\n\t            reset: function() {\n\t                fileState = {};\n\t            },\n\t            _getFileState: function(id) {\n\t                return fileState[id];\n\t            },\n\t            _setThirdPartyFileId: function(id, thirdPartyFileId) {\n\t                fileState[id].key = thirdPartyFileId;\n\t            },\n\t            _wasCanceled: function(id) {\n\t                return !!fileState[id].canceled;\n\t            }\n\t        });\n\t    };\n\t    qq.UploadHandlerController = function(o, namespace) {\n\t        \"use strict\";\n\t        var controller = this, chunkingPossible = false, concurrentChunkingPossible = false, chunking, preventRetryResponse, log, handler, options = {\n\t            paramsStore: {},\n\t            maxConnections: 3,\n\t            chunking: {\n\t                enabled: false,\n\t                multiple: {\n\t                    enabled: false\n\t                }\n\t            },\n\t            log: function(str, level) {},\n\t            onProgress: function(id, fileName, loaded, total) {},\n\t            onComplete: function(id, fileName, response, xhr) {},\n\t            onCancel: function(id, fileName) {},\n\t            onUploadPrep: function(id) {},\n\t            onUpload: function(id, fileName) {},\n\t            onUploadChunk: function(id, fileName, chunkData) {},\n\t            onUploadChunkSuccess: function(id, chunkData, response, xhr) {},\n\t            onAutoRetry: function(id, fileName, response, xhr) {},\n\t            onResume: function(id, fileName, chunkData) {},\n\t            onUuidChanged: function(id, newUuid) {},\n\t            getName: function(id) {},\n\t            setSize: function(id, newSize) {},\n\t            isQueued: function(id) {},\n\t            getIdsInProxyGroup: function(id) {},\n\t            getIdsInBatch: function(id) {}\n\t        }, chunked = {\n\t            done: function(id, chunkIdx, response, xhr) {\n\t                var chunkData = handler._getChunkData(id, chunkIdx);\n\t                handler._getFileState(id).attemptingResume = false;\n\t                delete handler._getFileState(id).temp.chunkProgress[chunkIdx];\n\t                handler._getFileState(id).loaded += chunkData.size;\n\t                options.onUploadChunkSuccess(id, handler._getChunkDataForCallback(chunkData), response, xhr);\n\t            },\n\t            finalize: function(id) {\n\t                var size = options.getSize(id), name = options.getName(id);\n\t                log(\"All chunks have been uploaded for \" + id + \" - finalizing....\");\n\t                handler.finalizeChunks(id).then(function(response, xhr) {\n\t                    log(\"Finalize successful for \" + id);\n\t                    var normaizedResponse = upload.normalizeResponse(response, true);\n\t                    options.onProgress(id, name, size, size);\n\t                    handler._maybeDeletePersistedChunkData(id);\n\t                    upload.cleanup(id, normaizedResponse, xhr);\n\t                }, function(response, xhr) {\n\t                    var normaizedResponse = upload.normalizeResponse(response, false);\n\t                    log(\"Problem finalizing chunks for file ID \" + id + \" - \" + normaizedResponse.error, \"error\");\n\t                    if (normaizedResponse.reset) {\n\t                        chunked.reset(id);\n\t                    }\n\t                    if (!options.onAutoRetry(id, name, normaizedResponse, xhr)) {\n\t                        upload.cleanup(id, normaizedResponse, xhr);\n\t                    }\n\t                });\n\t            },\n\t            handleFailure: function(chunkIdx, id, response, xhr) {\n\t                var name = options.getName(id);\n\t                log(\"Chunked upload request failed for \" + id + \", chunk \" + chunkIdx);\n\t                handler.clearCachedChunk(id, chunkIdx);\n\t                var responseToReport = upload.normalizeResponse(response, false), inProgressIdx;\n\t                if (responseToReport.reset) {\n\t                    chunked.reset(id);\n\t                } else {\n\t                    inProgressIdx = qq.indexOf(handler._getFileState(id).chunking.inProgress, chunkIdx);\n\t                    if (inProgressIdx >= 0) {\n\t                        handler._getFileState(id).chunking.inProgress.splice(inProgressIdx, 1);\n\t                        handler._getFileState(id).chunking.remaining.unshift(chunkIdx);\n\t                    }\n\t                }\n\t                if (!handler._getFileState(id).temp.ignoreFailure) {\n\t                    if (concurrentChunkingPossible) {\n\t                        handler._getFileState(id).temp.ignoreFailure = true;\n\t                        log(qq.format(\"Going to attempt to abort these chunks: {}. These are currently in-progress: {}.\", JSON.stringify(Object.keys(handler._getXhrs(id))), JSON.stringify(handler._getFileState(id).chunking.inProgress)));\n\t                        qq.each(handler._getXhrs(id), function(ckid, ckXhr) {\n\t                            log(qq.format(\"Attempting to abort file {}.{}. XHR readyState {}. \", id, ckid, ckXhr.readyState));\n\t                            ckXhr.abort();\n\t                            ckXhr._cancelled = true;\n\t                        });\n\t                        handler.moveInProgressToRemaining(id);\n\t                        connectionManager.free(id, true);\n\t                    }\n\t                    if (!options.onAutoRetry(id, name, responseToReport, xhr)) {\n\t                        upload.cleanup(id, responseToReport, xhr);\n\t                    }\n\t                }\n\t            },\n\t            hasMoreParts: function(id) {\n\t                return !!handler._getFileState(id).chunking.remaining.length;\n\t            },\n\t            nextPart: function(id) {\n\t                var nextIdx = handler._getFileState(id).chunking.remaining.shift();\n\t                if (nextIdx >= handler._getTotalChunks(id)) {\n\t                    nextIdx = null;\n\t                }\n\t                return nextIdx;\n\t            },\n\t            reset: function(id) {\n\t                log(\"Server or callback has ordered chunking effort to be restarted on next attempt for item ID \" + id, \"error\");\n\t                handler._maybeDeletePersistedChunkData(id);\n\t                handler.reevaluateChunking(id);\n\t                handler._getFileState(id).loaded = 0;\n\t            },\n\t            sendNext: function(id) {\n\t                var size = options.getSize(id), name = options.getName(id), chunkIdx = chunked.nextPart(id), chunkData = handler._getChunkData(id, chunkIdx), resuming = handler._getFileState(id).attemptingResume, inProgressChunks = handler._getFileState(id).chunking.inProgress || [];\n\t                if (handler._getFileState(id).loaded == null) {\n\t                    handler._getFileState(id).loaded = 0;\n\t                }\n\t                if (resuming && options.onResume(id, name, chunkData) === false) {\n\t                    chunked.reset(id);\n\t                    chunkIdx = chunked.nextPart(id);\n\t                    chunkData = handler._getChunkData(id, chunkIdx);\n\t                    resuming = false;\n\t                }\n\t                if (chunkIdx == null && inProgressChunks.length === 0) {\n\t                    chunked.finalize(id);\n\t                } else {\n\t                    log(qq.format(\"Sending chunked upload request for item {}.{}, bytes {}-{} of {}.\", id, chunkIdx, chunkData.start + 1, chunkData.end, size));\n\t                    options.onUploadChunk(id, name, handler._getChunkDataForCallback(chunkData));\n\t                    inProgressChunks.push(chunkIdx);\n\t                    handler._getFileState(id).chunking.inProgress = inProgressChunks;\n\t                    if (concurrentChunkingPossible) {\n\t                        connectionManager.open(id, chunkIdx);\n\t                    }\n\t                    if (concurrentChunkingPossible && connectionManager.available() && handler._getFileState(id).chunking.remaining.length) {\n\t                        chunked.sendNext(id);\n\t                    }\n\t                    if (chunkData.blob.size === 0) {\n\t                        log(qq.format(\"Chunk {} for file {} will not be uploaded, zero sized chunk.\", chunkIdx, id), \"error\");\n\t                        chunked.handleFailure(chunkIdx, id, \"File is no longer available\", null);\n\t                    } else {\n\t                        handler.uploadChunk(id, chunkIdx, resuming).then(function success(response, xhr) {\n\t                            log(\"Chunked upload request succeeded for \" + id + \", chunk \" + chunkIdx);\n\t                            handler.clearCachedChunk(id, chunkIdx);\n\t                            var inProgressChunks = handler._getFileState(id).chunking.inProgress || [], responseToReport = upload.normalizeResponse(response, true), inProgressChunkIdx = qq.indexOf(inProgressChunks, chunkIdx);\n\t                            log(qq.format(\"Chunk {} for file {} uploaded successfully.\", chunkIdx, id));\n\t                            chunked.done(id, chunkIdx, responseToReport, xhr);\n\t                            if (inProgressChunkIdx >= 0) {\n\t                                inProgressChunks.splice(inProgressChunkIdx, 1);\n\t                            }\n\t                            handler._maybePersistChunkedState(id);\n\t                            if (!chunked.hasMoreParts(id) && inProgressChunks.length === 0) {\n\t                                chunked.finalize(id);\n\t                            } else if (chunked.hasMoreParts(id)) {\n\t                                chunked.sendNext(id);\n\t                            } else {\n\t                                log(qq.format(\"File ID {} has no more chunks to send and these chunk indexes are still marked as in-progress: {}\", id, JSON.stringify(inProgressChunks)));\n\t                            }\n\t                        }, function failure(response, xhr) {\n\t                            chunked.handleFailure(chunkIdx, id, response, xhr);\n\t                        }).done(function() {\n\t                            handler.clearXhr(id, chunkIdx);\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t        }, connectionManager = {\n\t            _open: [],\n\t            _openChunks: {},\n\t            _waiting: [],\n\t            available: function() {\n\t                var max = options.maxConnections, openChunkEntriesCount = 0, openChunksCount = 0;\n\t                qq.each(connectionManager._openChunks, function(fileId, openChunkIndexes) {\n\t                    openChunkEntriesCount++;\n\t                    openChunksCount += openChunkIndexes.length;\n\t                });\n\t                return max - (connectionManager._open.length - openChunkEntriesCount + openChunksCount);\n\t            },\n\t            free: function(id, dontAllowNext) {\n\t                var allowNext = !dontAllowNext, waitingIndex = qq.indexOf(connectionManager._waiting, id), connectionsIndex = qq.indexOf(connectionManager._open, id), nextId;\n\t                delete connectionManager._openChunks[id];\n\t                if (upload.getProxyOrBlob(id) instanceof qq.BlobProxy) {\n\t                    log(\"Generated blob upload has ended for \" + id + \", disposing generated blob.\");\n\t                    delete handler._getFileState(id).file;\n\t                }\n\t                if (waitingIndex >= 0) {\n\t                    connectionManager._waiting.splice(waitingIndex, 1);\n\t                } else if (allowNext && connectionsIndex >= 0) {\n\t                    connectionManager._open.splice(connectionsIndex, 1);\n\t                    nextId = connectionManager._waiting.shift();\n\t                    if (nextId >= 0) {\n\t                        connectionManager._open.push(nextId);\n\t                        upload.start(nextId);\n\t                    }\n\t                }\n\t            },\n\t            getWaitingOrConnected: function() {\n\t                var waitingOrConnected = [];\n\t                qq.each(connectionManager._openChunks, function(fileId, chunks) {\n\t                    if (chunks && chunks.length) {\n\t                        waitingOrConnected.push(parseInt(fileId));\n\t                    }\n\t                });\n\t                qq.each(connectionManager._open, function(idx, fileId) {\n\t                    if (!connectionManager._openChunks[fileId]) {\n\t                        waitingOrConnected.push(parseInt(fileId));\n\t                    }\n\t                });\n\t                waitingOrConnected = waitingOrConnected.concat(connectionManager._waiting);\n\t                return waitingOrConnected;\n\t            },\n\t            isUsingConnection: function(id) {\n\t                return qq.indexOf(connectionManager._open, id) >= 0;\n\t            },\n\t            open: function(id, chunkIdx) {\n\t                if (chunkIdx == null) {\n\t                    connectionManager._waiting.push(id);\n\t                }\n\t                if (connectionManager.available()) {\n\t                    if (chunkIdx == null) {\n\t                        connectionManager._waiting.pop();\n\t                        connectionManager._open.push(id);\n\t                    } else {\n\t                        (function() {\n\t                            var openChunksEntry = connectionManager._openChunks[id] || [];\n\t                            openChunksEntry.push(chunkIdx);\n\t                            connectionManager._openChunks[id] = openChunksEntry;\n\t                        })();\n\t                    }\n\t                    return true;\n\t                }\n\t                return false;\n\t            },\n\t            reset: function() {\n\t                connectionManager._waiting = [];\n\t                connectionManager._open = [];\n\t            }\n\t        }, simple = {\n\t            send: function(id, name) {\n\t                handler._getFileState(id).loaded = 0;\n\t                log(\"Sending simple upload request for \" + id);\n\t                handler.uploadFile(id).then(function(response, optXhr) {\n\t                    log(\"Simple upload request succeeded for \" + id);\n\t                    var responseToReport = upload.normalizeResponse(response, true), size = options.getSize(id);\n\t                    options.onProgress(id, name, size, size);\n\t                    upload.maybeNewUuid(id, responseToReport);\n\t                    upload.cleanup(id, responseToReport, optXhr);\n\t                }, function(response, optXhr) {\n\t                    log(\"Simple upload request failed for \" + id);\n\t                    var responseToReport = upload.normalizeResponse(response, false);\n\t                    if (!options.onAutoRetry(id, name, responseToReport, optXhr)) {\n\t                        upload.cleanup(id, responseToReport, optXhr);\n\t                    }\n\t                });\n\t            }\n\t        }, upload = {\n\t            cancel: function(id) {\n\t                log(\"Cancelling \" + id);\n\t                options.paramsStore.remove(id);\n\t                connectionManager.free(id);\n\t            },\n\t            cleanup: function(id, response, optXhr) {\n\t                var name = options.getName(id);\n\t                options.onComplete(id, name, response, optXhr);\n\t                if (handler._getFileState(id)) {\n\t                    handler._clearXhrs && handler._clearXhrs(id);\n\t                }\n\t                connectionManager.free(id);\n\t            },\n\t            getProxyOrBlob: function(id) {\n\t                return handler.getProxy && handler.getProxy(id) || handler.getFile && handler.getFile(id);\n\t            },\n\t            initHandler: function() {\n\t                var handlerType = namespace ? qq[namespace] : qq.traditional, handlerModuleSubtype = qq.supportedFeatures.ajaxUploading ? \"Xhr\" : \"Form\";\n\t                handler = new handlerType[handlerModuleSubtype + \"UploadHandler\"](options, {\n\t                    getDataByUuid: options.getDataByUuid,\n\t                    getName: options.getName,\n\t                    getSize: options.getSize,\n\t                    getUuid: options.getUuid,\n\t                    log: log,\n\t                    onCancel: options.onCancel,\n\t                    onProgress: options.onProgress,\n\t                    onUuidChanged: options.onUuidChanged\n\t                });\n\t                if (handler._removeExpiredChunkingRecords) {\n\t                    handler._removeExpiredChunkingRecords();\n\t                }\n\t            },\n\t            isDeferredEligibleForUpload: function(id) {\n\t                return options.isQueued(id);\n\t            },\n\t            maybeDefer: function(id, blob) {\n\t                if (blob && !handler.getFile(id) && blob instanceof qq.BlobProxy) {\n\t                    options.onUploadPrep(id);\n\t                    log(\"Attempting to generate a blob on-demand for \" + id);\n\t                    blob.create().then(function(generatedBlob) {\n\t                        log(\"Generated an on-demand blob for \" + id);\n\t                        handler.updateBlob(id, generatedBlob);\n\t                        options.setSize(id, generatedBlob.size);\n\t                        handler.reevaluateChunking(id);\n\t                        upload.maybeSendDeferredFiles(id);\n\t                    }, function(errorMessage) {\n\t                        var errorResponse = {};\n\t                        if (errorMessage) {\n\t                            errorResponse.error = errorMessage;\n\t                        }\n\t                        log(qq.format(\"Failed to generate blob for ID {}.  Error message: {}.\", id, errorMessage), \"error\");\n\t                        options.onComplete(id, options.getName(id), qq.extend(errorResponse, preventRetryResponse), null);\n\t                        upload.maybeSendDeferredFiles(id);\n\t                        connectionManager.free(id);\n\t                    });\n\t                } else {\n\t                    return upload.maybeSendDeferredFiles(id);\n\t                }\n\t                return false;\n\t            },\n\t            maybeSendDeferredFiles: function(id) {\n\t                var idsInGroup = options.getIdsInProxyGroup(id), uploadedThisId = false;\n\t                if (idsInGroup && idsInGroup.length) {\n\t                    log(\"Maybe ready to upload proxy group file \" + id);\n\t                    qq.each(idsInGroup, function(idx, idInGroup) {\n\t                        if (upload.isDeferredEligibleForUpload(idInGroup) && !!handler.getFile(idInGroup)) {\n\t                            uploadedThisId = idInGroup === id;\n\t                            upload.now(idInGroup);\n\t                        } else if (upload.isDeferredEligibleForUpload(idInGroup)) {\n\t                            return false;\n\t                        }\n\t                    });\n\t                } else {\n\t                    uploadedThisId = true;\n\t                    upload.now(id);\n\t                }\n\t                return uploadedThisId;\n\t            },\n\t            maybeNewUuid: function(id, response) {\n\t                if (response.newUuid !== undefined) {\n\t                    options.onUuidChanged(id, response.newUuid);\n\t                }\n\t            },\n\t            normalizeResponse: function(originalResponse, successful) {\n\t                var response = originalResponse;\n\t                if (!qq.isObject(originalResponse)) {\n\t                    response = {};\n\t                    if (qq.isString(originalResponse) && !successful) {\n\t                        response.error = originalResponse;\n\t                    }\n\t                }\n\t                response.success = successful;\n\t                return response;\n\t            },\n\t            now: function(id) {\n\t                var name = options.getName(id);\n\t                if (!controller.isValid(id)) {\n\t                    throw new qq.Error(id + \" is not a valid file ID to upload!\");\n\t                }\n\t                options.onUpload(id, name);\n\t                if (chunkingPossible && handler._shouldChunkThisFile(id)) {\n\t                    chunked.sendNext(id);\n\t                } else {\n\t                    simple.send(id, name);\n\t                }\n\t            },\n\t            start: function(id) {\n\t                var blobToUpload = upload.getProxyOrBlob(id);\n\t                if (blobToUpload) {\n\t                    return upload.maybeDefer(id, blobToUpload);\n\t                } else {\n\t                    upload.now(id);\n\t                    return true;\n\t                }\n\t            }\n\t        };\n\t        qq.extend(this, {\n\t            add: function(id, file) {\n\t                handler.add.apply(this, arguments);\n\t            },\n\t            upload: function(id) {\n\t                if (connectionManager.open(id)) {\n\t                    return upload.start(id);\n\t                }\n\t                return false;\n\t            },\n\t            retry: function(id) {\n\t                if (concurrentChunkingPossible) {\n\t                    handler._getFileState(id).temp.ignoreFailure = false;\n\t                }\n\t                if (connectionManager.isUsingConnection(id)) {\n\t                    return upload.start(id);\n\t                } else {\n\t                    return controller.upload(id);\n\t                }\n\t            },\n\t            cancel: function(id) {\n\t                var cancelRetVal = handler.cancel(id);\n\t                if (qq.isGenericPromise(cancelRetVal)) {\n\t                    cancelRetVal.then(function() {\n\t                        upload.cancel(id);\n\t                    });\n\t                } else if (cancelRetVal !== false) {\n\t                    upload.cancel(id);\n\t                }\n\t            },\n\t            cancelAll: function() {\n\t                var waitingOrConnected = connectionManager.getWaitingOrConnected(), i;\n\t                if (waitingOrConnected.length) {\n\t                    for (i = waitingOrConnected.length - 1; i >= 0; i--) {\n\t                        controller.cancel(waitingOrConnected[i]);\n\t                    }\n\t                }\n\t                connectionManager.reset();\n\t            },\n\t            getFile: function(id) {\n\t                if (handler.getProxy && handler.getProxy(id)) {\n\t                    return handler.getProxy(id).referenceBlob;\n\t                }\n\t                return handler.getFile && handler.getFile(id);\n\t            },\n\t            isProxied: function(id) {\n\t                return !!(handler.getProxy && handler.getProxy(id));\n\t            },\n\t            getInput: function(id) {\n\t                if (handler.getInput) {\n\t                    return handler.getInput(id);\n\t                }\n\t            },\n\t            reset: function() {\n\t                log(\"Resetting upload handler\");\n\t                controller.cancelAll();\n\t                connectionManager.reset();\n\t                handler.reset();\n\t            },\n\t            expunge: function(id) {\n\t                if (controller.isValid(id)) {\n\t                    return handler.expunge(id);\n\t                }\n\t            },\n\t            isValid: function(id) {\n\t                return handler.isValid(id);\n\t            },\n\t            getResumableFilesData: function() {\n\t                if (handler.getResumableFilesData) {\n\t                    return handler.getResumableFilesData();\n\t                }\n\t                return [];\n\t            },\n\t            getThirdPartyFileId: function(id) {\n\t                if (controller.isValid(id)) {\n\t                    return handler.getThirdPartyFileId(id);\n\t                }\n\t            },\n\t            pause: function(id) {\n\t                if (controller.isResumable(id) && handler.pause && controller.isValid(id) && handler.pause(id)) {\n\t                    connectionManager.free(id);\n\t                    handler.moveInProgressToRemaining(id);\n\t                    return true;\n\t                }\n\t                return false;\n\t            },\n\t            isResumable: function(id) {\n\t                return !!handler.isResumable && handler.isResumable(id);\n\t            }\n\t        });\n\t        qq.extend(options, o);\n\t        log = options.log;\n\t        chunkingPossible = options.chunking.enabled && qq.supportedFeatures.chunking;\n\t        concurrentChunkingPossible = chunkingPossible && options.chunking.concurrent.enabled;\n\t        preventRetryResponse = function() {\n\t            var response = {};\n\t            response[options.preventRetryParam] = true;\n\t            return response;\n\t        }();\n\t        upload.initHandler();\n\t    };\n\t    qq.WindowReceiveMessage = function(o) {\n\t        \"use strict\";\n\t        var options = {\n\t            log: function(message, level) {}\n\t        }, callbackWrapperDetachers = {};\n\t        qq.extend(options, o);\n\t        qq.extend(this, {\n\t            receiveMessage: function(id, callback) {\n\t                var onMessageCallbackWrapper = function(event) {\n\t                    callback(event.data);\n\t                };\n\t                if (window.postMessage) {\n\t                    callbackWrapperDetachers[id] = qq(window).attach(\"message\", onMessageCallbackWrapper);\n\t                } else {\n\t                    log(\"iframe message passing not supported in this browser!\", \"error\");\n\t                }\n\t            },\n\t            stopReceivingMessages: function(id) {\n\t                if (window.postMessage) {\n\t                    var detacher = callbackWrapperDetachers[id];\n\t                    if (detacher) {\n\t                        detacher();\n\t                    }\n\t                }\n\t            }\n\t        });\n\t    };\n\t    qq.FormUploadHandler = function(spec) {\n\t        \"use strict\";\n\t        var options = spec.options, handler = this, proxy = spec.proxy, formHandlerInstanceId = qq.getUniqueId(), onloadCallbacks = {}, detachLoadEvents = {}, postMessageCallbackTimers = {}, isCors = options.isCors, inputName = options.inputName, getUuid = proxy.getUuid, log = proxy.log, corsMessageReceiver = new qq.WindowReceiveMessage({\n\t            log: log\n\t        });\n\t        function expungeFile(id) {\n\t            delete detachLoadEvents[id];\n\t            if (isCors) {\n\t                clearTimeout(postMessageCallbackTimers[id]);\n\t                delete postMessageCallbackTimers[id];\n\t                corsMessageReceiver.stopReceivingMessages(id);\n\t            }\n\t            var iframe = document.getElementById(handler._getIframeName(id));\n\t            if (iframe) {\n\t                iframe.setAttribute(\"src\", \"javascript:false;\");\n\t                qq(iframe).remove();\n\t            }\n\t        }\n\t        function getFileIdForIframeName(iframeName) {\n\t            return iframeName.split(\"_\")[0];\n\t        }\n\t        function initIframeForUpload(name) {\n\t            var iframe = qq.toElement(\"<iframe src='javascript:false;' name='\" + name + \"' />\");\n\t            iframe.setAttribute(\"id\", name);\n\t            iframe.style.display = \"none\";\n\t            document.body.appendChild(iframe);\n\t            return iframe;\n\t        }\n\t        function registerPostMessageCallback(iframe, callback) {\n\t            var iframeName = iframe.id, fileId = getFileIdForIframeName(iframeName), uuid = getUuid(fileId);\n\t            onloadCallbacks[uuid] = callback;\n\t            detachLoadEvents[fileId] = qq(iframe).attach(\"load\", function() {\n\t                if (handler.getInput(fileId)) {\n\t                    log(\"Received iframe load event for CORS upload request (iframe name \" + iframeName + \")\");\n\t                    postMessageCallbackTimers[iframeName] = setTimeout(function() {\n\t                        var errorMessage = \"No valid message received from loaded iframe for iframe name \" + iframeName;\n\t                        log(errorMessage, \"error\");\n\t                        callback({\n\t                            error: errorMessage\n\t                        });\n\t                    }, 1e3);\n\t                }\n\t            });\n\t            corsMessageReceiver.receiveMessage(iframeName, function(message) {\n\t                log(\"Received the following window message: '\" + message + \"'\");\n\t                var fileId = getFileIdForIframeName(iframeName), response = handler._parseJsonResponse(message), uuid = response.uuid, onloadCallback;\n\t                if (uuid && onloadCallbacks[uuid]) {\n\t                    log(\"Handling response for iframe name \" + iframeName);\n\t                    clearTimeout(postMessageCallbackTimers[iframeName]);\n\t                    delete postMessageCallbackTimers[iframeName];\n\t                    handler._detachLoadEvent(iframeName);\n\t                    onloadCallback = onloadCallbacks[uuid];\n\t                    delete onloadCallbacks[uuid];\n\t                    corsMessageReceiver.stopReceivingMessages(iframeName);\n\t                    onloadCallback(response);\n\t                } else if (!uuid) {\n\t                    log(\"'\" + message + \"' does not contain a UUID - ignoring.\");\n\t                }\n\t            });\n\t        }\n\t        qq.extend(this, new qq.UploadHandler(spec));\n\t        qq.override(this, function(super_) {\n\t            return {\n\t                add: function(id, fileInput) {\n\t                    super_.add(id, {\n\t                        input: fileInput\n\t                    });\n\t                    fileInput.setAttribute(\"name\", inputName);\n\t                    if (fileInput.parentNode) {\n\t                        qq(fileInput).remove();\n\t                    }\n\t                },\n\t                expunge: function(id) {\n\t                    expungeFile(id);\n\t                    super_.expunge(id);\n\t                },\n\t                isValid: function(id) {\n\t                    return super_.isValid(id) && handler._getFileState(id).input !== undefined;\n\t                }\n\t            };\n\t        });\n\t        qq.extend(this, {\n\t            getInput: function(id) {\n\t                return handler._getFileState(id).input;\n\t            },\n\t            _attachLoadEvent: function(iframe, callback) {\n\t                var responseDescriptor;\n\t                if (isCors) {\n\t                    registerPostMessageCallback(iframe, callback);\n\t                } else {\n\t                    detachLoadEvents[iframe.id] = qq(iframe).attach(\"load\", function() {\n\t                        log(\"Received response for \" + iframe.id);\n\t                        if (!iframe.parentNode) {\n\t                            return;\n\t                        }\n\t                        try {\n\t                            if (iframe.contentDocument && iframe.contentDocument.body && iframe.contentDocument.body.innerHTML == \"false\") {\n\t                                return;\n\t                            }\n\t                        } catch (error) {\n\t                            log(\"Error when attempting to access iframe during handling of upload response (\" + error.message + \")\", \"error\");\n\t                            responseDescriptor = {\n\t                                success: false\n\t                            };\n\t                        }\n\t                        callback(responseDescriptor);\n\t                    });\n\t                }\n\t            },\n\t            _createIframe: function(id) {\n\t                var iframeName = handler._getIframeName(id);\n\t                return initIframeForUpload(iframeName);\n\t            },\n\t            _detachLoadEvent: function(id) {\n\t                if (detachLoadEvents[id] !== undefined) {\n\t                    detachLoadEvents[id]();\n\t                    delete detachLoadEvents[id];\n\t                }\n\t            },\n\t            _getIframeName: function(fileId) {\n\t                return fileId + \"_\" + formHandlerInstanceId;\n\t            },\n\t            _initFormForUpload: function(spec) {\n\t                var method = spec.method, endpoint = spec.endpoint, params = spec.params, paramsInBody = spec.paramsInBody, targetName = spec.targetName, form = qq.toElement(\"<form method='\" + method + \"' enctype='multipart/form-data'></form>\"), url = endpoint;\n\t                if (paramsInBody) {\n\t                    qq.obj2Inputs(params, form);\n\t                } else {\n\t                    url = qq.obj2url(params, endpoint);\n\t                }\n\t                form.setAttribute(\"action\", url);\n\t                form.setAttribute(\"target\", targetName);\n\t                form.style.display = \"none\";\n\t                document.body.appendChild(form);\n\t                return form;\n\t            },\n\t            _parseJsonResponse: function(innerHtmlOrMessage) {\n\t                var response = {};\n\t                try {\n\t                    response = qq.parseJson(innerHtmlOrMessage);\n\t                } catch (error) {\n\t                    log(\"Error when attempting to parse iframe upload response (\" + error.message + \")\", \"error\");\n\t                }\n\t                return response;\n\t            }\n\t        });\n\t    };\n\t    qq.XhrUploadHandler = function(spec) {\n\t        \"use strict\";\n\t        var handler = this, namespace = spec.options.namespace, proxy = spec.proxy, chunking = spec.options.chunking, resume = spec.options.resume, chunkFiles = chunking && spec.options.chunking.enabled && qq.supportedFeatures.chunking, resumeEnabled = resume && spec.options.resume.enabled && chunkFiles && qq.supportedFeatures.resume, getName = proxy.getName, getSize = proxy.getSize, getUuid = proxy.getUuid, getEndpoint = proxy.getEndpoint, getDataByUuid = proxy.getDataByUuid, onUuidChanged = proxy.onUuidChanged, onProgress = proxy.onProgress, log = proxy.log;\n\t        function abort(id) {\n\t            qq.each(handler._getXhrs(id), function(xhrId, xhr) {\n\t                var ajaxRequester = handler._getAjaxRequester(id, xhrId);\n\t                xhr.onreadystatechange = null;\n\t                xhr.upload.onprogress = null;\n\t                xhr.abort();\n\t                ajaxRequester && ajaxRequester.canceled && ajaxRequester.canceled(id);\n\t            });\n\t        }\n\t        qq.extend(this, new qq.UploadHandler(spec));\n\t        qq.override(this, function(super_) {\n\t            return {\n\t                add: function(id, blobOrProxy) {\n\t                    if (qq.isFile(blobOrProxy) || qq.isBlob(blobOrProxy)) {\n\t                        super_.add(id, {\n\t                            file: blobOrProxy\n\t                        });\n\t                    } else if (blobOrProxy instanceof qq.BlobProxy) {\n\t                        super_.add(id, {\n\t                            proxy: blobOrProxy\n\t                        });\n\t                    } else {\n\t                        throw new Error(\"Passed obj is not a File, Blob, or proxy\");\n\t                    }\n\t                    handler._initTempState(id);\n\t                    resumeEnabled && handler._maybePrepareForResume(id);\n\t                },\n\t                expunge: function(id) {\n\t                    abort(id);\n\t                    handler._maybeDeletePersistedChunkData(id);\n\t                    handler._clearXhrs(id);\n\t                    super_.expunge(id);\n\t                }\n\t            };\n\t        });\n\t        qq.extend(this, {\n\t            clearCachedChunk: function(id, chunkIdx) {\n\t                delete handler._getFileState(id).temp.cachedChunks[chunkIdx];\n\t            },\n\t            clearXhr: function(id, chunkIdx) {\n\t                var tempState = handler._getFileState(id).temp;\n\t                if (tempState.xhrs) {\n\t                    delete tempState.xhrs[chunkIdx];\n\t                }\n\t                if (tempState.ajaxRequesters) {\n\t                    delete tempState.ajaxRequesters[chunkIdx];\n\t                }\n\t            },\n\t            finalizeChunks: function(id, responseParser) {\n\t                var lastChunkIdx = handler._getTotalChunks(id) - 1, xhr = handler._getXhr(id, lastChunkIdx);\n\t                if (responseParser) {\n\t                    return new qq.Promise().success(responseParser(xhr), xhr);\n\t                }\n\t                return new qq.Promise().success({}, xhr);\n\t            },\n\t            getFile: function(id) {\n\t                return handler.isValid(id) && handler._getFileState(id).file;\n\t            },\n\t            getProxy: function(id) {\n\t                return handler.isValid(id) && handler._getFileState(id).proxy;\n\t            },\n\t            getResumableFilesData: function() {\n\t                var resumableFilesData = [];\n\t                handler._iterateResumeRecords(function(key, uploadData) {\n\t                    handler.moveInProgressToRemaining(null, uploadData.chunking.inProgress, uploadData.chunking.remaining);\n\t                    var data = {\n\t                        name: uploadData.name,\n\t                        remaining: uploadData.chunking.remaining,\n\t                        size: uploadData.size,\n\t                        uuid: uploadData.uuid\n\t                    };\n\t                    if (uploadData.key) {\n\t                        data.key = uploadData.key;\n\t                    }\n\t                    resumableFilesData.push(data);\n\t                });\n\t                return resumableFilesData;\n\t            },\n\t            isResumable: function(id) {\n\t                return !!chunking && handler.isValid(id) && !handler._getFileState(id).notResumable;\n\t            },\n\t            moveInProgressToRemaining: function(id, optInProgress, optRemaining) {\n\t                var inProgress = optInProgress || handler._getFileState(id).chunking.inProgress, remaining = optRemaining || handler._getFileState(id).chunking.remaining;\n\t                if (inProgress) {\n\t                    log(qq.format(\"Moving these chunks from in-progress {}, to remaining.\", JSON.stringify(inProgress)));\n\t                    inProgress.reverse();\n\t                    qq.each(inProgress, function(idx, chunkIdx) {\n\t                        remaining.unshift(chunkIdx);\n\t                    });\n\t                    inProgress.length = 0;\n\t                }\n\t            },\n\t            pause: function(id) {\n\t                if (handler.isValid(id)) {\n\t                    log(qq.format(\"Aborting XHR upload for {} '{}' due to pause instruction.\", id, getName(id)));\n\t                    handler._getFileState(id).paused = true;\n\t                    abort(id);\n\t                    return true;\n\t                }\n\t            },\n\t            reevaluateChunking: function(id) {\n\t                if (chunking && handler.isValid(id)) {\n\t                    var state = handler._getFileState(id), totalChunks, i;\n\t                    delete state.chunking;\n\t                    state.chunking = {};\n\t                    totalChunks = handler._getTotalChunks(id);\n\t                    if (totalChunks > 1 || chunking.mandatory) {\n\t                        state.chunking.enabled = true;\n\t                        state.chunking.parts = totalChunks;\n\t                        state.chunking.remaining = [];\n\t                        for (i = 0; i < totalChunks; i++) {\n\t                            state.chunking.remaining.push(i);\n\t                        }\n\t                        handler._initTempState(id);\n\t                    } else {\n\t                        state.chunking.enabled = false;\n\t                    }\n\t                }\n\t            },\n\t            updateBlob: function(id, newBlob) {\n\t                if (handler.isValid(id)) {\n\t                    handler._getFileState(id).file = newBlob;\n\t                }\n\t            },\n\t            _clearXhrs: function(id) {\n\t                var tempState = handler._getFileState(id).temp;\n\t                qq.each(tempState.ajaxRequesters, function(chunkId) {\n\t                    delete tempState.ajaxRequesters[chunkId];\n\t                });\n\t                qq.each(tempState.xhrs, function(chunkId) {\n\t                    delete tempState.xhrs[chunkId];\n\t                });\n\t            },\n\t            _createXhr: function(id, optChunkIdx) {\n\t                return handler._registerXhr(id, optChunkIdx, qq.createXhrInstance());\n\t            },\n\t            _getAjaxRequester: function(id, optChunkIdx) {\n\t                var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n\t                return handler._getFileState(id).temp.ajaxRequesters[chunkIdx];\n\t            },\n\t            _getChunkData: function(id, chunkIndex) {\n\t                var chunkSize = chunking.partSize, fileSize = getSize(id), fileOrBlob = handler.getFile(id), startBytes = chunkSize * chunkIndex, endBytes = startBytes + chunkSize >= fileSize ? fileSize : startBytes + chunkSize, totalChunks = handler._getTotalChunks(id), cachedChunks = this._getFileState(id).temp.cachedChunks, blob = cachedChunks[chunkIndex] || qq.sliceBlob(fileOrBlob, startBytes, endBytes);\n\t                cachedChunks[chunkIndex] = blob;\n\t                return {\n\t                    part: chunkIndex,\n\t                    start: startBytes,\n\t                    end: endBytes,\n\t                    count: totalChunks,\n\t                    blob: blob,\n\t                    size: endBytes - startBytes\n\t                };\n\t            },\n\t            _getChunkDataForCallback: function(chunkData) {\n\t                return {\n\t                    partIndex: chunkData.part,\n\t                    startByte: chunkData.start + 1,\n\t                    endByte: chunkData.end,\n\t                    totalParts: chunkData.count\n\t                };\n\t            },\n\t            _getLocalStorageId: function(id) {\n\t                var formatVersion = \"5.0\", name = getName(id), size = getSize(id), chunkSize = chunking.partSize, endpoint = getEndpoint(id);\n\t                return qq.format(\"qq{}resume{}-{}-{}-{}-{}\", namespace, formatVersion, name, size, chunkSize, endpoint);\n\t            },\n\t            _getMimeType: function(id) {\n\t                return handler.getFile(id).type;\n\t            },\n\t            _getPersistableData: function(id) {\n\t                return handler._getFileState(id).chunking;\n\t            },\n\t            _getTotalChunks: function(id) {\n\t                if (chunking) {\n\t                    var fileSize = getSize(id), chunkSize = chunking.partSize;\n\t                    return Math.ceil(fileSize / chunkSize);\n\t                }\n\t            },\n\t            _getXhr: function(id, optChunkIdx) {\n\t                var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n\t                return handler._getFileState(id).temp.xhrs[chunkIdx];\n\t            },\n\t            _getXhrs: function(id) {\n\t                return handler._getFileState(id).temp.xhrs;\n\t            },\n\t            _iterateResumeRecords: function(callback) {\n\t                if (resumeEnabled) {\n\t                    qq.each(localStorage, function(key, item) {\n\t                        if (key.indexOf(qq.format(\"qq{}resume\", namespace)) === 0) {\n\t                            var uploadData = JSON.parse(item);\n\t                            callback(key, uploadData);\n\t                        }\n\t                    });\n\t                }\n\t            },\n\t            _initTempState: function(id) {\n\t                handler._getFileState(id).temp = {\n\t                    ajaxRequesters: {},\n\t                    chunkProgress: {},\n\t                    xhrs: {},\n\t                    cachedChunks: {}\n\t                };\n\t            },\n\t            _markNotResumable: function(id) {\n\t                handler._getFileState(id).notResumable = true;\n\t            },\n\t            _maybeDeletePersistedChunkData: function(id) {\n\t                var localStorageId;\n\t                if (resumeEnabled && handler.isResumable(id)) {\n\t                    localStorageId = handler._getLocalStorageId(id);\n\t                    if (localStorageId && localStorage.getItem(localStorageId)) {\n\t                        localStorage.removeItem(localStorageId);\n\t                        return true;\n\t                    }\n\t                }\n\t                return false;\n\t            },\n\t            _maybePrepareForResume: function(id) {\n\t                var state = handler._getFileState(id), localStorageId, persistedData;\n\t                if (resumeEnabled && state.key === undefined) {\n\t                    localStorageId = handler._getLocalStorageId(id);\n\t                    persistedData = localStorage.getItem(localStorageId);\n\t                    if (persistedData) {\n\t                        persistedData = JSON.parse(persistedData);\n\t                        if (getDataByUuid(persistedData.uuid)) {\n\t                            handler._markNotResumable(id);\n\t                        } else {\n\t                            log(qq.format(\"Identified file with ID {} and name of {} as resumable.\", id, getName(id)));\n\t                            onUuidChanged(id, persistedData.uuid);\n\t                            state.key = persistedData.key;\n\t                            state.chunking = persistedData.chunking;\n\t                            state.loaded = persistedData.loaded;\n\t                            state.attemptingResume = true;\n\t                            handler.moveInProgressToRemaining(id);\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            _maybePersistChunkedState: function(id) {\n\t                var state = handler._getFileState(id), localStorageId, persistedData;\n\t                if (resumeEnabled && handler.isResumable(id)) {\n\t                    localStorageId = handler._getLocalStorageId(id);\n\t                    persistedData = {\n\t                        name: getName(id),\n\t                        size: getSize(id),\n\t                        uuid: getUuid(id),\n\t                        key: state.key,\n\t                        chunking: state.chunking,\n\t                        loaded: state.loaded,\n\t                        lastUpdated: Date.now()\n\t                    };\n\t                    try {\n\t                        localStorage.setItem(localStorageId, JSON.stringify(persistedData));\n\t                    } catch (error) {\n\t                        log(qq.format(\"Unable to save resume data for '{}' due to error: '{}'.\", id, error.toString()), \"warn\");\n\t                    }\n\t                }\n\t            },\n\t            _registerProgressHandler: function(id, chunkIdx, chunkSize) {\n\t                var xhr = handler._getXhr(id, chunkIdx), name = getName(id), progressCalculator = {\n\t                    simple: function(loaded, total) {\n\t                        var fileSize = getSize(id);\n\t                        if (loaded === total) {\n\t                            onProgress(id, name, fileSize, fileSize);\n\t                        } else {\n\t                            onProgress(id, name, loaded >= fileSize ? fileSize - 1 : loaded, fileSize);\n\t                        }\n\t                    },\n\t                    chunked: function(loaded, total) {\n\t                        var chunkProgress = handler._getFileState(id).temp.chunkProgress, totalSuccessfullyLoadedForFile = handler._getFileState(id).loaded, loadedForRequest = loaded, totalForRequest = total, totalFileSize = getSize(id), estActualChunkLoaded = loadedForRequest - (totalForRequest - chunkSize), totalLoadedForFile = totalSuccessfullyLoadedForFile;\n\t                        chunkProgress[chunkIdx] = estActualChunkLoaded;\n\t                        qq.each(chunkProgress, function(chunkIdx, chunkLoaded) {\n\t                            totalLoadedForFile += chunkLoaded;\n\t                        });\n\t                        onProgress(id, name, totalLoadedForFile, totalFileSize);\n\t                    }\n\t                };\n\t                xhr.upload.onprogress = function(e) {\n\t                    if (e.lengthComputable) {\n\t                        var type = chunkSize == null ? \"simple\" : \"chunked\";\n\t                        progressCalculator[type](e.loaded, e.total);\n\t                    }\n\t                };\n\t            },\n\t            _registerXhr: function(id, optChunkIdx, xhr, optAjaxRequester) {\n\t                var xhrsId = optChunkIdx == null ? -1 : optChunkIdx, tempState = handler._getFileState(id).temp;\n\t                tempState.xhrs = tempState.xhrs || {};\n\t                tempState.ajaxRequesters = tempState.ajaxRequesters || {};\n\t                tempState.xhrs[xhrsId] = xhr;\n\t                if (optAjaxRequester) {\n\t                    tempState.ajaxRequesters[xhrsId] = optAjaxRequester;\n\t                }\n\t                return xhr;\n\t            },\n\t            _removeExpiredChunkingRecords: function() {\n\t                var expirationDays = resume.recordsExpireIn;\n\t                handler._iterateResumeRecords(function(key, uploadData) {\n\t                    var expirationDate = new Date(uploadData.lastUpdated);\n\t                    expirationDate.setDate(expirationDate.getDate() + expirationDays);\n\t                    if (expirationDate.getTime() <= Date.now()) {\n\t                        log(\"Removing expired resume record with key \" + key);\n\t                        localStorage.removeItem(key);\n\t                    }\n\t                });\n\t            },\n\t            _shouldChunkThisFile: function(id) {\n\t                var state = handler._getFileState(id);\n\t                if (!state.chunking) {\n\t                    handler.reevaluateChunking(id);\n\t                }\n\t                return state.chunking.enabled;\n\t            }\n\t        });\n\t    };\n\t    qq.DeleteFileAjaxRequester = function(o) {\n\t        \"use strict\";\n\t        var requester, options = {\n\t            method: \"DELETE\",\n\t            uuidParamName: \"qquuid\",\n\t            endpointStore: {},\n\t            maxConnections: 3,\n\t            customHeaders: function(id) {\n\t                return {};\n\t            },\n\t            paramsStore: {},\n\t            cors: {\n\t                expected: false,\n\t                sendCredentials: false\n\t            },\n\t            log: function(str, level) {},\n\t            onDelete: function(id) {},\n\t            onDeleteComplete: function(id, xhrOrXdr, isError) {}\n\t        };\n\t        qq.extend(options, o);\n\t        function getMandatedParams() {\n\t            if (options.method.toUpperCase() === \"POST\") {\n\t                return {\n\t                    _method: \"DELETE\"\n\t                };\n\t            }\n\t            return {};\n\t        }\n\t        requester = qq.extend(this, new qq.AjaxRequester({\n\t            acceptHeader: \"application/json\",\n\t            validMethods: [ \"POST\", \"DELETE\" ],\n\t            method: options.method,\n\t            endpointStore: options.endpointStore,\n\t            paramsStore: options.paramsStore,\n\t            mandatedParams: getMandatedParams(),\n\t            maxConnections: options.maxConnections,\n\t            customHeaders: function(id) {\n\t                return options.customHeaders.get(id);\n\t            },\n\t            log: options.log,\n\t            onSend: options.onDelete,\n\t            onComplete: options.onDeleteComplete,\n\t            cors: options.cors\n\t        }));\n\t        qq.extend(this, {\n\t            sendDelete: function(id, uuid, additionalMandatedParams) {\n\t                var additionalOptions = additionalMandatedParams || {};\n\t                options.log(\"Submitting delete file request for \" + id);\n\t                if (options.method === \"DELETE\") {\n\t                    requester.initTransport(id).withPath(uuid).withParams(additionalOptions).send();\n\t                } else {\n\t                    additionalOptions[options.uuidParamName] = uuid;\n\t                    requester.initTransport(id).withParams(additionalOptions).send();\n\t                }\n\t            }\n\t        });\n\t    };\n\t    (function() {\n\t        function detectSubsampling(img) {\n\t            var iw = img.naturalWidth, ih = img.naturalHeight, canvas = document.createElement(\"canvas\"), ctx;\n\t            if (iw * ih > 1024 * 1024) {\n\t                canvas.width = canvas.height = 1;\n\t                ctx = canvas.getContext(\"2d\");\n\t                ctx.drawImage(img, -iw + 1, 0);\n\t                return ctx.getImageData(0, 0, 1, 1).data[3] === 0;\n\t            } else {\n\t                return false;\n\t            }\n\t        }\n\t        function detectVerticalSquash(img, iw, ih) {\n\t            var canvas = document.createElement(\"canvas\"), sy = 0, ey = ih, py = ih, ctx, data, alpha, ratio;\n\t            canvas.width = 1;\n\t            canvas.height = ih;\n\t            ctx = canvas.getContext(\"2d\");\n\t            ctx.drawImage(img, 0, 0);\n\t            data = ctx.getImageData(0, 0, 1, ih).data;\n\t            while (py > sy) {\n\t                alpha = data[(py - 1) * 4 + 3];\n\t                if (alpha === 0) {\n\t                    ey = py;\n\t                } else {\n\t                    sy = py;\n\t                }\n\t                py = ey + sy >> 1;\n\t            }\n\t            ratio = py / ih;\n\t            return ratio === 0 ? 1 : ratio;\n\t        }\n\t        function renderImageToDataURL(img, blob, options, doSquash) {\n\t            var canvas = document.createElement(\"canvas\"), mime = options.mime || \"image/jpeg\", promise = new qq.Promise();\n\t            renderImageToCanvas(img, blob, canvas, options, doSquash).then(function() {\n\t                promise.success(canvas.toDataURL(mime, options.quality || .8));\n\t            });\n\t            return promise;\n\t        }\n\t        function maybeCalculateDownsampledDimensions(spec) {\n\t            var maxPixels = 5241e3;\n\t            if (!qq.ios()) {\n\t                throw new qq.Error(\"Downsampled dimensions can only be reliably calculated for iOS!\");\n\t            }\n\t            if (spec.origHeight * spec.origWidth > maxPixels) {\n\t                return {\n\t                    newHeight: Math.round(Math.sqrt(maxPixels * (spec.origHeight / spec.origWidth))),\n\t                    newWidth: Math.round(Math.sqrt(maxPixels * (spec.origWidth / spec.origHeight)))\n\t                };\n\t            }\n\t        }\n\t        function renderImageToCanvas(img, blob, canvas, options, doSquash) {\n\t            var iw = img.naturalWidth, ih = img.naturalHeight, width = options.width, height = options.height, ctx = canvas.getContext(\"2d\"), promise = new qq.Promise(), modifiedDimensions;\n\t            ctx.save();\n\t            if (options.resize) {\n\t                return renderImageToCanvasWithCustomResizer({\n\t                    blob: blob,\n\t                    canvas: canvas,\n\t                    image: img,\n\t                    imageHeight: ih,\n\t                    imageWidth: iw,\n\t                    orientation: options.orientation,\n\t                    resize: options.resize,\n\t                    targetHeight: height,\n\t                    targetWidth: width\n\t                });\n\t            }\n\t            if (!qq.supportedFeatures.unlimitedScaledImageSize) {\n\t                modifiedDimensions = maybeCalculateDownsampledDimensions({\n\t                    origWidth: width,\n\t                    origHeight: height\n\t                });\n\t                if (modifiedDimensions) {\n\t                    qq.log(qq.format(\"Had to reduce dimensions due to device limitations from {}w / {}h to {}w / {}h\", width, height, modifiedDimensions.newWidth, modifiedDimensions.newHeight), \"warn\");\n\t                    width = modifiedDimensions.newWidth;\n\t                    height = modifiedDimensions.newHeight;\n\t                }\n\t            }\n\t            transformCoordinate(canvas, width, height, options.orientation);\n\t            if (qq.ios()) {\n\t                (function() {\n\t                    if (detectSubsampling(img)) {\n\t                        iw /= 2;\n\t                        ih /= 2;\n\t                    }\n\t                    var d = 1024, tmpCanvas = document.createElement(\"canvas\"), vertSquashRatio = doSquash ? detectVerticalSquash(img, iw, ih) : 1, dw = Math.ceil(d * width / iw), dh = Math.ceil(d * height / ih / vertSquashRatio), sy = 0, dy = 0, tmpCtx, sx, dx;\n\t                    tmpCanvas.width = tmpCanvas.height = d;\n\t                    tmpCtx = tmpCanvas.getContext(\"2d\");\n\t                    while (sy < ih) {\n\t                        sx = 0;\n\t                        dx = 0;\n\t                        while (sx < iw) {\n\t                            tmpCtx.clearRect(0, 0, d, d);\n\t                            tmpCtx.drawImage(img, -sx, -sy);\n\t                            ctx.drawImage(tmpCanvas, 0, 0, d, d, dx, dy, dw, dh);\n\t                            sx += d;\n\t                            dx += dw;\n\t                        }\n\t                        sy += d;\n\t                        dy += dh;\n\t                    }\n\t                    ctx.restore();\n\t                    tmpCanvas = tmpCtx = null;\n\t                })();\n\t            } else {\n\t                ctx.drawImage(img, 0, 0, width, height);\n\t            }\n\t            canvas.qqImageRendered && canvas.qqImageRendered();\n\t            promise.success();\n\t            return promise;\n\t        }\n\t        function renderImageToCanvasWithCustomResizer(resizeInfo) {\n\t            var blob = resizeInfo.blob, image = resizeInfo.image, imageHeight = resizeInfo.imageHeight, imageWidth = resizeInfo.imageWidth, orientation = resizeInfo.orientation, promise = new qq.Promise(), resize = resizeInfo.resize, sourceCanvas = document.createElement(\"canvas\"), sourceCanvasContext = sourceCanvas.getContext(\"2d\"), targetCanvas = resizeInfo.canvas, targetHeight = resizeInfo.targetHeight, targetWidth = resizeInfo.targetWidth;\n\t            transformCoordinate(sourceCanvas, imageWidth, imageHeight, orientation);\n\t            targetCanvas.height = targetHeight;\n\t            targetCanvas.width = targetWidth;\n\t            sourceCanvasContext.drawImage(image, 0, 0);\n\t            resize({\n\t                blob: blob,\n\t                height: targetHeight,\n\t                image: image,\n\t                sourceCanvas: sourceCanvas,\n\t                targetCanvas: targetCanvas,\n\t                width: targetWidth\n\t            }).then(function success() {\n\t                targetCanvas.qqImageRendered && targetCanvas.qqImageRendered();\n\t                promise.success();\n\t            }, promise.failure);\n\t            return promise;\n\t        }\n\t        function transformCoordinate(canvas, width, height, orientation) {\n\t            switch (orientation) {\n\t              case 5:\n\t              case 6:\n\t              case 7:\n\t              case 8:\n\t                canvas.width = height;\n\t                canvas.height = width;\n\t                break;\n\t\n\t              default:\n\t                canvas.width = width;\n\t                canvas.height = height;\n\t            }\n\t            var ctx = canvas.getContext(\"2d\");\n\t            switch (orientation) {\n\t              case 2:\n\t                ctx.translate(width, 0);\n\t                ctx.scale(-1, 1);\n\t                break;\n\t\n\t              case 3:\n\t                ctx.translate(width, height);\n\t                ctx.rotate(Math.PI);\n\t                break;\n\t\n\t              case 4:\n\t                ctx.translate(0, height);\n\t                ctx.scale(1, -1);\n\t                break;\n\t\n\t              case 5:\n\t                ctx.rotate(.5 * Math.PI);\n\t                ctx.scale(1, -1);\n\t                break;\n\t\n\t              case 6:\n\t                ctx.rotate(.5 * Math.PI);\n\t                ctx.translate(0, -height);\n\t                break;\n\t\n\t              case 7:\n\t                ctx.rotate(.5 * Math.PI);\n\t                ctx.translate(width, -height);\n\t                ctx.scale(-1, 1);\n\t                break;\n\t\n\t              case 8:\n\t                ctx.rotate(-.5 * Math.PI);\n\t                ctx.translate(-width, 0);\n\t                break;\n\t\n\t              default:\n\t                break;\n\t            }\n\t        }\n\t        function MegaPixImage(srcImage, errorCallback) {\n\t            var self = this;\n\t            if (window.Blob && srcImage instanceof Blob) {\n\t                (function() {\n\t                    var img = new Image(), URL = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n\t                    if (!URL) {\n\t                        throw Error(\"No createObjectURL function found to create blob url\");\n\t                    }\n\t                    img.src = URL.createObjectURL(srcImage);\n\t                    self.blob = srcImage;\n\t                    srcImage = img;\n\t                })();\n\t            }\n\t            if (!srcImage.naturalWidth && !srcImage.naturalHeight) {\n\t                srcImage.onload = function() {\n\t                    var listeners = self.imageLoadListeners;\n\t                    if (listeners) {\n\t                        self.imageLoadListeners = null;\n\t                        setTimeout(function() {\n\t                            for (var i = 0, len = listeners.length; i < len; i++) {\n\t                                listeners[i]();\n\t                            }\n\t                        }, 0);\n\t                    }\n\t                };\n\t                srcImage.onerror = errorCallback;\n\t                this.imageLoadListeners = [];\n\t            }\n\t            this.srcImage = srcImage;\n\t        }\n\t        MegaPixImage.prototype.render = function(target, options) {\n\t            options = options || {};\n\t            var self = this, imgWidth = this.srcImage.naturalWidth, imgHeight = this.srcImage.naturalHeight, width = options.width, height = options.height, maxWidth = options.maxWidth, maxHeight = options.maxHeight, doSquash = !this.blob || this.blob.type === \"image/jpeg\", tagName = target.tagName.toLowerCase(), opt;\n\t            if (this.imageLoadListeners) {\n\t                this.imageLoadListeners.push(function() {\n\t                    self.render(target, options);\n\t                });\n\t                return;\n\t            }\n\t            if (width && !height) {\n\t                height = imgHeight * width / imgWidth << 0;\n\t            } else if (height && !width) {\n\t                width = imgWidth * height / imgHeight << 0;\n\t            } else {\n\t                width = imgWidth;\n\t                height = imgHeight;\n\t            }\n\t            if (maxWidth && width > maxWidth) {\n\t                width = maxWidth;\n\t                height = imgHeight * width / imgWidth << 0;\n\t            }\n\t            if (maxHeight && height > maxHeight) {\n\t                height = maxHeight;\n\t                width = imgWidth * height / imgHeight << 0;\n\t            }\n\t            opt = {\n\t                width: width,\n\t                height: height\n\t            }, qq.each(options, function(optionsKey, optionsValue) {\n\t                opt[optionsKey] = optionsValue;\n\t            });\n\t            if (tagName === \"img\") {\n\t                (function() {\n\t                    var oldTargetSrc = target.src;\n\t                    renderImageToDataURL(self.srcImage, self.blob, opt, doSquash).then(function(dataUri) {\n\t                        target.src = dataUri;\n\t                        oldTargetSrc === target.src && target.onload();\n\t                    });\n\t                })();\n\t            } else if (tagName === \"canvas\") {\n\t                renderImageToCanvas(this.srcImage, this.blob, target, opt, doSquash);\n\t            }\n\t            if (typeof this.onrender === \"function\") {\n\t                this.onrender(target);\n\t            }\n\t        };\n\t        qq.MegaPixImage = MegaPixImage;\n\t    })();\n\t    qq.ImageGenerator = function(log) {\n\t        \"use strict\";\n\t        function isImg(el) {\n\t            return el.tagName.toLowerCase() === \"img\";\n\t        }\n\t        function isCanvas(el) {\n\t            return el.tagName.toLowerCase() === \"canvas\";\n\t        }\n\t        function isImgCorsSupported() {\n\t            return new Image().crossOrigin !== undefined;\n\t        }\n\t        function isCanvasSupported() {\n\t            var canvas = document.createElement(\"canvas\");\n\t            return canvas.getContext && canvas.getContext(\"2d\");\n\t        }\n\t        function determineMimeOfFileName(nameWithPath) {\n\t            var pathSegments = nameWithPath.split(\"/\"), name = pathSegments[pathSegments.length - 1].split(\"?\")[0], extension = qq.getExtension(name);\n\t            extension = extension && extension.toLowerCase();\n\t            switch (extension) {\n\t              case \"jpeg\":\n\t              case \"jpg\":\n\t                return \"image/jpeg\";\n\t\n\t              case \"png\":\n\t                return \"image/png\";\n\t\n\t              case \"bmp\":\n\t                return \"image/bmp\";\n\t\n\t              case \"gif\":\n\t                return \"image/gif\";\n\t\n\t              case \"tiff\":\n\t              case \"tif\":\n\t                return \"image/tiff\";\n\t            }\n\t        }\n\t        function isCrossOrigin(url) {\n\t            var targetAnchor = document.createElement(\"a\"), targetProtocol, targetHostname, targetPort;\n\t            targetAnchor.href = url;\n\t            targetProtocol = targetAnchor.protocol;\n\t            targetPort = targetAnchor.port;\n\t            targetHostname = targetAnchor.hostname;\n\t            if (targetProtocol.toLowerCase() !== window.location.protocol.toLowerCase()) {\n\t                return true;\n\t            }\n\t            if (targetHostname.toLowerCase() !== window.location.hostname.toLowerCase()) {\n\t                return true;\n\t            }\n\t            if (targetPort !== window.location.port && !qq.ie()) {\n\t                return true;\n\t            }\n\t            return false;\n\t        }\n\t        function registerImgLoadListeners(img, promise) {\n\t            img.onload = function() {\n\t                img.onload = null;\n\t                img.onerror = null;\n\t                promise.success(img);\n\t            };\n\t            img.onerror = function() {\n\t                img.onload = null;\n\t                img.onerror = null;\n\t                log(\"Problem drawing thumbnail!\", \"error\");\n\t                promise.failure(img, \"Problem drawing thumbnail!\");\n\t            };\n\t        }\n\t        function registerCanvasDrawImageListener(canvas, promise) {\n\t            canvas.qqImageRendered = function() {\n\t                promise.success(canvas);\n\t            };\n\t        }\n\t        function registerThumbnailRenderedListener(imgOrCanvas, promise) {\n\t            var registered = isImg(imgOrCanvas) || isCanvas(imgOrCanvas);\n\t            if (isImg(imgOrCanvas)) {\n\t                registerImgLoadListeners(imgOrCanvas, promise);\n\t            } else if (isCanvas(imgOrCanvas)) {\n\t                registerCanvasDrawImageListener(imgOrCanvas, promise);\n\t            } else {\n\t                promise.failure(imgOrCanvas);\n\t                log(qq.format(\"Element container of type {} is not supported!\", imgOrCanvas.tagName), \"error\");\n\t            }\n\t            return registered;\n\t        }\n\t        function draw(fileOrBlob, container, options) {\n\t            var drawPreview = new qq.Promise(), identifier = new qq.Identify(fileOrBlob, log), maxSize = options.maxSize, orient = options.orient == null ? true : options.orient, megapixErrorHandler = function() {\n\t                container.onerror = null;\n\t                container.onload = null;\n\t                log(\"Could not render preview, file may be too large!\", \"error\");\n\t                drawPreview.failure(container, \"Browser cannot render image!\");\n\t            };\n\t            identifier.isPreviewable().then(function(mime) {\n\t                var dummyExif = {\n\t                    parse: function() {\n\t                        return new qq.Promise().success();\n\t                    }\n\t                }, exif = orient ? new qq.Exif(fileOrBlob, log) : dummyExif, mpImg = new qq.MegaPixImage(fileOrBlob, megapixErrorHandler);\n\t                if (registerThumbnailRenderedListener(container, drawPreview)) {\n\t                    exif.parse().then(function(exif) {\n\t                        var orientation = exif && exif.Orientation;\n\t                        mpImg.render(container, {\n\t                            maxWidth: maxSize,\n\t                            maxHeight: maxSize,\n\t                            orientation: orientation,\n\t                            mime: mime,\n\t                            resize: options.customResizeFunction\n\t                        });\n\t                    }, function(failureMsg) {\n\t                        log(qq.format(\"EXIF data could not be parsed ({}).  Assuming orientation = 1.\", failureMsg));\n\t                        mpImg.render(container, {\n\t                            maxWidth: maxSize,\n\t                            maxHeight: maxSize,\n\t                            mime: mime,\n\t                            resize: options.customResizeFunction\n\t                        });\n\t                    });\n\t                }\n\t            }, function() {\n\t                log(\"Not previewable\");\n\t                drawPreview.failure(container, \"Not previewable\");\n\t            });\n\t            return drawPreview;\n\t        }\n\t        function drawOnCanvasOrImgFromUrl(url, canvasOrImg, draw, maxSize, customResizeFunction) {\n\t            var tempImg = new Image(), tempImgRender = new qq.Promise();\n\t            registerThumbnailRenderedListener(tempImg, tempImgRender);\n\t            if (isCrossOrigin(url)) {\n\t                tempImg.crossOrigin = \"anonymous\";\n\t            }\n\t            tempImg.src = url;\n\t            tempImgRender.then(function rendered() {\n\t                registerThumbnailRenderedListener(canvasOrImg, draw);\n\t                var mpImg = new qq.MegaPixImage(tempImg);\n\t                mpImg.render(canvasOrImg, {\n\t                    maxWidth: maxSize,\n\t                    maxHeight: maxSize,\n\t                    mime: determineMimeOfFileName(url),\n\t                    resize: customResizeFunction\n\t                });\n\t            }, draw.failure);\n\t        }\n\t        function drawOnImgFromUrlWithCssScaling(url, img, draw, maxSize) {\n\t            registerThumbnailRenderedListener(img, draw);\n\t            qq(img).css({\n\t                maxWidth: maxSize + \"px\",\n\t                maxHeight: maxSize + \"px\"\n\t            });\n\t            img.src = url;\n\t        }\n\t        function drawFromUrl(url, container, options) {\n\t            var draw = new qq.Promise(), scale = options.scale, maxSize = scale ? options.maxSize : null;\n\t            if (scale && isImg(container)) {\n\t                if (isCanvasSupported()) {\n\t                    if (isCrossOrigin(url) && !isImgCorsSupported()) {\n\t                        drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n\t                    } else {\n\t                        drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n\t                    }\n\t                } else {\n\t                    drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n\t                }\n\t            } else if (isCanvas(container)) {\n\t                drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n\t            } else if (registerThumbnailRenderedListener(container, draw)) {\n\t                container.src = url;\n\t            }\n\t            return draw;\n\t        }\n\t        qq.extend(this, {\n\t            generate: function(fileBlobOrUrl, container, options) {\n\t                if (qq.isString(fileBlobOrUrl)) {\n\t                    log(\"Attempting to update thumbnail based on server response.\");\n\t                    return drawFromUrl(fileBlobOrUrl, container, options || {});\n\t                } else {\n\t                    log(\"Attempting to draw client-side image preview.\");\n\t                    return draw(fileBlobOrUrl, container, options || {});\n\t                }\n\t            }\n\t        });\n\t        this._testing = {};\n\t        this._testing.isImg = isImg;\n\t        this._testing.isCanvas = isCanvas;\n\t        this._testing.isCrossOrigin = isCrossOrigin;\n\t        this._testing.determineMimeOfFileName = determineMimeOfFileName;\n\t    };\n\t    qq.Exif = function(fileOrBlob, log) {\n\t        \"use strict\";\n\t        var TAG_IDS = [ 274 ], TAG_INFO = {\n\t            274: {\n\t                name: \"Orientation\",\n\t                bytes: 2\n\t            }\n\t        };\n\t        function parseLittleEndian(hex) {\n\t            var result = 0, pow = 0;\n\t            while (hex.length > 0) {\n\t                result += parseInt(hex.substring(0, 2), 16) * Math.pow(2, pow);\n\t                hex = hex.substring(2, hex.length);\n\t                pow += 8;\n\t            }\n\t            return result;\n\t        }\n\t        function seekToApp1(offset, promise) {\n\t            var theOffset = offset, thePromise = promise;\n\t            if (theOffset === undefined) {\n\t                theOffset = 2;\n\t                thePromise = new qq.Promise();\n\t            }\n\t            qq.readBlobToHex(fileOrBlob, theOffset, 4).then(function(hex) {\n\t                var match = /^ffe([0-9])/.exec(hex), segmentLength;\n\t                if (match) {\n\t                    if (match[1] !== \"1\") {\n\t                        segmentLength = parseInt(hex.slice(4, 8), 16);\n\t                        seekToApp1(theOffset + segmentLength + 2, thePromise);\n\t                    } else {\n\t                        thePromise.success(theOffset);\n\t                    }\n\t                } else {\n\t                    thePromise.failure(\"No EXIF header to be found!\");\n\t                }\n\t            });\n\t            return thePromise;\n\t        }\n\t        function getApp1Offset() {\n\t            var promise = new qq.Promise();\n\t            qq.readBlobToHex(fileOrBlob, 0, 6).then(function(hex) {\n\t                if (hex.indexOf(\"ffd8\") !== 0) {\n\t                    promise.failure(\"Not a valid JPEG!\");\n\t                } else {\n\t                    seekToApp1().then(function(offset) {\n\t                        promise.success(offset);\n\t                    }, function(error) {\n\t                        promise.failure(error);\n\t                    });\n\t                }\n\t            });\n\t            return promise;\n\t        }\n\t        function isLittleEndian(app1Start) {\n\t            var promise = new qq.Promise();\n\t            qq.readBlobToHex(fileOrBlob, app1Start + 10, 2).then(function(hex) {\n\t                promise.success(hex === \"4949\");\n\t            });\n\t            return promise;\n\t        }\n\t        function getDirEntryCount(app1Start, littleEndian) {\n\t            var promise = new qq.Promise();\n\t            qq.readBlobToHex(fileOrBlob, app1Start + 18, 2).then(function(hex) {\n\t                if (littleEndian) {\n\t                    return promise.success(parseLittleEndian(hex));\n\t                } else {\n\t                    promise.success(parseInt(hex, 16));\n\t                }\n\t            });\n\t            return promise;\n\t        }\n\t        function getIfd(app1Start, dirEntries) {\n\t            var offset = app1Start + 20, bytes = dirEntries * 12;\n\t            return qq.readBlobToHex(fileOrBlob, offset, bytes);\n\t        }\n\t        function getDirEntries(ifdHex) {\n\t            var entries = [], offset = 0;\n\t            while (offset + 24 <= ifdHex.length) {\n\t                entries.push(ifdHex.slice(offset, offset + 24));\n\t                offset += 24;\n\t            }\n\t            return entries;\n\t        }\n\t        function getTagValues(littleEndian, dirEntries) {\n\t            var TAG_VAL_OFFSET = 16, tagsToFind = qq.extend([], TAG_IDS), vals = {};\n\t            qq.each(dirEntries, function(idx, entry) {\n\t                var idHex = entry.slice(0, 4), id = littleEndian ? parseLittleEndian(idHex) : parseInt(idHex, 16), tagsToFindIdx = tagsToFind.indexOf(id), tagValHex, tagName, tagValLength;\n\t                if (tagsToFindIdx >= 0) {\n\t                    tagName = TAG_INFO[id].name;\n\t                    tagValLength = TAG_INFO[id].bytes;\n\t                    tagValHex = entry.slice(TAG_VAL_OFFSET, TAG_VAL_OFFSET + tagValLength * 2);\n\t                    vals[tagName] = littleEndian ? parseLittleEndian(tagValHex) : parseInt(tagValHex, 16);\n\t                    tagsToFind.splice(tagsToFindIdx, 1);\n\t                }\n\t                if (tagsToFind.length === 0) {\n\t                    return false;\n\t                }\n\t            });\n\t            return vals;\n\t        }\n\t        qq.extend(this, {\n\t            parse: function() {\n\t                var parser = new qq.Promise(), onParseFailure = function(message) {\n\t                    log(qq.format(\"EXIF header parse failed: '{}' \", message));\n\t                    parser.failure(message);\n\t                };\n\t                getApp1Offset().then(function(app1Offset) {\n\t                    log(qq.format(\"Moving forward with EXIF header parsing for '{}'\", fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name));\n\t                    isLittleEndian(app1Offset).then(function(littleEndian) {\n\t                        log(qq.format(\"EXIF Byte order is {} endian\", littleEndian ? \"little\" : \"big\"));\n\t                        getDirEntryCount(app1Offset, littleEndian).then(function(dirEntryCount) {\n\t                            log(qq.format(\"Found {} APP1 directory entries\", dirEntryCount));\n\t                            getIfd(app1Offset, dirEntryCount).then(function(ifdHex) {\n\t                                var dirEntries = getDirEntries(ifdHex), tagValues = getTagValues(littleEndian, dirEntries);\n\t                                log(\"Successfully parsed some EXIF tags\");\n\t                                parser.success(tagValues);\n\t                            }, onParseFailure);\n\t                        }, onParseFailure);\n\t                    }, onParseFailure);\n\t                }, onParseFailure);\n\t                return parser;\n\t            }\n\t        });\n\t        this._testing = {};\n\t        this._testing.parseLittleEndian = parseLittleEndian;\n\t    };\n\t    qq.Identify = function(fileOrBlob, log) {\n\t        \"use strict\";\n\t        function isIdentifiable(magicBytes, questionableBytes) {\n\t            var identifiable = false, magicBytesEntries = [].concat(magicBytes);\n\t            qq.each(magicBytesEntries, function(idx, magicBytesArrayEntry) {\n\t                if (questionableBytes.indexOf(magicBytesArrayEntry) === 0) {\n\t                    identifiable = true;\n\t                    return false;\n\t                }\n\t            });\n\t            return identifiable;\n\t        }\n\t        qq.extend(this, {\n\t            isPreviewable: function() {\n\t                var self = this, identifier = new qq.Promise(), previewable = false, name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n\t                log(qq.format(\"Attempting to determine if {} can be rendered in this browser\", name));\n\t                log(\"First pass: check type attribute of blob object.\");\n\t                if (this.isPreviewableSync()) {\n\t                    log(\"Second pass: check for magic bytes in file header.\");\n\t                    qq.readBlobToHex(fileOrBlob, 0, 4).then(function(hex) {\n\t                        qq.each(self.PREVIEWABLE_MIME_TYPES, function(mime, bytes) {\n\t                            if (isIdentifiable(bytes, hex)) {\n\t                                if (mime !== \"image/tiff\" || qq.supportedFeatures.tiffPreviews) {\n\t                                    previewable = true;\n\t                                    identifier.success(mime);\n\t                                }\n\t                                return false;\n\t                            }\n\t                        });\n\t                        log(qq.format(\"'{}' is {} able to be rendered in this browser\", name, previewable ? \"\" : \"NOT\"));\n\t                        if (!previewable) {\n\t                            identifier.failure();\n\t                        }\n\t                    }, function() {\n\t                        log(\"Error reading file w/ name '\" + name + \"'.  Not able to be rendered in this browser.\");\n\t                        identifier.failure();\n\t                    });\n\t                } else {\n\t                    identifier.failure();\n\t                }\n\t                return identifier;\n\t            },\n\t            isPreviewableSync: function() {\n\t                var fileMime = fileOrBlob.type, isRecognizedImage = qq.indexOf(Object.keys(this.PREVIEWABLE_MIME_TYPES), fileMime) >= 0, previewable = false, name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n\t                if (isRecognizedImage) {\n\t                    if (fileMime === \"image/tiff\") {\n\t                        previewable = qq.supportedFeatures.tiffPreviews;\n\t                    } else {\n\t                        previewable = true;\n\t                    }\n\t                }\n\t                !previewable && log(name + \" is not previewable in this browser per the blob's type attr\");\n\t                return previewable;\n\t            }\n\t        });\n\t    };\n\t    qq.Identify.prototype.PREVIEWABLE_MIME_TYPES = {\n\t        \"image/jpeg\": \"ffd8ff\",\n\t        \"image/gif\": \"474946\",\n\t        \"image/png\": \"89504e\",\n\t        \"image/bmp\": \"424d\",\n\t        \"image/tiff\": [ \"49492a00\", \"4d4d002a\" ]\n\t    };\n\t    qq.ImageValidation = function(blob, log) {\n\t        \"use strict\";\n\t        function hasNonZeroLimits(limits) {\n\t            var atLeastOne = false;\n\t            qq.each(limits, function(limit, value) {\n\t                if (value > 0) {\n\t                    atLeastOne = true;\n\t                    return false;\n\t                }\n\t            });\n\t            return atLeastOne;\n\t        }\n\t        function getWidthHeight() {\n\t            var sizeDetermination = new qq.Promise();\n\t            new qq.Identify(blob, log).isPreviewable().then(function() {\n\t                var image = new Image(), url = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n\t                if (url) {\n\t                    image.onerror = function() {\n\t                        log(\"Cannot determine dimensions for image.  May be too large.\", \"error\");\n\t                        sizeDetermination.failure();\n\t                    };\n\t                    image.onload = function() {\n\t                        sizeDetermination.success({\n\t                            width: this.width,\n\t                            height: this.height\n\t                        });\n\t                    };\n\t                    image.src = url.createObjectURL(blob);\n\t                } else {\n\t                    log(\"No createObjectURL function available to generate image URL!\", \"error\");\n\t                    sizeDetermination.failure();\n\t                }\n\t            }, sizeDetermination.failure);\n\t            return sizeDetermination;\n\t        }\n\t        function getFailingLimit(limits, dimensions) {\n\t            var failingLimit;\n\t            qq.each(limits, function(limitName, limitValue) {\n\t                if (limitValue > 0) {\n\t                    var limitMatcher = /(max|min)(Width|Height)/.exec(limitName), dimensionPropName = limitMatcher[2].charAt(0).toLowerCase() + limitMatcher[2].slice(1), actualValue = dimensions[dimensionPropName];\n\t                    switch (limitMatcher[1]) {\n\t                      case \"min\":\n\t                        if (actualValue < limitValue) {\n\t                            failingLimit = limitName;\n\t                            return false;\n\t                        }\n\t                        break;\n\t\n\t                      case \"max\":\n\t                        if (actualValue > limitValue) {\n\t                            failingLimit = limitName;\n\t                            return false;\n\t                        }\n\t                        break;\n\t                    }\n\t                }\n\t            });\n\t            return failingLimit;\n\t        }\n\t        this.validate = function(limits) {\n\t            var validationEffort = new qq.Promise();\n\t            log(\"Attempting to validate image.\");\n\t            if (hasNonZeroLimits(limits)) {\n\t                getWidthHeight().then(function(dimensions) {\n\t                    var failingLimit = getFailingLimit(limits, dimensions);\n\t                    if (failingLimit) {\n\t                        validationEffort.failure(failingLimit);\n\t                    } else {\n\t                        validationEffort.success();\n\t                    }\n\t                }, validationEffort.success);\n\t            } else {\n\t                validationEffort.success();\n\t            }\n\t            return validationEffort;\n\t        };\n\t    };\n\t    qq.Session = function(spec) {\n\t        \"use strict\";\n\t        var options = {\n\t            endpoint: null,\n\t            params: {},\n\t            customHeaders: {},\n\t            cors: {},\n\t            addFileRecord: function(sessionData) {},\n\t            log: function(message, level) {}\n\t        };\n\t        qq.extend(options, spec, true);\n\t        function isJsonResponseValid(response) {\n\t            if (qq.isArray(response)) {\n\t                return true;\n\t            }\n\t            options.log(\"Session response is not an array.\", \"error\");\n\t        }\n\t        function handleFileItems(fileItems, success, xhrOrXdr, promise) {\n\t            var someItemsIgnored = false;\n\t            success = success && isJsonResponseValid(fileItems);\n\t            if (success) {\n\t                qq.each(fileItems, function(idx, fileItem) {\n\t                    if (fileItem.uuid == null) {\n\t                        someItemsIgnored = true;\n\t                        options.log(qq.format(\"Session response item {} did not include a valid UUID - ignoring.\", idx), \"error\");\n\t                    } else if (fileItem.name == null) {\n\t                        someItemsIgnored = true;\n\t                        options.log(qq.format(\"Session response item {} did not include a valid name - ignoring.\", idx), \"error\");\n\t                    } else {\n\t                        try {\n\t                            options.addFileRecord(fileItem);\n\t                            return true;\n\t                        } catch (err) {\n\t                            someItemsIgnored = true;\n\t                            options.log(err.message, \"error\");\n\t                        }\n\t                    }\n\t                    return false;\n\t                });\n\t            }\n\t            promise[success && !someItemsIgnored ? \"success\" : \"failure\"](fileItems, xhrOrXdr);\n\t        }\n\t        this.refresh = function() {\n\t            var refreshEffort = new qq.Promise(), refreshCompleteCallback = function(response, success, xhrOrXdr) {\n\t                handleFileItems(response, success, xhrOrXdr, refreshEffort);\n\t            }, requesterOptions = qq.extend({}, options), requester = new qq.SessionAjaxRequester(qq.extend(requesterOptions, {\n\t                onComplete: refreshCompleteCallback\n\t            }));\n\t            requester.queryServer();\n\t            return refreshEffort;\n\t        };\n\t    };\n\t    qq.SessionAjaxRequester = function(spec) {\n\t        \"use strict\";\n\t        var requester, options = {\n\t            endpoint: null,\n\t            customHeaders: {},\n\t            params: {},\n\t            cors: {\n\t                expected: false,\n\t                sendCredentials: false\n\t            },\n\t            onComplete: function(response, success, xhrOrXdr) {},\n\t            log: function(str, level) {}\n\t        };\n\t        qq.extend(options, spec);\n\t        function onComplete(id, xhrOrXdr, isError) {\n\t            var response = null;\n\t            if (xhrOrXdr.responseText != null) {\n\t                try {\n\t                    response = qq.parseJson(xhrOrXdr.responseText);\n\t                } catch (err) {\n\t                    options.log(\"Problem parsing session response: \" + err.message, \"error\");\n\t                    isError = true;\n\t                }\n\t            }\n\t            options.onComplete(response, !isError, xhrOrXdr);\n\t        }\n\t        requester = qq.extend(this, new qq.AjaxRequester({\n\t            acceptHeader: \"application/json\",\n\t            validMethods: [ \"GET\" ],\n\t            method: \"GET\",\n\t            endpointStore: {\n\t                get: function() {\n\t                    return options.endpoint;\n\t                }\n\t            },\n\t            customHeaders: options.customHeaders,\n\t            log: options.log,\n\t            onComplete: onComplete,\n\t            cors: options.cors\n\t        }));\n\t        qq.extend(this, {\n\t            queryServer: function() {\n\t                var params = qq.extend({}, options.params);\n\t                options.log(\"Session query request.\");\n\t                requester.initTransport(\"sessionRefresh\").withParams(params).withCacheBuster().send();\n\t            }\n\t        });\n\t    };\n\t    qq.Scaler = function(spec, log) {\n\t        \"use strict\";\n\t        var self = this, customResizeFunction = spec.customResizer, includeOriginal = spec.sendOriginal, orient = spec.orient, defaultType = spec.defaultType, defaultQuality = spec.defaultQuality / 100, failedToScaleText = spec.failureText, includeExif = spec.includeExif, sizes = this._getSortedSizes(spec.sizes);\n\t        qq.extend(this, {\n\t            enabled: qq.supportedFeatures.scaling && sizes.length > 0,\n\t            getFileRecords: function(originalFileUuid, originalFileName, originalBlobOrBlobData) {\n\t                var self = this, records = [], originalBlob = originalBlobOrBlobData.blob ? originalBlobOrBlobData.blob : originalBlobOrBlobData, identifier = new qq.Identify(originalBlob, log);\n\t                if (identifier.isPreviewableSync()) {\n\t                    qq.each(sizes, function(idx, sizeRecord) {\n\t                        var outputType = self._determineOutputType({\n\t                            defaultType: defaultType,\n\t                            requestedType: sizeRecord.type,\n\t                            refType: originalBlob.type\n\t                        });\n\t                        records.push({\n\t                            uuid: qq.getUniqueId(),\n\t                            name: self._getName(originalFileName, {\n\t                                name: sizeRecord.name,\n\t                                type: outputType,\n\t                                refType: originalBlob.type\n\t                            }),\n\t                            blob: new qq.BlobProxy(originalBlob, qq.bind(self._generateScaledImage, self, {\n\t                                customResizeFunction: customResizeFunction,\n\t                                maxSize: sizeRecord.maxSize,\n\t                                orient: orient,\n\t                                type: outputType,\n\t                                quality: defaultQuality,\n\t                                failedText: failedToScaleText,\n\t                                includeExif: includeExif,\n\t                                log: log\n\t                            }))\n\t                        });\n\t                    });\n\t                    records.push({\n\t                        uuid: originalFileUuid,\n\t                        name: originalFileName,\n\t                        size: originalBlob.size,\n\t                        blob: includeOriginal ? originalBlob : null\n\t                    });\n\t                } else {\n\t                    records.push({\n\t                        uuid: originalFileUuid,\n\t                        name: originalFileName,\n\t                        size: originalBlob.size,\n\t                        blob: originalBlob\n\t                    });\n\t                }\n\t                return records;\n\t            },\n\t            handleNewFile: function(file, name, uuid, size, fileList, batchId, uuidParamName, api) {\n\t                var self = this, buttonId = file.qqButtonId || file.blob && file.blob.qqButtonId, scaledIds = [], originalId = null, addFileToHandler = api.addFileToHandler, uploadData = api.uploadData, paramsStore = api.paramsStore, proxyGroupId = qq.getUniqueId();\n\t                qq.each(self.getFileRecords(uuid, name, file), function(idx, record) {\n\t                    var blobSize = record.size, id;\n\t                    if (record.blob instanceof qq.BlobProxy) {\n\t                        blobSize = -1;\n\t                    }\n\t                    id = uploadData.addFile({\n\t                        uuid: record.uuid,\n\t                        name: record.name,\n\t                        size: blobSize,\n\t                        batchId: batchId,\n\t                        proxyGroupId: proxyGroupId\n\t                    });\n\t                    if (record.blob instanceof qq.BlobProxy) {\n\t                        scaledIds.push(id);\n\t                    } else {\n\t                        originalId = id;\n\t                    }\n\t                    if (record.blob) {\n\t                        addFileToHandler(id, record.blob);\n\t                        fileList.push({\n\t                            id: id,\n\t                            file: record.blob\n\t                        });\n\t                    } else {\n\t                        uploadData.setStatus(id, qq.status.REJECTED);\n\t                    }\n\t                });\n\t                if (originalId !== null) {\n\t                    qq.each(scaledIds, function(idx, scaledId) {\n\t                        var params = {\n\t                            qqparentuuid: uploadData.retrieve({\n\t                                id: originalId\n\t                            }).uuid,\n\t                            qqparentsize: uploadData.retrieve({\n\t                                id: originalId\n\t                            }).size\n\t                        };\n\t                        params[uuidParamName] = uploadData.retrieve({\n\t                            id: scaledId\n\t                        }).uuid;\n\t                        uploadData.setParentId(scaledId, originalId);\n\t                        paramsStore.addReadOnly(scaledId, params);\n\t                    });\n\t                    if (scaledIds.length) {\n\t                        (function() {\n\t                            var param = {};\n\t                            param[uuidParamName] = uploadData.retrieve({\n\t                                id: originalId\n\t                            }).uuid;\n\t                            paramsStore.addReadOnly(originalId, param);\n\t                        })();\n\t                    }\n\t                }\n\t            }\n\t        });\n\t    };\n\t    qq.extend(qq.Scaler.prototype, {\n\t        scaleImage: function(id, specs, api) {\n\t            \"use strict\";\n\t            if (!qq.supportedFeatures.scaling) {\n\t                throw new qq.Error(\"Scaling is not supported in this browser!\");\n\t            }\n\t            var scalingEffort = new qq.Promise(), log = api.log, file = api.getFile(id), uploadData = api.uploadData.retrieve({\n\t                id: id\n\t            }), name = uploadData && uploadData.name, uuid = uploadData && uploadData.uuid, scalingOptions = {\n\t                customResizer: specs.customResizer,\n\t                sendOriginal: false,\n\t                orient: specs.orient,\n\t                defaultType: specs.type || null,\n\t                defaultQuality: specs.quality,\n\t                failedToScaleText: \"Unable to scale\",\n\t                sizes: [ {\n\t                    name: \"\",\n\t                    maxSize: specs.maxSize\n\t                } ]\n\t            }, scaler = new qq.Scaler(scalingOptions, log);\n\t            if (!qq.Scaler || !qq.supportedFeatures.imagePreviews || !file) {\n\t                scalingEffort.failure();\n\t                log(\"Could not generate requested scaled image for \" + id + \".  \" + \"Scaling is either not possible in this browser, or the file could not be located.\", \"error\");\n\t            } else {\n\t                qq.bind(function() {\n\t                    var record = scaler.getFileRecords(uuid, name, file)[0];\n\t                    if (record && record.blob instanceof qq.BlobProxy) {\n\t                        record.blob.create().then(scalingEffort.success, scalingEffort.failure);\n\t                    } else {\n\t                        log(id + \" is not a scalable image!\", \"error\");\n\t                        scalingEffort.failure();\n\t                    }\n\t                }, this)();\n\t            }\n\t            return scalingEffort;\n\t        },\n\t        _determineOutputType: function(spec) {\n\t            \"use strict\";\n\t            var requestedType = spec.requestedType, defaultType = spec.defaultType, referenceType = spec.refType;\n\t            if (!defaultType && !requestedType) {\n\t                if (referenceType !== \"image/jpeg\") {\n\t                    return \"image/png\";\n\t                }\n\t                return referenceType;\n\t            }\n\t            if (!requestedType) {\n\t                return defaultType;\n\t            }\n\t            if (qq.indexOf(Object.keys(qq.Identify.prototype.PREVIEWABLE_MIME_TYPES), requestedType) >= 0) {\n\t                if (requestedType === \"image/tiff\") {\n\t                    return qq.supportedFeatures.tiffPreviews ? requestedType : defaultType;\n\t                }\n\t                return requestedType;\n\t            }\n\t            return defaultType;\n\t        },\n\t        _getName: function(originalName, scaledVersionProperties) {\n\t            \"use strict\";\n\t            var startOfExt = originalName.lastIndexOf(\".\"), versionType = scaledVersionProperties.type || \"image/png\", referenceType = scaledVersionProperties.refType, scaledName = \"\", scaledExt = qq.getExtension(originalName), nameAppendage = \"\";\n\t            if (scaledVersionProperties.name && scaledVersionProperties.name.trim().length) {\n\t                nameAppendage = \" (\" + scaledVersionProperties.name + \")\";\n\t            }\n\t            if (startOfExt >= 0) {\n\t                scaledName = originalName.substr(0, startOfExt);\n\t                if (referenceType !== versionType) {\n\t                    scaledExt = versionType.split(\"/\")[1];\n\t                }\n\t                scaledName += nameAppendage + \".\" + scaledExt;\n\t            } else {\n\t                scaledName = originalName + nameAppendage;\n\t            }\n\t            return scaledName;\n\t        },\n\t        _getSortedSizes: function(sizes) {\n\t            \"use strict\";\n\t            sizes = qq.extend([], sizes);\n\t            return sizes.sort(function(a, b) {\n\t                if (a.maxSize > b.maxSize) {\n\t                    return 1;\n\t                }\n\t                if (a.maxSize < b.maxSize) {\n\t                    return -1;\n\t                }\n\t                return 0;\n\t            });\n\t        },\n\t        _generateScaledImage: function(spec, sourceFile) {\n\t            \"use strict\";\n\t            var self = this, customResizeFunction = spec.customResizeFunction, log = spec.log, maxSize = spec.maxSize, orient = spec.orient, type = spec.type, quality = spec.quality, failedText = spec.failedText, includeExif = spec.includeExif && sourceFile.type === \"image/jpeg\" && type === \"image/jpeg\", scalingEffort = new qq.Promise(), imageGenerator = new qq.ImageGenerator(log), canvas = document.createElement(\"canvas\");\n\t            log(\"Attempting to generate scaled version for \" + sourceFile.name);\n\t            imageGenerator.generate(sourceFile, canvas, {\n\t                maxSize: maxSize,\n\t                orient: orient,\n\t                customResizeFunction: customResizeFunction\n\t            }).then(function() {\n\t                var scaledImageDataUri = canvas.toDataURL(type, quality), signalSuccess = function() {\n\t                    log(\"Success generating scaled version for \" + sourceFile.name);\n\t                    var blob = qq.dataUriToBlob(scaledImageDataUri);\n\t                    scalingEffort.success(blob);\n\t                };\n\t                if (includeExif) {\n\t                    self._insertExifHeader(sourceFile, scaledImageDataUri, log).then(function(scaledImageDataUriWithExif) {\n\t                        scaledImageDataUri = scaledImageDataUriWithExif;\n\t                        signalSuccess();\n\t                    }, function() {\n\t                        log(\"Problem inserting EXIF header into scaled image.  Using scaled image w/out EXIF data.\", \"error\");\n\t                        signalSuccess();\n\t                    });\n\t                } else {\n\t                    signalSuccess();\n\t                }\n\t            }, function() {\n\t                log(\"Failed attempt to generate scaled version for \" + sourceFile.name, \"error\");\n\t                scalingEffort.failure(failedText);\n\t            });\n\t            return scalingEffort;\n\t        },\n\t        _insertExifHeader: function(originalImage, scaledImageDataUri, log) {\n\t            \"use strict\";\n\t            var reader = new FileReader(), insertionEffort = new qq.Promise(), originalImageDataUri = \"\";\n\t            reader.onload = function() {\n\t                originalImageDataUri = reader.result;\n\t                insertionEffort.success(qq.ExifRestorer.restore(originalImageDataUri, scaledImageDataUri));\n\t            };\n\t            reader.onerror = function() {\n\t                log(\"Problem reading \" + originalImage.name + \" during attempt to transfer EXIF data to scaled version.\", \"error\");\n\t                insertionEffort.failure();\n\t            };\n\t            reader.readAsDataURL(originalImage);\n\t            return insertionEffort;\n\t        },\n\t        _dataUriToBlob: function(dataUri) {\n\t            \"use strict\";\n\t            var byteString, mimeString, arrayBuffer, intArray;\n\t            if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n\t                byteString = atob(dataUri.split(\",\")[1]);\n\t            } else {\n\t                byteString = decodeURI(dataUri.split(\",\")[1]);\n\t            }\n\t            mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n\t            arrayBuffer = new ArrayBuffer(byteString.length);\n\t            intArray = new Uint8Array(arrayBuffer);\n\t            qq.each(byteString, function(idx, character) {\n\t                intArray[idx] = character.charCodeAt(0);\n\t            });\n\t            return this._createBlob(arrayBuffer, mimeString);\n\t        },\n\t        _createBlob: function(data, mime) {\n\t            \"use strict\";\n\t            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, blobBuilder = BlobBuilder && new BlobBuilder();\n\t            if (blobBuilder) {\n\t                blobBuilder.append(data);\n\t                return blobBuilder.getBlob(mime);\n\t            } else {\n\t                return new Blob([ data ], {\n\t                    type: mime\n\t                });\n\t            }\n\t        }\n\t    });\n\t    qq.ExifRestorer = function() {\n\t        var ExifRestorer = {};\n\t        ExifRestorer.KEY_STR = \"ABCDEFGHIJKLMNOP\" + \"QRSTUVWXYZabcdef\" + \"ghijklmnopqrstuv\" + \"wxyz0123456789+/\" + \"=\";\n\t        ExifRestorer.encode64 = function(input) {\n\t            var output = \"\", chr1, chr2, chr3 = \"\", enc1, enc2, enc3, enc4 = \"\", i = 0;\n\t            do {\n\t                chr1 = input[i++];\n\t                chr2 = input[i++];\n\t                chr3 = input[i++];\n\t                enc1 = chr1 >> 2;\n\t                enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n\t                enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n\t                enc4 = chr3 & 63;\n\t                if (isNaN(chr2)) {\n\t                    enc3 = enc4 = 64;\n\t                } else if (isNaN(chr3)) {\n\t                    enc4 = 64;\n\t                }\n\t                output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);\n\t                chr1 = chr2 = chr3 = \"\";\n\t                enc1 = enc2 = enc3 = enc4 = \"\";\n\t            } while (i < input.length);\n\t            return output;\n\t        };\n\t        ExifRestorer.restore = function(origFileBase64, resizedFileBase64) {\n\t            var expectedBase64Header = \"data:image/jpeg;base64,\";\n\t            if (!origFileBase64.match(expectedBase64Header)) {\n\t                return resizedFileBase64;\n\t            }\n\t            var rawImage = this.decode64(origFileBase64.replace(expectedBase64Header, \"\"));\n\t            var segments = this.slice2Segments(rawImage);\n\t            var image = this.exifManipulation(resizedFileBase64, segments);\n\t            return expectedBase64Header + this.encode64(image);\n\t        };\n\t        ExifRestorer.exifManipulation = function(resizedFileBase64, segments) {\n\t            var exifArray = this.getExifArray(segments), newImageArray = this.insertExif(resizedFileBase64, exifArray), aBuffer = new Uint8Array(newImageArray);\n\t            return aBuffer;\n\t        };\n\t        ExifRestorer.getExifArray = function(segments) {\n\t            var seg;\n\t            for (var x = 0; x < segments.length; x++) {\n\t                seg = segments[x];\n\t                if (seg[0] == 255 & seg[1] == 225) {\n\t                    return seg;\n\t                }\n\t            }\n\t            return [];\n\t        };\n\t        ExifRestorer.insertExif = function(resizedFileBase64, exifArray) {\n\t            var imageData = resizedFileBase64.replace(\"data:image/jpeg;base64,\", \"\"), buf = this.decode64(imageData), separatePoint = buf.indexOf(255, 3), mae = buf.slice(0, separatePoint), ato = buf.slice(separatePoint), array = mae;\n\t            array = array.concat(exifArray);\n\t            array = array.concat(ato);\n\t            return array;\n\t        };\n\t        ExifRestorer.slice2Segments = function(rawImageArray) {\n\t            var head = 0, segments = [];\n\t            while (1) {\n\t                if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 218) {\n\t                    break;\n\t                }\n\t                if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 216) {\n\t                    head += 2;\n\t                } else {\n\t                    var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3], endPoint = head + length + 2, seg = rawImageArray.slice(head, endPoint);\n\t                    segments.push(seg);\n\t                    head = endPoint;\n\t                }\n\t                if (head > rawImageArray.length) {\n\t                    break;\n\t                }\n\t            }\n\t            return segments;\n\t        };\n\t        ExifRestorer.decode64 = function(input) {\n\t            var output = \"\", chr1, chr2, chr3 = \"\", enc1, enc2, enc3, enc4 = \"\", i = 0, buf = [];\n\t            var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n\t            if (base64test.exec(input)) {\n\t                throw new Error(\"There were invalid base64 characters in the input text.  \" + \"Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\");\n\t            }\n\t            input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\t            do {\n\t                enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n\t                enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n\t                enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n\t                enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n\t                chr1 = enc1 << 2 | enc2 >> 4;\n\t                chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n\t                chr3 = (enc3 & 3) << 6 | enc4;\n\t                buf.push(chr1);\n\t                if (enc3 != 64) {\n\t                    buf.push(chr2);\n\t                }\n\t                if (enc4 != 64) {\n\t                    buf.push(chr3);\n\t                }\n\t                chr1 = chr2 = chr3 = \"\";\n\t                enc1 = enc2 = enc3 = enc4 = \"\";\n\t            } while (i < input.length);\n\t            return buf;\n\t        };\n\t        return ExifRestorer;\n\t    }();\n\t    qq.TotalProgress = function(callback, getSize) {\n\t        \"use strict\";\n\t        var perFileProgress = {}, totalLoaded = 0, totalSize = 0, lastLoadedSent = -1, lastTotalSent = -1, callbackProxy = function(loaded, total) {\n\t            if (loaded !== lastLoadedSent || total !== lastTotalSent) {\n\t                callback(loaded, total);\n\t            }\n\t            lastLoadedSent = loaded;\n\t            lastTotalSent = total;\n\t        }, noRetryableFiles = function(failed, retryable) {\n\t            var none = true;\n\t            qq.each(failed, function(idx, failedId) {\n\t                if (qq.indexOf(retryable, failedId) >= 0) {\n\t                    none = false;\n\t                    return false;\n\t                }\n\t            });\n\t            return none;\n\t        }, onCancel = function(id) {\n\t            updateTotalProgress(id, -1, -1);\n\t            delete perFileProgress[id];\n\t        }, onAllComplete = function(successful, failed, retryable) {\n\t            if (failed.length === 0 || noRetryableFiles(failed, retryable)) {\n\t                callbackProxy(totalSize, totalSize);\n\t                this.reset();\n\t            }\n\t        }, onNew = function(id) {\n\t            var size = getSize(id);\n\t            if (size > 0) {\n\t                updateTotalProgress(id, 0, size);\n\t                perFileProgress[id] = {\n\t                    loaded: 0,\n\t                    total: size\n\t                };\n\t            }\n\t        }, updateTotalProgress = function(id, newLoaded, newTotal) {\n\t            var oldLoaded = perFileProgress[id] ? perFileProgress[id].loaded : 0, oldTotal = perFileProgress[id] ? perFileProgress[id].total : 0;\n\t            if (newLoaded === -1 && newTotal === -1) {\n\t                totalLoaded -= oldLoaded;\n\t                totalSize -= oldTotal;\n\t            } else {\n\t                if (newLoaded) {\n\t                    totalLoaded += newLoaded - oldLoaded;\n\t                }\n\t                if (newTotal) {\n\t                    totalSize += newTotal - oldTotal;\n\t                }\n\t            }\n\t            callbackProxy(totalLoaded, totalSize);\n\t        };\n\t        qq.extend(this, {\n\t            onAllComplete: onAllComplete,\n\t            onStatusChange: function(id, oldStatus, newStatus) {\n\t                if (newStatus === qq.status.CANCELED || newStatus === qq.status.REJECTED) {\n\t                    onCancel(id);\n\t                } else if (newStatus === qq.status.SUBMITTING) {\n\t                    onNew(id);\n\t                }\n\t            },\n\t            onIndividualProgress: function(id, loaded, total) {\n\t                updateTotalProgress(id, loaded, total);\n\t                perFileProgress[id] = {\n\t                    loaded: loaded,\n\t                    total: total\n\t                };\n\t            },\n\t            onNewSize: function(id) {\n\t                onNew(id);\n\t            },\n\t            reset: function() {\n\t                perFileProgress = {};\n\t                totalLoaded = 0;\n\t                totalSize = 0;\n\t            }\n\t        });\n\t    };\n\t    qq.PasteSupport = function(o) {\n\t        \"use strict\";\n\t        var options, detachPasteHandler;\n\t        options = {\n\t            targetElement: null,\n\t            callbacks: {\n\t                log: function(message, level) {},\n\t                pasteReceived: function(blob) {}\n\t            }\n\t        };\n\t        function isImage(item) {\n\t            return item.type && item.type.indexOf(\"image/\") === 0;\n\t        }\n\t        function registerPasteHandler() {\n\t            detachPasteHandler = qq(options.targetElement).attach(\"paste\", function(event) {\n\t                var clipboardData = event.clipboardData;\n\t                if (clipboardData) {\n\t                    qq.each(clipboardData.items, function(idx, item) {\n\t                        if (isImage(item)) {\n\t                            var blob = item.getAsFile();\n\t                            options.callbacks.pasteReceived(blob);\n\t                        }\n\t                    });\n\t                }\n\t            });\n\t        }\n\t        function unregisterPasteHandler() {\n\t            if (detachPasteHandler) {\n\t                detachPasteHandler();\n\t            }\n\t        }\n\t        qq.extend(options, o);\n\t        registerPasteHandler();\n\t        qq.extend(this, {\n\t            reset: function() {\n\t                unregisterPasteHandler();\n\t            }\n\t        });\n\t    };\n\t    qq.FormSupport = function(options, startUpload, log) {\n\t        \"use strict\";\n\t        var self = this, interceptSubmit = options.interceptSubmit, formEl = options.element, autoUpload = options.autoUpload;\n\t        qq.extend(this, {\n\t            newEndpoint: null,\n\t            newAutoUpload: autoUpload,\n\t            attachedToForm: false,\n\t            getFormInputsAsObject: function() {\n\t                if (formEl == null) {\n\t                    return null;\n\t                }\n\t                return self._form2Obj(formEl);\n\t            }\n\t        });\n\t        function determineNewEndpoint(formEl) {\n\t            if (formEl.getAttribute(\"action\")) {\n\t                self.newEndpoint = formEl.getAttribute(\"action\");\n\t            }\n\t        }\n\t        function validateForm(formEl, nativeSubmit) {\n\t            if (formEl.checkValidity && !formEl.checkValidity()) {\n\t                log(\"Form did not pass validation checks - will not upload.\", \"error\");\n\t                nativeSubmit();\n\t            } else {\n\t                return true;\n\t            }\n\t        }\n\t        function maybeUploadOnSubmit(formEl) {\n\t            var nativeSubmit = formEl.submit;\n\t            qq(formEl).attach(\"submit\", function(event) {\n\t                event = event || window.event;\n\t                if (event.preventDefault) {\n\t                    event.preventDefault();\n\t                } else {\n\t                    event.returnValue = false;\n\t                }\n\t                validateForm(formEl, nativeSubmit) && startUpload();\n\t            });\n\t            formEl.submit = function() {\n\t                validateForm(formEl, nativeSubmit) && startUpload();\n\t            };\n\t        }\n\t        function determineFormEl(formEl) {\n\t            if (formEl) {\n\t                if (qq.isString(formEl)) {\n\t                    formEl = document.getElementById(formEl);\n\t                }\n\t                if (formEl) {\n\t                    log(\"Attaching to form element.\");\n\t                    determineNewEndpoint(formEl);\n\t                    interceptSubmit && maybeUploadOnSubmit(formEl);\n\t                }\n\t            }\n\t            return formEl;\n\t        }\n\t        formEl = determineFormEl(formEl);\n\t        this.attachedToForm = !!formEl;\n\t    };\n\t    qq.extend(qq.FormSupport.prototype, {\n\t        _form2Obj: function(form) {\n\t            \"use strict\";\n\t            var obj = {}, notIrrelevantType = function(type) {\n\t                var irrelevantTypes = [ \"button\", \"image\", \"reset\", \"submit\" ];\n\t                return qq.indexOf(irrelevantTypes, type.toLowerCase()) < 0;\n\t            }, radioOrCheckbox = function(type) {\n\t                return qq.indexOf([ \"checkbox\", \"radio\" ], type.toLowerCase()) >= 0;\n\t            }, ignoreValue = function(el) {\n\t                if (radioOrCheckbox(el.type) && !el.checked) {\n\t                    return true;\n\t                }\n\t                return el.disabled && el.type.toLowerCase() !== \"hidden\";\n\t            }, selectValue = function(select) {\n\t                var value = null;\n\t                qq.each(qq(select).children(), function(idx, child) {\n\t                    if (child.tagName.toLowerCase() === \"option\" && child.selected) {\n\t                        value = child.value;\n\t                        return false;\n\t                    }\n\t                });\n\t                return value;\n\t            };\n\t            qq.each(form.elements, function(idx, el) {\n\t                if ((qq.isInput(el, true) || el.tagName.toLowerCase() === \"textarea\") && notIrrelevantType(el.type) && !ignoreValue(el)) {\n\t                    obj[el.name] = el.value;\n\t                } else if (el.tagName.toLowerCase() === \"select\" && !ignoreValue(el)) {\n\t                    var value = selectValue(el);\n\t                    if (value !== null) {\n\t                        obj[el.name] = value;\n\t                    }\n\t                }\n\t            });\n\t            return obj;\n\t        }\n\t    });\n\t    qq.traditional = qq.traditional || {};\n\t    qq.traditional.FormUploadHandler = function(options, proxy) {\n\t        \"use strict\";\n\t        var handler = this, getName = proxy.getName, getUuid = proxy.getUuid, log = proxy.log;\n\t        function getIframeContentJson(id, iframe) {\n\t            var response, doc, innerHtml;\n\t            try {\n\t                doc = iframe.contentDocument || iframe.contentWindow.document;\n\t                innerHtml = doc.body.innerHTML;\n\t                log(\"converting iframe's innerHTML to JSON\");\n\t                log(\"innerHTML = \" + innerHtml);\n\t                if (innerHtml && innerHtml.match(/^<pre/i)) {\n\t                    innerHtml = doc.body.firstChild.firstChild.nodeValue;\n\t                }\n\t                response = handler._parseJsonResponse(innerHtml);\n\t            } catch (error) {\n\t                log(\"Error when attempting to parse form upload response (\" + error.message + \")\", \"error\");\n\t                response = {\n\t                    success: false\n\t                };\n\t            }\n\t            return response;\n\t        }\n\t        function createForm(id, iframe) {\n\t            var params = options.paramsStore.get(id), method = options.method.toLowerCase() === \"get\" ? \"GET\" : \"POST\", endpoint = options.endpointStore.get(id), name = getName(id);\n\t            params[options.uuidName] = getUuid(id);\n\t            params[options.filenameParam] = name;\n\t            return handler._initFormForUpload({\n\t                method: method,\n\t                endpoint: endpoint,\n\t                params: params,\n\t                paramsInBody: options.paramsInBody,\n\t                targetName: iframe.name\n\t            });\n\t        }\n\t        this.uploadFile = function(id) {\n\t            var input = handler.getInput(id), iframe = handler._createIframe(id), promise = new qq.Promise(), form;\n\t            form = createForm(id, iframe);\n\t            form.appendChild(input);\n\t            handler._attachLoadEvent(iframe, function(responseFromMessage) {\n\t                log(\"iframe loaded\");\n\t                var response = responseFromMessage ? responseFromMessage : getIframeContentJson(id, iframe);\n\t                handler._detachLoadEvent(id);\n\t                if (!options.cors.expected) {\n\t                    qq(iframe).remove();\n\t                }\n\t                if (response.success) {\n\t                    promise.success(response);\n\t                } else {\n\t                    promise.failure(response);\n\t                }\n\t            });\n\t            log(\"Sending upload request for \" + id);\n\t            form.submit();\n\t            qq(form).remove();\n\t            return promise;\n\t        };\n\t        qq.extend(this, new qq.FormUploadHandler({\n\t            options: {\n\t                isCors: options.cors.expected,\n\t                inputName: options.inputName\n\t            },\n\t            proxy: {\n\t                onCancel: options.onCancel,\n\t                getName: getName,\n\t                getUuid: getUuid,\n\t                log: log\n\t            }\n\t        }));\n\t    };\n\t    qq.traditional = qq.traditional || {};\n\t    qq.traditional.XhrUploadHandler = function(spec, proxy) {\n\t        \"use strict\";\n\t        var handler = this, getName = proxy.getName, getSize = proxy.getSize, getUuid = proxy.getUuid, log = proxy.log, multipart = spec.forceMultipart || spec.paramsInBody, addChunkingSpecificParams = function(id, params, chunkData) {\n\t            var size = getSize(id), name = getName(id);\n\t            params[spec.chunking.paramNames.partIndex] = chunkData.part;\n\t            params[spec.chunking.paramNames.partByteOffset] = chunkData.start;\n\t            params[spec.chunking.paramNames.chunkSize] = chunkData.size;\n\t            params[spec.chunking.paramNames.totalParts] = chunkData.count;\n\t            params[spec.totalFileSizeName] = size;\n\t            if (multipart) {\n\t                params[spec.filenameParam] = name;\n\t            }\n\t        }, allChunksDoneRequester = new qq.traditional.AllChunksDoneAjaxRequester({\n\t            cors: spec.cors,\n\t            endpoint: spec.chunking.success.endpoint,\n\t            log: log\n\t        }), createReadyStateChangedHandler = function(id, xhr) {\n\t            var promise = new qq.Promise();\n\t            xhr.onreadystatechange = function() {\n\t                if (xhr.readyState === 4) {\n\t                    var result = onUploadOrChunkComplete(id, xhr);\n\t                    if (result.success) {\n\t                        promise.success(result.response, xhr);\n\t                    } else {\n\t                        promise.failure(result.response, xhr);\n\t                    }\n\t                }\n\t            };\n\t            return promise;\n\t        }, getChunksCompleteParams = function(id) {\n\t            var params = spec.paramsStore.get(id), name = getName(id), size = getSize(id);\n\t            params[spec.uuidName] = getUuid(id);\n\t            params[spec.filenameParam] = name;\n\t            params[spec.totalFileSizeName] = size;\n\t            params[spec.chunking.paramNames.totalParts] = handler._getTotalChunks(id);\n\t            return params;\n\t        }, isErrorUploadResponse = function(xhr, response) {\n\t            return qq.indexOf([ 200, 201, 202, 203, 204 ], xhr.status) < 0 || !response.success || response.reset;\n\t        }, onUploadOrChunkComplete = function(id, xhr) {\n\t            var response;\n\t            log(\"xhr - server response received for \" + id);\n\t            log(\"responseText = \" + xhr.responseText);\n\t            response = parseResponse(true, xhr);\n\t            return {\n\t                success: !isErrorUploadResponse(xhr, response),\n\t                response: response\n\t            };\n\t        }, parseResponse = function(upload, xhr) {\n\t            var response = {};\n\t            try {\n\t                log(qq.format(\"Received response status {} with body: {}\", xhr.status, xhr.responseText));\n\t                response = qq.parseJson(xhr.responseText);\n\t            } catch (error) {\n\t                upload && log(\"Error when attempting to parse xhr response text (\" + error.message + \")\", \"error\");\n\t            }\n\t            return response;\n\t        }, sendChunksCompleteRequest = function(id) {\n\t            var promise = new qq.Promise();\n\t            allChunksDoneRequester.complete(id, handler._createXhr(id), getChunksCompleteParams(id), spec.customHeaders.get(id)).then(function(xhr) {\n\t                promise.success(parseResponse(false, xhr), xhr);\n\t            }, function(xhr) {\n\t                promise.failure(parseResponse(false, xhr), xhr);\n\t            });\n\t            return promise;\n\t        }, setParamsAndGetEntityToSend = function(params, xhr, fileOrBlob, id) {\n\t            var formData = new FormData(), method = spec.method, endpoint = spec.endpointStore.get(id), name = getName(id), size = getSize(id);\n\t            params[spec.uuidName] = getUuid(id);\n\t            params[spec.filenameParam] = name;\n\t            if (multipart) {\n\t                params[spec.totalFileSizeName] = size;\n\t            }\n\t            if (!spec.paramsInBody) {\n\t                if (!multipart) {\n\t                    params[spec.inputName] = name;\n\t                }\n\t                endpoint = qq.obj2url(params, endpoint);\n\t            }\n\t            xhr.open(method, endpoint, true);\n\t            if (spec.cors.expected && spec.cors.sendCredentials) {\n\t                xhr.withCredentials = true;\n\t            }\n\t            if (multipart) {\n\t                if (spec.paramsInBody) {\n\t                    qq.obj2FormData(params, formData);\n\t                }\n\t                formData.append(spec.inputName, fileOrBlob);\n\t                return formData;\n\t            }\n\t            return fileOrBlob;\n\t        }, setUploadHeaders = function(id, xhr) {\n\t            var extraHeaders = spec.customHeaders.get(id), fileOrBlob = handler.getFile(id);\n\t            xhr.setRequestHeader(\"Accept\", \"application/json\");\n\t            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n\t            xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n\t            if (!multipart) {\n\t                xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\n\t                xhr.setRequestHeader(\"X-Mime-Type\", fileOrBlob.type);\n\t            }\n\t            qq.each(extraHeaders, function(name, val) {\n\t                xhr.setRequestHeader(name, val);\n\t            });\n\t        };\n\t        qq.extend(this, {\n\t            uploadChunk: function(id, chunkIdx, resuming) {\n\t                var chunkData = handler._getChunkData(id, chunkIdx), xhr = handler._createXhr(id, chunkIdx), size = getSize(id), promise, toSend, params;\n\t                promise = createReadyStateChangedHandler(id, xhr);\n\t                handler._registerProgressHandler(id, chunkIdx, chunkData.size);\n\t                params = spec.paramsStore.get(id);\n\t                addChunkingSpecificParams(id, params, chunkData);\n\t                if (resuming) {\n\t                    params[spec.resume.paramNames.resuming] = true;\n\t                }\n\t                toSend = setParamsAndGetEntityToSend(params, xhr, chunkData.blob, id);\n\t                setUploadHeaders(id, xhr);\n\t                xhr.send(toSend);\n\t                return promise;\n\t            },\n\t            uploadFile: function(id) {\n\t                var fileOrBlob = handler.getFile(id), promise, xhr, params, toSend;\n\t                xhr = handler._createXhr(id);\n\t                handler._registerProgressHandler(id);\n\t                promise = createReadyStateChangedHandler(id, xhr);\n\t                params = spec.paramsStore.get(id);\n\t                toSend = setParamsAndGetEntityToSend(params, xhr, fileOrBlob, id);\n\t                setUploadHeaders(id, xhr);\n\t                xhr.send(toSend);\n\t                return promise;\n\t            }\n\t        });\n\t        qq.extend(this, new qq.XhrUploadHandler({\n\t            options: qq.extend({\n\t                namespace: \"traditional\"\n\t            }, spec),\n\t            proxy: qq.extend({\n\t                getEndpoint: spec.endpointStore.get\n\t            }, proxy)\n\t        }));\n\t        qq.override(this, function(super_) {\n\t            return {\n\t                finalizeChunks: function(id) {\n\t                    if (spec.chunking.success.endpoint) {\n\t                        return sendChunksCompleteRequest(id);\n\t                    } else {\n\t                        return super_.finalizeChunks(id, qq.bind(parseResponse, this, true));\n\t                    }\n\t                }\n\t            };\n\t        });\n\t    };\n\t    qq.traditional.AllChunksDoneAjaxRequester = function(o) {\n\t        \"use strict\";\n\t        var requester, method = \"POST\", options = {\n\t            cors: {\n\t                allowXdr: false,\n\t                expected: false,\n\t                sendCredentials: false\n\t            },\n\t            endpoint: null,\n\t            log: function(str, level) {}\n\t        }, promises = {}, endpointHandler = {\n\t            get: function(id) {\n\t                return options.endpoint;\n\t            }\n\t        };\n\t        qq.extend(options, o);\n\t        requester = qq.extend(this, new qq.AjaxRequester({\n\t            acceptHeader: \"application/json\",\n\t            validMethods: [ method ],\n\t            method: method,\n\t            endpointStore: endpointHandler,\n\t            allowXRequestedWithAndCacheControl: false,\n\t            cors: options.cors,\n\t            log: options.log,\n\t            onComplete: function(id, xhr, isError) {\n\t                var promise = promises[id];\n\t                delete promises[id];\n\t                if (isError) {\n\t                    promise.failure(xhr);\n\t                } else {\n\t                    promise.success(xhr);\n\t                }\n\t            }\n\t        }));\n\t        qq.extend(this, {\n\t            complete: function(id, xhr, params, headers) {\n\t                var promise = new qq.Promise();\n\t                options.log(\"Submitting All Chunks Done request for \" + id);\n\t                promises[id] = promise;\n\t                requester.initTransport(id).withParams(params).withHeaders(headers).send(xhr);\n\t                return promise;\n\t            }\n\t        });\n\t    };\n\t    qq.DragAndDrop = function(o) {\n\t        \"use strict\";\n\t        var options, HIDE_ZONES_EVENT_NAME = \"qq-hidezones\", HIDE_BEFORE_ENTER_ATTR = \"qq-hide-dropzone\", uploadDropZones = [], droppedFiles = [], disposeSupport = new qq.DisposeSupport();\n\t        options = {\n\t            dropZoneElements: [],\n\t            allowMultipleItems: true,\n\t            classes: {\n\t                dropActive: null\n\t            },\n\t            callbacks: new qq.DragAndDrop.callbacks()\n\t        };\n\t        qq.extend(options, o, true);\n\t        function uploadDroppedFiles(files, uploadDropZone) {\n\t            var filesAsArray = Array.prototype.slice.call(files);\n\t            options.callbacks.dropLog(\"Grabbed \" + files.length + \" dropped files.\");\n\t            uploadDropZone.dropDisabled(false);\n\t            options.callbacks.processingDroppedFilesComplete(filesAsArray, uploadDropZone.getElement());\n\t        }\n\t        function traverseFileTree(entry) {\n\t            var parseEntryPromise = new qq.Promise();\n\t            if (entry.isFile) {\n\t                entry.file(function(file) {\n\t                    var name = entry.name, fullPath = entry.fullPath, indexOfNameInFullPath = fullPath.indexOf(name);\n\t                    fullPath = fullPath.substr(0, indexOfNameInFullPath);\n\t                    if (fullPath.charAt(0) === \"/\") {\n\t                        fullPath = fullPath.substr(1);\n\t                    }\n\t                    file.qqPath = fullPath;\n\t                    droppedFiles.push(file);\n\t                    parseEntryPromise.success();\n\t                }, function(fileError) {\n\t                    options.callbacks.dropLog(\"Problem parsing '\" + entry.fullPath + \"'.  FileError code \" + fileError.code + \".\", \"error\");\n\t                    parseEntryPromise.failure();\n\t                });\n\t            } else if (entry.isDirectory) {\n\t                getFilesInDirectory(entry).then(function allEntriesRead(entries) {\n\t                    var entriesLeft = entries.length;\n\t                    qq.each(entries, function(idx, entry) {\n\t                        traverseFileTree(entry).done(function() {\n\t                            entriesLeft -= 1;\n\t                            if (entriesLeft === 0) {\n\t                                parseEntryPromise.success();\n\t                            }\n\t                        });\n\t                    });\n\t                    if (!entries.length) {\n\t                        parseEntryPromise.success();\n\t                    }\n\t                }, function readFailure(fileError) {\n\t                    options.callbacks.dropLog(\"Problem parsing '\" + entry.fullPath + \"'.  FileError code \" + fileError.code + \".\", \"error\");\n\t                    parseEntryPromise.failure();\n\t                });\n\t            }\n\t            return parseEntryPromise;\n\t        }\n\t        function getFilesInDirectory(entry, reader, accumEntries, existingPromise) {\n\t            var promise = existingPromise || new qq.Promise(), dirReader = reader || entry.createReader();\n\t            dirReader.readEntries(function readSuccess(entries) {\n\t                var newEntries = accumEntries ? accumEntries.concat(entries) : entries;\n\t                if (entries.length) {\n\t                    setTimeout(function() {\n\t                        getFilesInDirectory(entry, dirReader, newEntries, promise);\n\t                    }, 0);\n\t                } else {\n\t                    promise.success(newEntries);\n\t                }\n\t            }, promise.failure);\n\t            return promise;\n\t        }\n\t        function handleDataTransfer(dataTransfer, uploadDropZone) {\n\t            var pendingFolderPromises = [], handleDataTransferPromise = new qq.Promise();\n\t            options.callbacks.processingDroppedFiles();\n\t            uploadDropZone.dropDisabled(true);\n\t            if (dataTransfer.files.length > 1 && !options.allowMultipleItems) {\n\t                options.callbacks.processingDroppedFilesComplete([]);\n\t                options.callbacks.dropError(\"tooManyFilesError\", \"\");\n\t                uploadDropZone.dropDisabled(false);\n\t                handleDataTransferPromise.failure();\n\t            } else {\n\t                droppedFiles = [];\n\t                if (qq.isFolderDropSupported(dataTransfer)) {\n\t                    qq.each(dataTransfer.items, function(idx, item) {\n\t                        var entry = item.webkitGetAsEntry();\n\t                        if (entry) {\n\t                            if (entry.isFile) {\n\t                                droppedFiles.push(item.getAsFile());\n\t                            } else {\n\t                                pendingFolderPromises.push(traverseFileTree(entry).done(function() {\n\t                                    pendingFolderPromises.pop();\n\t                                    if (pendingFolderPromises.length === 0) {\n\t                                        handleDataTransferPromise.success();\n\t                                    }\n\t                                }));\n\t                            }\n\t                        }\n\t                    });\n\t                } else {\n\t                    droppedFiles = dataTransfer.files;\n\t                }\n\t                if (pendingFolderPromises.length === 0) {\n\t                    handleDataTransferPromise.success();\n\t                }\n\t            }\n\t            return handleDataTransferPromise;\n\t        }\n\t        function setupDropzone(dropArea) {\n\t            var dropZone = new qq.UploadDropZone({\n\t                HIDE_ZONES_EVENT_NAME: HIDE_ZONES_EVENT_NAME,\n\t                element: dropArea,\n\t                onEnter: function(e) {\n\t                    qq(dropArea).addClass(options.classes.dropActive);\n\t                    e.stopPropagation();\n\t                },\n\t                onLeaveNotDescendants: function(e) {\n\t                    qq(dropArea).removeClass(options.classes.dropActive);\n\t                },\n\t                onDrop: function(e) {\n\t                    handleDataTransfer(e.dataTransfer, dropZone).then(function() {\n\t                        uploadDroppedFiles(droppedFiles, dropZone);\n\t                    }, function() {\n\t                        options.callbacks.dropLog(\"Drop event DataTransfer parsing failed.  No files will be uploaded.\", \"error\");\n\t                    });\n\t                }\n\t            });\n\t            disposeSupport.addDisposer(function() {\n\t                dropZone.dispose();\n\t            });\n\t            qq(dropArea).hasAttribute(HIDE_BEFORE_ENTER_ATTR) && qq(dropArea).hide();\n\t            uploadDropZones.push(dropZone);\n\t            return dropZone;\n\t        }\n\t        function isFileDrag(dragEvent) {\n\t            var fileDrag;\n\t            qq.each(dragEvent.dataTransfer.types, function(key, val) {\n\t                if (val === \"Files\") {\n\t                    fileDrag = true;\n\t                    return false;\n\t                }\n\t            });\n\t            return fileDrag;\n\t        }\n\t        function leavingDocumentOut(e) {\n\t            if (qq.firefox()) {\n\t                return !e.relatedTarget;\n\t            }\n\t            if (qq.safari()) {\n\t                return e.x < 0 || e.y < 0;\n\t            }\n\t            return e.x === 0 && e.y === 0;\n\t        }\n\t        function setupDragDrop() {\n\t            var dropZones = options.dropZoneElements, maybeHideDropZones = function() {\n\t                setTimeout(function() {\n\t                    qq.each(dropZones, function(idx, dropZone) {\n\t                        qq(dropZone).hasAttribute(HIDE_BEFORE_ENTER_ATTR) && qq(dropZone).hide();\n\t                        qq(dropZone).removeClass(options.classes.dropActive);\n\t                    });\n\t                }, 10);\n\t            };\n\t            qq.each(dropZones, function(idx, dropZone) {\n\t                var uploadDropZone = setupDropzone(dropZone);\n\t                if (dropZones.length && qq.supportedFeatures.fileDrop) {\n\t                    disposeSupport.attach(document, \"dragenter\", function(e) {\n\t                        if (!uploadDropZone.dropDisabled() && isFileDrag(e)) {\n\t                            qq.each(dropZones, function(idx, dropZone) {\n\t                                if (dropZone instanceof HTMLElement && qq(dropZone).hasAttribute(HIDE_BEFORE_ENTER_ATTR)) {\n\t                                    qq(dropZone).css({\n\t                                        display: \"block\"\n\t                                    });\n\t                                }\n\t                            });\n\t                        }\n\t                    });\n\t                }\n\t            });\n\t            disposeSupport.attach(document, \"dragleave\", function(e) {\n\t                if (leavingDocumentOut(e)) {\n\t                    maybeHideDropZones();\n\t                }\n\t            });\n\t            disposeSupport.attach(qq(document).children()[0], \"mouseenter\", function(e) {\n\t                maybeHideDropZones();\n\t            });\n\t            disposeSupport.attach(document, \"drop\", function(e) {\n\t                e.preventDefault();\n\t                maybeHideDropZones();\n\t            });\n\t            disposeSupport.attach(document, HIDE_ZONES_EVENT_NAME, maybeHideDropZones);\n\t        }\n\t        setupDragDrop();\n\t        qq.extend(this, {\n\t            setupExtraDropzone: function(element) {\n\t                options.dropZoneElements.push(element);\n\t                setupDropzone(element);\n\t            },\n\t            removeDropzone: function(element) {\n\t                var i, dzs = options.dropZoneElements;\n\t                for (i in dzs) {\n\t                    if (dzs[i] === element) {\n\t                        return dzs.splice(i, 1);\n\t                    }\n\t                }\n\t            },\n\t            dispose: function() {\n\t                disposeSupport.dispose();\n\t                qq.each(uploadDropZones, function(idx, dropZone) {\n\t                    dropZone.dispose();\n\t                });\n\t            }\n\t        });\n\t    };\n\t    qq.DragAndDrop.callbacks = function() {\n\t        \"use strict\";\n\t        return {\n\t            processingDroppedFiles: function() {},\n\t            processingDroppedFilesComplete: function(files, targetEl) {},\n\t            dropError: function(code, errorSpecifics) {\n\t                qq.log(\"Drag & drop error code '\" + code + \" with these specifics: '\" + errorSpecifics + \"'\", \"error\");\n\t            },\n\t            dropLog: function(message, level) {\n\t                qq.log(message, level);\n\t            }\n\t        };\n\t    };\n\t    qq.UploadDropZone = function(o) {\n\t        \"use strict\";\n\t        var disposeSupport = new qq.DisposeSupport(), options, element, preventDrop, dropOutsideDisabled;\n\t        options = {\n\t            element: null,\n\t            onEnter: function(e) {},\n\t            onLeave: function(e) {},\n\t            onLeaveNotDescendants: function(e) {},\n\t            onDrop: function(e) {}\n\t        };\n\t        qq.extend(options, o);\n\t        element = options.element;\n\t        function dragoverShouldBeCanceled() {\n\t            return qq.safari() || qq.firefox() && qq.windows();\n\t        }\n\t        function disableDropOutside(e) {\n\t            if (!dropOutsideDisabled) {\n\t                if (dragoverShouldBeCanceled) {\n\t                    disposeSupport.attach(document, \"dragover\", function(e) {\n\t                        e.preventDefault();\n\t                    });\n\t                } else {\n\t                    disposeSupport.attach(document, \"dragover\", function(e) {\n\t                        if (e.dataTransfer) {\n\t                            e.dataTransfer.dropEffect = \"none\";\n\t                            e.preventDefault();\n\t                        }\n\t                    });\n\t                }\n\t                dropOutsideDisabled = true;\n\t            }\n\t        }\n\t        function isValidFileDrag(e) {\n\t            if (!qq.supportedFeatures.fileDrop) {\n\t                return false;\n\t            }\n\t            var effectTest, dt = e.dataTransfer, isSafari = qq.safari();\n\t            effectTest = qq.ie() && qq.supportedFeatures.fileDrop ? true : dt.effectAllowed !== \"none\";\n\t            return dt && effectTest && (dt.files || !isSafari && dt.types.contains && dt.types.contains(\"Files\"));\n\t        }\n\t        function isOrSetDropDisabled(isDisabled) {\n\t            if (isDisabled !== undefined) {\n\t                preventDrop = isDisabled;\n\t            }\n\t            return preventDrop;\n\t        }\n\t        function triggerHidezonesEvent() {\n\t            var hideZonesEvent;\n\t            function triggerUsingOldApi() {\n\t                hideZonesEvent = document.createEvent(\"Event\");\n\t                hideZonesEvent.initEvent(options.HIDE_ZONES_EVENT_NAME, true, true);\n\t            }\n\t            if (window.CustomEvent) {\n\t                try {\n\t                    hideZonesEvent = new CustomEvent(options.HIDE_ZONES_EVENT_NAME);\n\t                } catch (err) {\n\t                    triggerUsingOldApi();\n\t                }\n\t            } else {\n\t                triggerUsingOldApi();\n\t            }\n\t            document.dispatchEvent(hideZonesEvent);\n\t        }\n\t        function attachEvents() {\n\t            disposeSupport.attach(element, \"dragover\", function(e) {\n\t                if (!isValidFileDrag(e)) {\n\t                    return;\n\t                }\n\t                var effect = qq.ie() && qq.supportedFeatures.fileDrop ? null : e.dataTransfer.effectAllowed;\n\t                if (effect === \"move\" || effect === \"linkMove\") {\n\t                    e.dataTransfer.dropEffect = \"move\";\n\t                } else {\n\t                    e.dataTransfer.dropEffect = \"copy\";\n\t                }\n\t                e.stopPropagation();\n\t                e.preventDefault();\n\t            });\n\t            disposeSupport.attach(element, \"dragenter\", function(e) {\n\t                if (!isOrSetDropDisabled()) {\n\t                    if (!isValidFileDrag(e)) {\n\t                        return;\n\t                    }\n\t                    options.onEnter(e);\n\t                }\n\t            });\n\t            disposeSupport.attach(element, \"dragleave\", function(e) {\n\t                if (!isValidFileDrag(e)) {\n\t                    return;\n\t                }\n\t                options.onLeave(e);\n\t                var relatedTarget = document.elementFromPoint(e.clientX, e.clientY);\n\t                if (qq(this).contains(relatedTarget)) {\n\t                    return;\n\t                }\n\t                options.onLeaveNotDescendants(e);\n\t            });\n\t            disposeSupport.attach(element, \"drop\", function(e) {\n\t                if (!isOrSetDropDisabled()) {\n\t                    if (!isValidFileDrag(e)) {\n\t                        return;\n\t                    }\n\t                    e.preventDefault();\n\t                    e.stopPropagation();\n\t                    options.onDrop(e);\n\t                    triggerHidezonesEvent();\n\t                }\n\t            });\n\t        }\n\t        disableDropOutside();\n\t        attachEvents();\n\t        qq.extend(this, {\n\t            dropDisabled: function(isDisabled) {\n\t                return isOrSetDropDisabled(isDisabled);\n\t            },\n\t            dispose: function() {\n\t                disposeSupport.dispose();\n\t            },\n\t            getElement: function() {\n\t                return element;\n\t            }\n\t        });\n\t    };\n\t    (function() {\n\t        \"use strict\";\n\t        qq.uiPublicApi = {\n\t            addInitialFiles: function(cannedFileList) {\n\t                this._parent.prototype.addInitialFiles.apply(this, arguments);\n\t                this._templating.addCacheToDom();\n\t            },\n\t            clearStoredFiles: function() {\n\t                this._parent.prototype.clearStoredFiles.apply(this, arguments);\n\t                this._templating.clearFiles();\n\t            },\n\t            addExtraDropzone: function(element) {\n\t                this._dnd && this._dnd.setupExtraDropzone(element);\n\t            },\n\t            removeExtraDropzone: function(element) {\n\t                if (this._dnd) {\n\t                    return this._dnd.removeDropzone(element);\n\t                }\n\t            },\n\t            getItemByFileId: function(id) {\n\t                if (!this._templating.isHiddenForever(id)) {\n\t                    return this._templating.getFileContainer(id);\n\t                }\n\t            },\n\t            reset: function() {\n\t                this._parent.prototype.reset.apply(this, arguments);\n\t                this._templating.reset();\n\t                if (!this._options.button && this._templating.getButton()) {\n\t                    this._defaultButtonId = this._createUploadButton({\n\t                        element: this._templating.getButton(),\n\t                        title: this._options.text.fileInputTitle\n\t                    }).getButtonId();\n\t                }\n\t                if (this._dnd) {\n\t                    this._dnd.dispose();\n\t                    this._dnd = this._setupDragAndDrop();\n\t                }\n\t                this._totalFilesInBatch = 0;\n\t                this._filesInBatchAddedToUi = 0;\n\t                this._setupClickAndEditEventHandlers();\n\t            },\n\t            setName: function(id, newName) {\n\t                var formattedFilename = this._options.formatFileName(newName);\n\t                this._parent.prototype.setName.apply(this, arguments);\n\t                this._templating.updateFilename(id, formattedFilename);\n\t            },\n\t            pauseUpload: function(id) {\n\t                var paused = this._parent.prototype.pauseUpload.apply(this, arguments);\n\t                paused && this._templating.uploadPaused(id);\n\t                return paused;\n\t            },\n\t            continueUpload: function(id) {\n\t                var continued = this._parent.prototype.continueUpload.apply(this, arguments);\n\t                continued && this._templating.uploadContinued(id);\n\t                return continued;\n\t            },\n\t            getId: function(fileContainerOrChildEl) {\n\t                return this._templating.getFileId(fileContainerOrChildEl);\n\t            },\n\t            getDropTarget: function(fileId) {\n\t                var file = this.getFile(fileId);\n\t                return file.qqDropTarget;\n\t            }\n\t        };\n\t        qq.uiPrivateApi = {\n\t            _getButton: function(buttonId) {\n\t                var button = this._parent.prototype._getButton.apply(this, arguments);\n\t                if (!button) {\n\t                    if (buttonId === this._defaultButtonId) {\n\t                        button = this._templating.getButton();\n\t                    }\n\t                }\n\t                return button;\n\t            },\n\t            _removeFileItem: function(fileId) {\n\t                this._templating.removeFile(fileId);\n\t            },\n\t            _setupClickAndEditEventHandlers: function() {\n\t                this._fileButtonsClickHandler = qq.FileButtonsClickHandler && this._bindFileButtonsClickEvent();\n\t                this._focusinEventSupported = !qq.firefox();\n\t                if (this._isEditFilenameEnabled()) {\n\t                    this._filenameClickHandler = this._bindFilenameClickEvent();\n\t                    this._filenameInputFocusInHandler = this._bindFilenameInputFocusInEvent();\n\t                    this._filenameInputFocusHandler = this._bindFilenameInputFocusEvent();\n\t                }\n\t            },\n\t            _setupDragAndDrop: function() {\n\t                var self = this, dropZoneElements = this._options.dragAndDrop.extraDropzones, templating = this._templating, defaultDropZone = templating.getDropZone();\n\t                defaultDropZone && dropZoneElements.push(defaultDropZone);\n\t                return new qq.DragAndDrop({\n\t                    dropZoneElements: dropZoneElements,\n\t                    allowMultipleItems: this._options.multiple,\n\t                    classes: {\n\t                        dropActive: this._options.classes.dropActive\n\t                    },\n\t                    callbacks: {\n\t                        processingDroppedFiles: function() {\n\t                            templating.showDropProcessing();\n\t                        },\n\t                        processingDroppedFilesComplete: function(files, targetEl) {\n\t                            templating.hideDropProcessing();\n\t                            qq.each(files, function(idx, file) {\n\t                                file.qqDropTarget = targetEl;\n\t                            });\n\t                            if (files.length) {\n\t                                self.addFiles(files, null, null);\n\t                            }\n\t                        },\n\t                        dropError: function(code, errorData) {\n\t                            self._itemError(code, errorData);\n\t                        },\n\t                        dropLog: function(message, level) {\n\t                            self.log(message, level);\n\t                        }\n\t                    }\n\t                });\n\t            },\n\t            _bindFileButtonsClickEvent: function() {\n\t                var self = this;\n\t                return new qq.FileButtonsClickHandler({\n\t                    templating: this._templating,\n\t                    log: function(message, lvl) {\n\t                        self.log(message, lvl);\n\t                    },\n\t                    onDeleteFile: function(fileId) {\n\t                        self.deleteFile(fileId);\n\t                    },\n\t                    onCancel: function(fileId) {\n\t                        self.cancel(fileId);\n\t                    },\n\t                    onRetry: function(fileId) {\n\t                        self.retry(fileId);\n\t                    },\n\t                    onPause: function(fileId) {\n\t                        self.pauseUpload(fileId);\n\t                    },\n\t                    onContinue: function(fileId) {\n\t                        self.continueUpload(fileId);\n\t                    },\n\t                    onGetName: function(fileId) {\n\t                        return self.getName(fileId);\n\t                    }\n\t                });\n\t            },\n\t            _isEditFilenameEnabled: function() {\n\t                return this._templating.isEditFilenamePossible() && !this._options.autoUpload && qq.FilenameClickHandler && qq.FilenameInputFocusHandler && qq.FilenameInputFocusHandler;\n\t            },\n\t            _filenameEditHandler: function() {\n\t                var self = this, templating = this._templating;\n\t                return {\n\t                    templating: templating,\n\t                    log: function(message, lvl) {\n\t                        self.log(message, lvl);\n\t                    },\n\t                    onGetUploadStatus: function(fileId) {\n\t                        return self.getUploads({\n\t                            id: fileId\n\t                        }).status;\n\t                    },\n\t                    onGetName: function(fileId) {\n\t                        return self.getName(fileId);\n\t                    },\n\t                    onSetName: function(id, newName) {\n\t                        self.setName(id, newName);\n\t                    },\n\t                    onEditingStatusChange: function(id, isEditing) {\n\t                        var qqInput = qq(templating.getEditInput(id)), qqFileContainer = qq(templating.getFileContainer(id));\n\t                        if (isEditing) {\n\t                            qqInput.addClass(\"qq-editing\");\n\t                            templating.hideFilename(id);\n\t                            templating.hideEditIcon(id);\n\t                        } else {\n\t                            qqInput.removeClass(\"qq-editing\");\n\t                            templating.showFilename(id);\n\t                            templating.showEditIcon(id);\n\t                        }\n\t                        qqFileContainer.addClass(\"qq-temp\").removeClass(\"qq-temp\");\n\t                    }\n\t                };\n\t            },\n\t            _onUploadStatusChange: function(id, oldStatus, newStatus) {\n\t                this._parent.prototype._onUploadStatusChange.apply(this, arguments);\n\t                if (this._isEditFilenameEnabled()) {\n\t                    if (this._templating.getFileContainer(id) && newStatus !== qq.status.SUBMITTED) {\n\t                        this._templating.markFilenameEditable(id);\n\t                        this._templating.hideEditIcon(id);\n\t                    }\n\t                }\n\t                if (oldStatus === qq.status.UPLOAD_RETRYING && newStatus === qq.status.UPLOADING) {\n\t                    this._templating.hideRetry(id);\n\t                    this._templating.setStatusText(id);\n\t                    qq(this._templating.getFileContainer(id)).removeClass(this._classes.retrying);\n\t                } else if (newStatus === qq.status.UPLOAD_FAILED) {\n\t                    this._templating.hidePause(id);\n\t                }\n\t            },\n\t            _bindFilenameInputFocusInEvent: function() {\n\t                var spec = qq.extend({}, this._filenameEditHandler());\n\t                return new qq.FilenameInputFocusInHandler(spec);\n\t            },\n\t            _bindFilenameInputFocusEvent: function() {\n\t                var spec = qq.extend({}, this._filenameEditHandler());\n\t                return new qq.FilenameInputFocusHandler(spec);\n\t            },\n\t            _bindFilenameClickEvent: function() {\n\t                var spec = qq.extend({}, this._filenameEditHandler());\n\t                return new qq.FilenameClickHandler(spec);\n\t            },\n\t            _storeForLater: function(id) {\n\t                this._parent.prototype._storeForLater.apply(this, arguments);\n\t                this._templating.hideSpinner(id);\n\t            },\n\t            _onAllComplete: function(successful, failed) {\n\t                this._parent.prototype._onAllComplete.apply(this, arguments);\n\t                this._templating.resetTotalProgress();\n\t            },\n\t            _onSubmit: function(id, name) {\n\t                var file = this.getFile(id);\n\t                if (file && file.qqPath && this._options.dragAndDrop.reportDirectoryPaths) {\n\t                    this._paramsStore.addReadOnly(id, {\n\t                        qqpath: file.qqPath\n\t                    });\n\t                }\n\t                this._parent.prototype._onSubmit.apply(this, arguments);\n\t                this._addToList(id, name);\n\t            },\n\t            _onSubmitted: function(id) {\n\t                if (this._isEditFilenameEnabled()) {\n\t                    this._templating.markFilenameEditable(id);\n\t                    this._templating.showEditIcon(id);\n\t                    if (!this._focusinEventSupported) {\n\t                        this._filenameInputFocusHandler.addHandler(this._templating.getEditInput(id));\n\t                    }\n\t                }\n\t            },\n\t            _onProgress: function(id, name, loaded, total) {\n\t                this._parent.prototype._onProgress.apply(this, arguments);\n\t                this._templating.updateProgress(id, loaded, total);\n\t                if (Math.round(loaded / total * 100) === 100) {\n\t                    this._templating.hideCancel(id);\n\t                    this._templating.hidePause(id);\n\t                    this._templating.hideProgress(id);\n\t                    this._templating.setStatusText(id, this._options.text.waitingForResponse);\n\t                    this._displayFileSize(id);\n\t                } else {\n\t                    this._displayFileSize(id, loaded, total);\n\t                }\n\t            },\n\t            _onTotalProgress: function(loaded, total) {\n\t                this._parent.prototype._onTotalProgress.apply(this, arguments);\n\t                this._templating.updateTotalProgress(loaded, total);\n\t            },\n\t            _onComplete: function(id, name, result, xhr) {\n\t                var parentRetVal = this._parent.prototype._onComplete.apply(this, arguments), templating = this._templating, fileContainer = templating.getFileContainer(id), self = this;\n\t                function completeUpload(result) {\n\t                    if (!fileContainer) {\n\t                        return;\n\t                    }\n\t                    templating.setStatusText(id);\n\t                    qq(fileContainer).removeClass(self._classes.retrying);\n\t                    templating.hideProgress(id);\n\t                    if (self.getUploads({\n\t                        id: id\n\t                    }).status !== qq.status.UPLOAD_FAILED) {\n\t                        templating.hideCancel(id);\n\t                    }\n\t                    templating.hideSpinner(id);\n\t                    if (result.success) {\n\t                        self._markFileAsSuccessful(id);\n\t                    } else {\n\t                        qq(fileContainer).addClass(self._classes.fail);\n\t                        templating.showCancel(id);\n\t                        if (templating.isRetryPossible() && !self._preventRetries[id]) {\n\t                            qq(fileContainer).addClass(self._classes.retryable);\n\t                            templating.showRetry(id);\n\t                        }\n\t                        self._controlFailureTextDisplay(id, result);\n\t                    }\n\t                }\n\t                if (parentRetVal instanceof qq.Promise) {\n\t                    parentRetVal.done(function(newResult) {\n\t                        completeUpload(newResult);\n\t                    });\n\t                } else {\n\t                    completeUpload(result);\n\t                }\n\t                return parentRetVal;\n\t            },\n\t            _markFileAsSuccessful: function(id) {\n\t                var templating = this._templating;\n\t                if (this._isDeletePossible()) {\n\t                    templating.showDeleteButton(id);\n\t                }\n\t                qq(templating.getFileContainer(id)).addClass(this._classes.success);\n\t                this._maybeUpdateThumbnail(id);\n\t            },\n\t            _onUploadPrep: function(id) {\n\t                this._parent.prototype._onUploadPrep.apply(this, arguments);\n\t                this._templating.showSpinner(id);\n\t            },\n\t            _onUpload: function(id, name) {\n\t                var parentRetVal = this._parent.prototype._onUpload.apply(this, arguments);\n\t                this._templating.showSpinner(id);\n\t                return parentRetVal;\n\t            },\n\t            _onUploadChunk: function(id, chunkData) {\n\t                this._parent.prototype._onUploadChunk.apply(this, arguments);\n\t                if (chunkData.partIndex > 0 && this._handler.isResumable(id)) {\n\t                    this._templating.allowPause(id);\n\t                }\n\t            },\n\t            _onCancel: function(id, name) {\n\t                this._parent.prototype._onCancel.apply(this, arguments);\n\t                this._removeFileItem(id);\n\t                if (this._getNotFinished() === 0) {\n\t                    this._templating.resetTotalProgress();\n\t                }\n\t            },\n\t            _onBeforeAutoRetry: function(id) {\n\t                var retryNumForDisplay, maxAuto, retryNote;\n\t                this._parent.prototype._onBeforeAutoRetry.apply(this, arguments);\n\t                this._showCancelLink(id);\n\t                if (this._options.retry.showAutoRetryNote) {\n\t                    retryNumForDisplay = this._autoRetries[id];\n\t                    maxAuto = this._options.retry.maxAutoAttempts;\n\t                    retryNote = this._options.retry.autoRetryNote.replace(/\\{retryNum\\}/g, retryNumForDisplay);\n\t                    retryNote = retryNote.replace(/\\{maxAuto\\}/g, maxAuto);\n\t                    this._templating.setStatusText(id, retryNote);\n\t                    qq(this._templating.getFileContainer(id)).addClass(this._classes.retrying);\n\t                }\n\t            },\n\t            _onBeforeManualRetry: function(id) {\n\t                if (this._parent.prototype._onBeforeManualRetry.apply(this, arguments)) {\n\t                    this._templating.resetProgress(id);\n\t                    qq(this._templating.getFileContainer(id)).removeClass(this._classes.fail);\n\t                    this._templating.setStatusText(id);\n\t                    this._templating.showSpinner(id);\n\t                    this._showCancelLink(id);\n\t                    return true;\n\t                } else {\n\t                    qq(this._templating.getFileContainer(id)).addClass(this._classes.retryable);\n\t                    this._templating.showRetry(id);\n\t                    return false;\n\t                }\n\t            },\n\t            _onSubmitDelete: function(id) {\n\t                var onSuccessCallback = qq.bind(this._onSubmitDeleteSuccess, this);\n\t                this._parent.prototype._onSubmitDelete.call(this, id, onSuccessCallback);\n\t            },\n\t            _onSubmitDeleteSuccess: function(id, uuid, additionalMandatedParams) {\n\t                if (this._options.deleteFile.forceConfirm) {\n\t                    this._showDeleteConfirm.apply(this, arguments);\n\t                } else {\n\t                    this._sendDeleteRequest.apply(this, arguments);\n\t                }\n\t            },\n\t            _onDeleteComplete: function(id, xhr, isError) {\n\t                this._parent.prototype._onDeleteComplete.apply(this, arguments);\n\t                this._templating.hideSpinner(id);\n\t                if (isError) {\n\t                    this._templating.setStatusText(id, this._options.deleteFile.deletingFailedText);\n\t                    this._templating.showDeleteButton(id);\n\t                } else {\n\t                    this._removeFileItem(id);\n\t                }\n\t            },\n\t            _sendDeleteRequest: function(id, uuid, additionalMandatedParams) {\n\t                this._templating.hideDeleteButton(id);\n\t                this._templating.showSpinner(id);\n\t                this._templating.setStatusText(id, this._options.deleteFile.deletingStatusText);\n\t                this._deleteHandler.sendDelete.apply(this, arguments);\n\t            },\n\t            _showDeleteConfirm: function(id, uuid, mandatedParams) {\n\t                var fileName = this.getName(id), confirmMessage = this._options.deleteFile.confirmMessage.replace(/\\{filename\\}/g, fileName), uuid = this.getUuid(id), deleteRequestArgs = arguments, self = this, retVal;\n\t                retVal = this._options.showConfirm(confirmMessage);\n\t                if (qq.isGenericPromise(retVal)) {\n\t                    retVal.then(function() {\n\t                        self._sendDeleteRequest.apply(self, deleteRequestArgs);\n\t                    });\n\t                } else if (retVal !== false) {\n\t                    self._sendDeleteRequest.apply(self, deleteRequestArgs);\n\t                }\n\t            },\n\t            _addToList: function(id, name, canned) {\n\t                var prependData, prependIndex = 0, dontDisplay = this._handler.isProxied(id) && this._options.scaling.hideScaled, record;\n\t                if (this._options.display.prependFiles) {\n\t                    if (this._totalFilesInBatch > 1 && this._filesInBatchAddedToUi > 0) {\n\t                        prependIndex = this._filesInBatchAddedToUi - 1;\n\t                    }\n\t                    prependData = {\n\t                        index: prependIndex\n\t                    };\n\t                }\n\t                if (!canned) {\n\t                    if (this._options.disableCancelForFormUploads && !qq.supportedFeatures.ajaxUploading) {\n\t                        this._templating.disableCancel();\n\t                    }\n\t                    if (!this._options.multiple) {\n\t                        record = this.getUploads({\n\t                            id: id\n\t                        });\n\t                        this._handledProxyGroup = this._handledProxyGroup || record.proxyGroupId;\n\t                        if (record.proxyGroupId !== this._handledProxyGroup || !record.proxyGroupId) {\n\t                            this._handler.cancelAll();\n\t                            this._clearList();\n\t                            this._handledProxyGroup = null;\n\t                        }\n\t                    }\n\t                }\n\t                if (canned) {\n\t                    this._templating.addFileToCache(id, this._options.formatFileName(name), prependData, dontDisplay);\n\t                    this._templating.updateThumbnail(id, this._thumbnailUrls[id], true, this._options.thumbnails.customResizer);\n\t                } else {\n\t                    this._templating.addFile(id, this._options.formatFileName(name), prependData, dontDisplay);\n\t                    this._templating.generatePreview(id, this.getFile(id), this._options.thumbnails.customResizer);\n\t                }\n\t                this._filesInBatchAddedToUi += 1;\n\t                if (canned || this._options.display.fileSizeOnSubmit && qq.supportedFeatures.ajaxUploading) {\n\t                    this._displayFileSize(id);\n\t                }\n\t            },\n\t            _clearList: function() {\n\t                this._templating.clearFiles();\n\t                this.clearStoredFiles();\n\t            },\n\t            _displayFileSize: function(id, loadedSize, totalSize) {\n\t                var size = this.getSize(id), sizeForDisplay = this._formatSize(size);\n\t                if (size >= 0) {\n\t                    if (loadedSize !== undefined && totalSize !== undefined) {\n\t                        sizeForDisplay = this._formatProgress(loadedSize, totalSize);\n\t                    }\n\t                    this._templating.updateSize(id, sizeForDisplay);\n\t                }\n\t            },\n\t            _formatProgress: function(uploadedSize, totalSize) {\n\t                var message = this._options.text.formatProgress;\n\t                function r(name, replacement) {\n\t                    message = message.replace(name, replacement);\n\t                }\n\t                r(\"{percent}\", Math.round(uploadedSize / totalSize * 100));\n\t                r(\"{total_size}\", this._formatSize(totalSize));\n\t                return message;\n\t            },\n\t            _controlFailureTextDisplay: function(id, response) {\n\t                var mode, responseProperty, failureReason;\n\t                mode = this._options.failedUploadTextDisplay.mode;\n\t                responseProperty = this._options.failedUploadTextDisplay.responseProperty;\n\t                if (mode === \"custom\") {\n\t                    failureReason = response[responseProperty];\n\t                    if (!failureReason) {\n\t                        failureReason = this._options.text.failUpload;\n\t                    }\n\t                    this._templating.setStatusText(id, failureReason);\n\t                    if (this._options.failedUploadTextDisplay.enableTooltip) {\n\t                        this._showTooltip(id, failureReason);\n\t                    }\n\t                } else if (mode === \"default\") {\n\t                    this._templating.setStatusText(id, this._options.text.failUpload);\n\t                } else if (mode !== \"none\") {\n\t                    this.log(\"failedUploadTextDisplay.mode value of '\" + mode + \"' is not valid\", \"warn\");\n\t                }\n\t            },\n\t            _showTooltip: function(id, text) {\n\t                this._templating.getFileContainer(id).title = text;\n\t            },\n\t            _showCancelLink: function(id) {\n\t                if (!this._options.disableCancelForFormUploads || qq.supportedFeatures.ajaxUploading) {\n\t                    this._templating.showCancel(id);\n\t                }\n\t            },\n\t            _itemError: function(code, name, item) {\n\t                var message = this._parent.prototype._itemError.apply(this, arguments);\n\t                this._options.showMessage(message);\n\t            },\n\t            _batchError: function(message) {\n\t                this._parent.prototype._batchError.apply(this, arguments);\n\t                this._options.showMessage(message);\n\t            },\n\t            _setupPastePrompt: function() {\n\t                var self = this;\n\t                this._options.callbacks.onPasteReceived = function() {\n\t                    var message = self._options.paste.namePromptMessage, defaultVal = self._options.paste.defaultName;\n\t                    return self._options.showPrompt(message, defaultVal);\n\t                };\n\t            },\n\t            _fileOrBlobRejected: function(id, name) {\n\t                this._totalFilesInBatch -= 1;\n\t                this._parent.prototype._fileOrBlobRejected.apply(this, arguments);\n\t            },\n\t            _prepareItemsForUpload: function(items, params, endpoint) {\n\t                this._totalFilesInBatch = items.length;\n\t                this._filesInBatchAddedToUi = 0;\n\t                this._parent.prototype._prepareItemsForUpload.apply(this, arguments);\n\t            },\n\t            _maybeUpdateThumbnail: function(fileId) {\n\t                var thumbnailUrl = this._thumbnailUrls[fileId], fileStatus = this.getUploads({\n\t                    id: fileId\n\t                }).status;\n\t                if (fileStatus !== qq.status.DELETED && (thumbnailUrl || this._options.thumbnails.placeholders.waitUntilResponse || !qq.supportedFeatures.imagePreviews)) {\n\t                    this._templating.updateThumbnail(fileId, thumbnailUrl, this._options.thumbnails.customResizer);\n\t                }\n\t            },\n\t            _addCannedFile: function(sessionData) {\n\t                var id = this._parent.prototype._addCannedFile.apply(this, arguments);\n\t                this._addToList(id, this.getName(id), true);\n\t                this._templating.hideSpinner(id);\n\t                this._templating.hideCancel(id);\n\t                this._markFileAsSuccessful(id);\n\t                return id;\n\t            },\n\t            _setSize: function(id, newSize) {\n\t                this._parent.prototype._setSize.apply(this, arguments);\n\t                this._templating.updateSize(id, this._formatSize(newSize));\n\t            },\n\t            _sessionRequestComplete: function() {\n\t                this._templating.addCacheToDom();\n\t                this._parent.prototype._sessionRequestComplete.apply(this, arguments);\n\t            }\n\t        };\n\t    })();\n\t    qq.FineUploader = function(o, namespace) {\n\t        \"use strict\";\n\t        var self = this;\n\t        this._parent = namespace ? qq[namespace].FineUploaderBasic : qq.FineUploaderBasic;\n\t        this._parent.apply(this, arguments);\n\t        qq.extend(this._options, {\n\t            element: null,\n\t            button: null,\n\t            listElement: null,\n\t            dragAndDrop: {\n\t                extraDropzones: [],\n\t                reportDirectoryPaths: false\n\t            },\n\t            text: {\n\t                formatProgress: \"{percent}% of {total_size}\",\n\t                failUpload: \"Upload failed\",\n\t                waitingForResponse: \"Processing...\",\n\t                paused: \"Paused\"\n\t            },\n\t            template: \"qq-template\",\n\t            classes: {\n\t                retrying: \"qq-upload-retrying\",\n\t                retryable: \"qq-upload-retryable\",\n\t                success: \"qq-upload-success\",\n\t                fail: \"qq-upload-fail\",\n\t                editable: \"qq-editable\",\n\t                hide: \"qq-hide\",\n\t                dropActive: \"qq-upload-drop-area-active\"\n\t            },\n\t            failedUploadTextDisplay: {\n\t                mode: \"default\",\n\t                responseProperty: \"error\",\n\t                enableTooltip: true\n\t            },\n\t            messages: {\n\t                tooManyFilesError: \"You may only drop one file\",\n\t                unsupportedBrowser: \"Unrecoverable error - this browser does not permit file uploading of any kind.\"\n\t            },\n\t            retry: {\n\t                showAutoRetryNote: true,\n\t                autoRetryNote: \"Retrying {retryNum}/{maxAuto}...\"\n\t            },\n\t            deleteFile: {\n\t                forceConfirm: false,\n\t                confirmMessage: \"Are you sure you want to delete {filename}?\",\n\t                deletingStatusText: \"Deleting...\",\n\t                deletingFailedText: \"Delete failed\"\n\t            },\n\t            display: {\n\t                fileSizeOnSubmit: false,\n\t                prependFiles: false\n\t            },\n\t            paste: {\n\t                promptForName: false,\n\t                namePromptMessage: \"Please name this image\"\n\t            },\n\t            thumbnails: {\n\t                customResizer: null,\n\t                maxCount: 0,\n\t                placeholders: {\n\t                    waitUntilResponse: false,\n\t                    notAvailablePath: null,\n\t                    waitingPath: null\n\t                },\n\t                timeBetweenThumbs: 750\n\t            },\n\t            scaling: {\n\t                hideScaled: false\n\t            },\n\t            showMessage: function(message) {\n\t                if (self._templating.hasDialog(\"alert\")) {\n\t                    return self._templating.showDialog(\"alert\", message);\n\t                } else {\n\t                    setTimeout(function() {\n\t                        window.alert(message);\n\t                    }, 0);\n\t                }\n\t            },\n\t            showConfirm: function(message) {\n\t                if (self._templating.hasDialog(\"confirm\")) {\n\t                    return self._templating.showDialog(\"confirm\", message);\n\t                } else {\n\t                    return window.confirm(message);\n\t                }\n\t            },\n\t            showPrompt: function(message, defaultValue) {\n\t                if (self._templating.hasDialog(\"prompt\")) {\n\t                    return self._templating.showDialog(\"prompt\", message, defaultValue);\n\t                } else {\n\t                    return window.prompt(message, defaultValue);\n\t                }\n\t            }\n\t        }, true);\n\t        qq.extend(this._options, o, true);\n\t        this._templating = new qq.Templating({\n\t            log: qq.bind(this.log, this),\n\t            templateIdOrEl: this._options.template,\n\t            containerEl: this._options.element,\n\t            fileContainerEl: this._options.listElement,\n\t            button: this._options.button,\n\t            imageGenerator: this._imageGenerator,\n\t            classes: {\n\t                hide: this._options.classes.hide,\n\t                editable: this._options.classes.editable\n\t            },\n\t            limits: {\n\t                maxThumbs: this._options.thumbnails.maxCount,\n\t                timeBetweenThumbs: this._options.thumbnails.timeBetweenThumbs\n\t            },\n\t            placeholders: {\n\t                waitUntilUpdate: this._options.thumbnails.placeholders.waitUntilResponse,\n\t                thumbnailNotAvailable: this._options.thumbnails.placeholders.notAvailablePath,\n\t                waitingForThumbnail: this._options.thumbnails.placeholders.waitingPath\n\t            },\n\t            text: this._options.text\n\t        });\n\t        if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n\t            this._templating.renderFailure(this._options.messages.unsupportedBrowserIos8Safari);\n\t        } else if (!qq.supportedFeatures.uploading || this._options.cors.expected && !qq.supportedFeatures.uploadCors) {\n\t            this._templating.renderFailure(this._options.messages.unsupportedBrowser);\n\t        } else {\n\t            this._wrapCallbacks();\n\t            this._templating.render();\n\t            this._classes = this._options.classes;\n\t            if (!this._options.button && this._templating.getButton()) {\n\t                this._defaultButtonId = this._createUploadButton({\n\t                    element: this._templating.getButton(),\n\t                    title: this._options.text.fileInputTitle\n\t                }).getButtonId();\n\t            }\n\t            this._setupClickAndEditEventHandlers();\n\t            if (qq.DragAndDrop && qq.supportedFeatures.fileDrop) {\n\t                this._dnd = this._setupDragAndDrop();\n\t            }\n\t            if (this._options.paste.targetElement && this._options.paste.promptForName) {\n\t                if (qq.PasteSupport) {\n\t                    this._setupPastePrompt();\n\t                } else {\n\t                    this.log(\"Paste support module not found.\", \"error\");\n\t                }\n\t            }\n\t            this._totalFilesInBatch = 0;\n\t            this._filesInBatchAddedToUi = 0;\n\t        }\n\t    };\n\t    qq.extend(qq.FineUploader.prototype, qq.basePublicApi);\n\t    qq.extend(qq.FineUploader.prototype, qq.basePrivateApi);\n\t    qq.extend(qq.FineUploader.prototype, qq.uiPublicApi);\n\t    qq.extend(qq.FineUploader.prototype, qq.uiPrivateApi);\n\t    qq.Templating = function(spec) {\n\t        \"use strict\";\n\t        var FILE_ID_ATTR = \"qq-file-id\", FILE_CLASS_PREFIX = \"qq-file-id-\", THUMBNAIL_MAX_SIZE_ATTR = \"qq-max-size\", THUMBNAIL_SERVER_SCALE_ATTR = \"qq-server-scale\", HIDE_DROPZONE_ATTR = \"qq-hide-dropzone\", DROPZPONE_TEXT_ATTR = \"qq-drop-area-text\", IN_PROGRESS_CLASS = \"qq-in-progress\", HIDDEN_FOREVER_CLASS = \"qq-hidden-forever\", fileBatch = {\n\t            content: document.createDocumentFragment(),\n\t            map: {}\n\t        }, isCancelDisabled = false, generatedThumbnails = 0, thumbnailQueueMonitorRunning = false, thumbGenerationQueue = [], thumbnailMaxSize = -1, options = {\n\t            log: null,\n\t            limits: {\n\t                maxThumbs: 0,\n\t                timeBetweenThumbs: 750\n\t            },\n\t            templateIdOrEl: \"qq-template\",\n\t            containerEl: null,\n\t            fileContainerEl: null,\n\t            button: null,\n\t            imageGenerator: null,\n\t            classes: {\n\t                hide: \"qq-hide\",\n\t                editable: \"qq-editable\"\n\t            },\n\t            placeholders: {\n\t                waitUntilUpdate: false,\n\t                thumbnailNotAvailable: null,\n\t                waitingForThumbnail: null\n\t            },\n\t            text: {\n\t                paused: \"Paused\"\n\t            }\n\t        }, selectorClasses = {\n\t            button: \"qq-upload-button-selector\",\n\t            alertDialog: \"qq-alert-dialog-selector\",\n\t            dialogCancelButton: \"qq-cancel-button-selector\",\n\t            confirmDialog: \"qq-confirm-dialog-selector\",\n\t            dialogMessage: \"qq-dialog-message-selector\",\n\t            dialogOkButton: \"qq-ok-button-selector\",\n\t            promptDialog: \"qq-prompt-dialog-selector\",\n\t            uploader: \"qq-uploader-selector\",\n\t            drop: \"qq-upload-drop-area-selector\",\n\t            list: \"qq-upload-list-selector\",\n\t            progressBarContainer: \"qq-progress-bar-container-selector\",\n\t            progressBar: \"qq-progress-bar-selector\",\n\t            totalProgressBarContainer: \"qq-total-progress-bar-container-selector\",\n\t            totalProgressBar: \"qq-total-progress-bar-selector\",\n\t            file: \"qq-upload-file-selector\",\n\t            spinner: \"qq-upload-spinner-selector\",\n\t            size: \"qq-upload-size-selector\",\n\t            cancel: \"qq-upload-cancel-selector\",\n\t            pause: \"qq-upload-pause-selector\",\n\t            continueButton: \"qq-upload-continue-selector\",\n\t            deleteButton: \"qq-upload-delete-selector\",\n\t            retry: \"qq-upload-retry-selector\",\n\t            statusText: \"qq-upload-status-text-selector\",\n\t            editFilenameInput: \"qq-edit-filename-selector\",\n\t            editNameIcon: \"qq-edit-filename-icon-selector\",\n\t            dropText: \"qq-upload-drop-area-text-selector\",\n\t            dropProcessing: \"qq-drop-processing-selector\",\n\t            dropProcessingSpinner: \"qq-drop-processing-spinner-selector\",\n\t            thumbnail: \"qq-thumbnail-selector\"\n\t        }, previewGeneration = {}, cachedThumbnailNotAvailableImg = new qq.Promise(), cachedWaitingForThumbnailImg = new qq.Promise(), log, isEditElementsExist, isRetryElementExist, templateHtml, container, fileList, showThumbnails, serverScale, cacheThumbnailPlaceholders = function() {\n\t            var notAvailableUrl = options.placeholders.thumbnailNotAvailable, waitingUrl = options.placeholders.waitingForThumbnail, spec = {\n\t                maxSize: thumbnailMaxSize,\n\t                scale: serverScale\n\t            };\n\t            if (showThumbnails) {\n\t                if (notAvailableUrl) {\n\t                    options.imageGenerator.generate(notAvailableUrl, new Image(), spec).then(function(updatedImg) {\n\t                        cachedThumbnailNotAvailableImg.success(updatedImg);\n\t                    }, function() {\n\t                        cachedThumbnailNotAvailableImg.failure();\n\t                        log(\"Problem loading 'not available' placeholder image at \" + notAvailableUrl, \"error\");\n\t                    });\n\t                } else {\n\t                    cachedThumbnailNotAvailableImg.failure();\n\t                }\n\t                if (waitingUrl) {\n\t                    options.imageGenerator.generate(waitingUrl, new Image(), spec).then(function(updatedImg) {\n\t                        cachedWaitingForThumbnailImg.success(updatedImg);\n\t                    }, function() {\n\t                        cachedWaitingForThumbnailImg.failure();\n\t                        log(\"Problem loading 'waiting for thumbnail' placeholder image at \" + waitingUrl, \"error\");\n\t                    });\n\t                } else {\n\t                    cachedWaitingForThumbnailImg.failure();\n\t                }\n\t            }\n\t        }, displayWaitingImg = function(thumbnail) {\n\t            var waitingImgPlacement = new qq.Promise();\n\t            cachedWaitingForThumbnailImg.then(function(img) {\n\t                maybeScalePlaceholderViaCss(img, thumbnail);\n\t                if (!thumbnail.src) {\n\t                    thumbnail.src = img.src;\n\t                    thumbnail.onload = function() {\n\t                        thumbnail.onload = null;\n\t                        show(thumbnail);\n\t                        waitingImgPlacement.success();\n\t                    };\n\t                } else {\n\t                    waitingImgPlacement.success();\n\t                }\n\t            }, function() {\n\t                hide(thumbnail);\n\t                waitingImgPlacement.success();\n\t            });\n\t            return waitingImgPlacement;\n\t        }, generateNewPreview = function(id, blob, spec) {\n\t            var thumbnail = getThumbnail(id);\n\t            log(\"Generating new thumbnail for \" + id);\n\t            blob.qqThumbnailId = id;\n\t            return options.imageGenerator.generate(blob, thumbnail, spec).then(function() {\n\t                generatedThumbnails++;\n\t                show(thumbnail);\n\t                previewGeneration[id].success();\n\t            }, function() {\n\t                previewGeneration[id].failure();\n\t                if (!options.placeholders.waitUntilUpdate) {\n\t                    maybeSetDisplayNotAvailableImg(id, thumbnail);\n\t                }\n\t            });\n\t        }, generateNextQueuedPreview = function() {\n\t            if (thumbGenerationQueue.length) {\n\t                thumbnailQueueMonitorRunning = true;\n\t                var queuedThumbRequest = thumbGenerationQueue.shift();\n\t                if (queuedThumbRequest.update) {\n\t                    processUpdateQueuedPreviewRequest(queuedThumbRequest);\n\t                } else {\n\t                    processNewQueuedPreviewRequest(queuedThumbRequest);\n\t                }\n\t            } else {\n\t                thumbnailQueueMonitorRunning = false;\n\t            }\n\t        }, getCancel = function(id) {\n\t            return getTemplateEl(getFile(id), selectorClasses.cancel);\n\t        }, getContinue = function(id) {\n\t            return getTemplateEl(getFile(id), selectorClasses.continueButton);\n\t        }, getDialog = function(type) {\n\t            return getTemplateEl(container, selectorClasses[type + \"Dialog\"]);\n\t        }, getDelete = function(id) {\n\t            return getTemplateEl(getFile(id), selectorClasses.deleteButton);\n\t        }, getDropProcessing = function() {\n\t            return getTemplateEl(container, selectorClasses.dropProcessing);\n\t        }, getEditIcon = function(id) {\n\t            return getTemplateEl(getFile(id), selectorClasses.editNameIcon);\n\t        }, getFile = function(id) {\n\t            return fileBatch.map[id] || qq(fileList).getFirstByClass(FILE_CLASS_PREFIX + id);\n\t        }, getFilename = function(id) {\n\t            return getTemplateEl(getFile(id), selectorClasses.file);\n\t        }, getPause = function(id) {\n\t            return getTemplateEl(getFile(id), selectorClasses.pause);\n\t        }, getProgress = function(id) {\n\t            if (id == null) {\n\t                return getTemplateEl(container, selectorClasses.totalProgressBarContainer) || getTemplateEl(container, selectorClasses.totalProgressBar);\n\t            }\n\t            return getTemplateEl(getFile(id), selectorClasses.progressBarContainer) || getTemplateEl(getFile(id), selectorClasses.progressBar);\n\t        }, getRetry = function(id) {\n\t            return getTemplateEl(getFile(id), selectorClasses.retry);\n\t        }, getSize = function(id) {\n\t            return getTemplateEl(getFile(id), selectorClasses.size);\n\t        }, getSpinner = function(id) {\n\t            return getTemplateEl(getFile(id), selectorClasses.spinner);\n\t        }, getTemplateEl = function(context, cssClass) {\n\t            return context && qq(context).getFirstByClass(cssClass);\n\t        }, getThumbnail = function(id) {\n\t            return showThumbnails && getTemplateEl(getFile(id), selectorClasses.thumbnail);\n\t        }, hide = function(el) {\n\t            el && qq(el).addClass(options.classes.hide);\n\t        }, maybeScalePlaceholderViaCss = function(placeholder, thumbnail) {\n\t            var maxWidth = placeholder.style.maxWidth, maxHeight = placeholder.style.maxHeight;\n\t            if (maxHeight && maxWidth && !thumbnail.style.maxWidth && !thumbnail.style.maxHeight) {\n\t                qq(thumbnail).css({\n\t                    maxWidth: maxWidth,\n\t                    maxHeight: maxHeight\n\t                });\n\t            }\n\t        }, maybeSetDisplayNotAvailableImg = function(id, thumbnail) {\n\t            var previewing = previewGeneration[id] || new qq.Promise().failure(), notAvailableImgPlacement = new qq.Promise();\n\t            cachedThumbnailNotAvailableImg.then(function(img) {\n\t                previewing.then(function() {\n\t                    notAvailableImgPlacement.success();\n\t                }, function() {\n\t                    maybeScalePlaceholderViaCss(img, thumbnail);\n\t                    thumbnail.onload = function() {\n\t                        thumbnail.onload = null;\n\t                        notAvailableImgPlacement.success();\n\t                    };\n\t                    thumbnail.src = img.src;\n\t                    show(thumbnail);\n\t                });\n\t            });\n\t            return notAvailableImgPlacement;\n\t        }, parseAndGetTemplate = function() {\n\t            var scriptEl, scriptHtml, fileListNode, tempTemplateEl, fileListHtml, defaultButton, dropArea, thumbnail, dropProcessing, dropTextEl, uploaderEl;\n\t            log(\"Parsing template\");\n\t            if (options.templateIdOrEl == null) {\n\t                throw new Error(\"You MUST specify either a template element or ID!\");\n\t            }\n\t            if (qq.isString(options.templateIdOrEl)) {\n\t                scriptEl = document.getElementById(options.templateIdOrEl);\n\t                if (scriptEl === null) {\n\t                    throw new Error(qq.format(\"Cannot find template script at ID '{}'!\", options.templateIdOrEl));\n\t                }\n\t                scriptHtml = scriptEl.innerHTML;\n\t            } else {\n\t                if (options.templateIdOrEl.innerHTML === undefined) {\n\t                    throw new Error(\"You have specified an invalid value for the template option!  \" + \"It must be an ID or an Element.\");\n\t                }\n\t                scriptHtml = options.templateIdOrEl.innerHTML;\n\t            }\n\t            scriptHtml = qq.trimStr(scriptHtml);\n\t            tempTemplateEl = document.createElement(\"div\");\n\t            tempTemplateEl.appendChild(qq.toElement(scriptHtml));\n\t            uploaderEl = qq(tempTemplateEl).getFirstByClass(selectorClasses.uploader);\n\t            if (options.button) {\n\t                defaultButton = qq(tempTemplateEl).getFirstByClass(selectorClasses.button);\n\t                if (defaultButton) {\n\t                    qq(defaultButton).remove();\n\t                }\n\t            }\n\t            if (!qq.DragAndDrop || !qq.supportedFeatures.fileDrop) {\n\t                dropProcessing = qq(tempTemplateEl).getFirstByClass(selectorClasses.dropProcessing);\n\t                if (dropProcessing) {\n\t                    qq(dropProcessing).remove();\n\t                }\n\t            }\n\t            dropArea = qq(tempTemplateEl).getFirstByClass(selectorClasses.drop);\n\t            if (dropArea && !qq.DragAndDrop) {\n\t                log(\"DnD module unavailable.\", \"info\");\n\t                qq(dropArea).remove();\n\t            }\n\t            if (!qq.supportedFeatures.fileDrop) {\n\t                uploaderEl.removeAttribute(DROPZPONE_TEXT_ATTR);\n\t                if (dropArea && qq(dropArea).hasAttribute(HIDE_DROPZONE_ATTR)) {\n\t                    qq(dropArea).css({\n\t                        display: \"none\"\n\t                    });\n\t                }\n\t            } else if (qq(uploaderEl).hasAttribute(DROPZPONE_TEXT_ATTR) && dropArea) {\n\t                dropTextEl = qq(dropArea).getFirstByClass(selectorClasses.dropText);\n\t                dropTextEl && qq(dropTextEl).remove();\n\t            }\n\t            thumbnail = qq(tempTemplateEl).getFirstByClass(selectorClasses.thumbnail);\n\t            if (!showThumbnails) {\n\t                thumbnail && qq(thumbnail).remove();\n\t            } else if (thumbnail) {\n\t                thumbnailMaxSize = parseInt(thumbnail.getAttribute(THUMBNAIL_MAX_SIZE_ATTR));\n\t                thumbnailMaxSize = thumbnailMaxSize > 0 ? thumbnailMaxSize : null;\n\t                serverScale = qq(thumbnail).hasAttribute(THUMBNAIL_SERVER_SCALE_ATTR);\n\t            }\n\t            showThumbnails = showThumbnails && thumbnail;\n\t            isEditElementsExist = qq(tempTemplateEl).getByClass(selectorClasses.editFilenameInput).length > 0;\n\t            isRetryElementExist = qq(tempTemplateEl).getByClass(selectorClasses.retry).length > 0;\n\t            fileListNode = qq(tempTemplateEl).getFirstByClass(selectorClasses.list);\n\t            if (fileListNode == null) {\n\t                throw new Error(\"Could not find the file list container in the template!\");\n\t            }\n\t            fileListHtml = fileListNode.innerHTML;\n\t            fileListNode.innerHTML = \"\";\n\t            if (tempTemplateEl.getElementsByTagName(\"DIALOG\").length) {\n\t                document.createElement(\"dialog\");\n\t            }\n\t            log(\"Template parsing complete\");\n\t            return {\n\t                template: qq.trimStr(tempTemplateEl.innerHTML),\n\t                fileTemplate: qq.trimStr(fileListHtml)\n\t            };\n\t        }, prependFile = function(el, index, fileList) {\n\t            var parentEl = fileList, beforeEl = parentEl.firstChild;\n\t            if (index > 0) {\n\t                beforeEl = qq(parentEl).children()[index].nextSibling;\n\t            }\n\t            parentEl.insertBefore(el, beforeEl);\n\t        }, processNewQueuedPreviewRequest = function(queuedThumbRequest) {\n\t            var id = queuedThumbRequest.id, optFileOrBlob = queuedThumbRequest.optFileOrBlob, relatedThumbnailId = optFileOrBlob && optFileOrBlob.qqThumbnailId, thumbnail = getThumbnail(id), spec = {\n\t                customResizeFunction: queuedThumbRequest.customResizeFunction,\n\t                maxSize: thumbnailMaxSize,\n\t                orient: true,\n\t                scale: true\n\t            };\n\t            if (qq.supportedFeatures.imagePreviews) {\n\t                if (thumbnail) {\n\t                    if (options.limits.maxThumbs && options.limits.maxThumbs <= generatedThumbnails) {\n\t                        maybeSetDisplayNotAvailableImg(id, thumbnail);\n\t                        generateNextQueuedPreview();\n\t                    } else {\n\t                        displayWaitingImg(thumbnail).done(function() {\n\t                            previewGeneration[id] = new qq.Promise();\n\t                            previewGeneration[id].done(function() {\n\t                                setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n\t                            });\n\t                            if (relatedThumbnailId != null) {\n\t                                useCachedPreview(id, relatedThumbnailId);\n\t                            } else {\n\t                                generateNewPreview(id, optFileOrBlob, spec);\n\t                            }\n\t                        });\n\t                    }\n\t                } else {\n\t                    generateNextQueuedPreview();\n\t                }\n\t            } else if (thumbnail) {\n\t                displayWaitingImg(thumbnail);\n\t                generateNextQueuedPreview();\n\t            }\n\t        }, processUpdateQueuedPreviewRequest = function(queuedThumbRequest) {\n\t            var id = queuedThumbRequest.id, thumbnailUrl = queuedThumbRequest.thumbnailUrl, showWaitingImg = queuedThumbRequest.showWaitingImg, thumbnail = getThumbnail(id), spec = {\n\t                customResizeFunction: queuedThumbRequest.customResizeFunction,\n\t                scale: serverScale,\n\t                maxSize: thumbnailMaxSize\n\t            };\n\t            if (thumbnail) {\n\t                if (thumbnailUrl) {\n\t                    if (options.limits.maxThumbs && options.limits.maxThumbs <= generatedThumbnails) {\n\t                        maybeSetDisplayNotAvailableImg(id, thumbnail);\n\t                        generateNextQueuedPreview();\n\t                    } else {\n\t                        if (showWaitingImg) {\n\t                            displayWaitingImg(thumbnail);\n\t                        }\n\t                        return options.imageGenerator.generate(thumbnailUrl, thumbnail, spec).then(function() {\n\t                            show(thumbnail);\n\t                            generatedThumbnails++;\n\t                            setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n\t                        }, function() {\n\t                            maybeSetDisplayNotAvailableImg(id, thumbnail);\n\t                            setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n\t                        });\n\t                    }\n\t                } else {\n\t                    maybeSetDisplayNotAvailableImg(id, thumbnail);\n\t                    generateNextQueuedPreview();\n\t                }\n\t            }\n\t        }, setProgressBarWidth = function(id, percent) {\n\t            var bar = getProgress(id), progressBarSelector = id == null ? selectorClasses.totalProgressBar : selectorClasses.progressBar;\n\t            if (bar && !qq(bar).hasClass(progressBarSelector)) {\n\t                bar = qq(bar).getFirstByClass(progressBarSelector);\n\t            }\n\t            if (bar) {\n\t                qq(bar).css({\n\t                    width: percent + \"%\"\n\t                });\n\t                bar.setAttribute(\"aria-valuenow\", percent);\n\t            }\n\t        }, show = function(el) {\n\t            el && qq(el).removeClass(options.classes.hide);\n\t        }, useCachedPreview = function(targetThumbnailId, cachedThumbnailId) {\n\t            var targetThumbnail = getThumbnail(targetThumbnailId), cachedThumbnail = getThumbnail(cachedThumbnailId);\n\t            log(qq.format(\"ID {} is the same file as ID {}.  Will use generated thumbnail from ID {} instead.\", targetThumbnailId, cachedThumbnailId, cachedThumbnailId));\n\t            previewGeneration[cachedThumbnailId].then(function() {\n\t                generatedThumbnails++;\n\t                previewGeneration[targetThumbnailId].success();\n\t                log(qq.format(\"Now using previously generated thumbnail created for ID {} on ID {}.\", cachedThumbnailId, targetThumbnailId));\n\t                targetThumbnail.src = cachedThumbnail.src;\n\t                show(targetThumbnail);\n\t            }, function() {\n\t                previewGeneration[targetThumbnailId].failure();\n\t                if (!options.placeholders.waitUntilUpdate) {\n\t                    maybeSetDisplayNotAvailableImg(targetThumbnailId, targetThumbnail);\n\t                }\n\t            });\n\t        };\n\t        qq.extend(options, spec);\n\t        log = options.log;\n\t        if (!qq.supportedFeatures.imagePreviews) {\n\t            options.limits.timeBetweenThumbs = 0;\n\t            options.limits.maxThumbs = 0;\n\t        }\n\t        container = options.containerEl;\n\t        showThumbnails = options.imageGenerator !== undefined;\n\t        templateHtml = parseAndGetTemplate();\n\t        cacheThumbnailPlaceholders();\n\t        qq.extend(this, {\n\t            render: function() {\n\t                log(\"Rendering template in DOM.\");\n\t                generatedThumbnails = 0;\n\t                container.innerHTML = templateHtml.template;\n\t                hide(getDropProcessing());\n\t                this.hideTotalProgress();\n\t                fileList = options.fileContainerEl || getTemplateEl(container, selectorClasses.list);\n\t                log(\"Template rendering complete\");\n\t            },\n\t            renderFailure: function(message) {\n\t                var cantRenderEl = qq.toElement(message);\n\t                container.innerHTML = \"\";\n\t                container.appendChild(cantRenderEl);\n\t            },\n\t            reset: function() {\n\t                this.render();\n\t            },\n\t            clearFiles: function() {\n\t                fileList.innerHTML = \"\";\n\t            },\n\t            disableCancel: function() {\n\t                isCancelDisabled = true;\n\t            },\n\t            addFile: function(id, name, prependInfo, hideForever, batch) {\n\t                var fileEl = qq.toElement(templateHtml.fileTemplate), fileNameEl = getTemplateEl(fileEl, selectorClasses.file), uploaderEl = getTemplateEl(container, selectorClasses.uploader), fileContainer = batch ? fileBatch.content : fileList, thumb;\n\t                if (batch) {\n\t                    fileBatch.map[id] = fileEl;\n\t                }\n\t                qq(fileEl).addClass(FILE_CLASS_PREFIX + id);\n\t                uploaderEl.removeAttribute(DROPZPONE_TEXT_ATTR);\n\t                if (fileNameEl) {\n\t                    qq(fileNameEl).setText(name);\n\t                    fileNameEl.setAttribute(\"title\", name);\n\t                }\n\t                fileEl.setAttribute(FILE_ID_ATTR, id);\n\t                if (prependInfo) {\n\t                    prependFile(fileEl, prependInfo.index, fileContainer);\n\t                } else {\n\t                    fileContainer.appendChild(fileEl);\n\t                }\n\t                if (hideForever) {\n\t                    fileEl.style.display = \"none\";\n\t                    qq(fileEl).addClass(HIDDEN_FOREVER_CLASS);\n\t                } else {\n\t                    hide(getProgress(id));\n\t                    hide(getSize(id));\n\t                    hide(getDelete(id));\n\t                    hide(getRetry(id));\n\t                    hide(getPause(id));\n\t                    hide(getContinue(id));\n\t                    if (isCancelDisabled) {\n\t                        this.hideCancel(id);\n\t                    }\n\t                    thumb = getThumbnail(id);\n\t                    if (thumb && !thumb.src) {\n\t                        cachedWaitingForThumbnailImg.then(function(waitingImg) {\n\t                            thumb.src = waitingImg.src;\n\t                            if (waitingImg.style.maxHeight && waitingImg.style.maxWidth) {\n\t                                qq(thumb).css({\n\t                                    maxHeight: waitingImg.style.maxHeight,\n\t                                    maxWidth: waitingImg.style.maxWidth\n\t                                });\n\t                            }\n\t                            show(thumb);\n\t                        });\n\t                    }\n\t                }\n\t            },\n\t            addFileToCache: function(id, name, prependInfo, hideForever) {\n\t                this.addFile(id, name, prependInfo, hideForever, true);\n\t            },\n\t            addCacheToDom: function() {\n\t                fileList.appendChild(fileBatch.content);\n\t                fileBatch.content = document.createDocumentFragment();\n\t                fileBatch.map = {};\n\t            },\n\t            removeFile: function(id) {\n\t                qq(getFile(id)).remove();\n\t            },\n\t            getFileId: function(el) {\n\t                var currentNode = el;\n\t                if (currentNode) {\n\t                    while (currentNode.getAttribute(FILE_ID_ATTR) == null) {\n\t                        currentNode = currentNode.parentNode;\n\t                    }\n\t                    return parseInt(currentNode.getAttribute(FILE_ID_ATTR));\n\t                }\n\t            },\n\t            getFileList: function() {\n\t                return fileList;\n\t            },\n\t            markFilenameEditable: function(id) {\n\t                var filename = getFilename(id);\n\t                filename && qq(filename).addClass(options.classes.editable);\n\t            },\n\t            updateFilename: function(id, name) {\n\t                var filenameEl = getFilename(id);\n\t                if (filenameEl) {\n\t                    qq(filenameEl).setText(name);\n\t                    filenameEl.setAttribute(\"title\", name);\n\t                }\n\t            },\n\t            hideFilename: function(id) {\n\t                hide(getFilename(id));\n\t            },\n\t            showFilename: function(id) {\n\t                show(getFilename(id));\n\t            },\n\t            isFileName: function(el) {\n\t                return qq(el).hasClass(selectorClasses.file);\n\t            },\n\t            getButton: function() {\n\t                return options.button || getTemplateEl(container, selectorClasses.button);\n\t            },\n\t            hideDropProcessing: function() {\n\t                hide(getDropProcessing());\n\t            },\n\t            showDropProcessing: function() {\n\t                show(getDropProcessing());\n\t            },\n\t            getDropZone: function() {\n\t                return getTemplateEl(container, selectorClasses.drop);\n\t            },\n\t            isEditFilenamePossible: function() {\n\t                return isEditElementsExist;\n\t            },\n\t            hideRetry: function(id) {\n\t                hide(getRetry(id));\n\t            },\n\t            isRetryPossible: function() {\n\t                return isRetryElementExist;\n\t            },\n\t            showRetry: function(id) {\n\t                show(getRetry(id));\n\t            },\n\t            getFileContainer: function(id) {\n\t                return getFile(id);\n\t            },\n\t            showEditIcon: function(id) {\n\t                var icon = getEditIcon(id);\n\t                icon && qq(icon).addClass(options.classes.editable);\n\t            },\n\t            isHiddenForever: function(id) {\n\t                return qq(getFile(id)).hasClass(HIDDEN_FOREVER_CLASS);\n\t            },\n\t            hideEditIcon: function(id) {\n\t                var icon = getEditIcon(id);\n\t                icon && qq(icon).removeClass(options.classes.editable);\n\t            },\n\t            isEditIcon: function(el) {\n\t                return qq(el).hasClass(selectorClasses.editNameIcon, true);\n\t            },\n\t            getEditInput: function(id) {\n\t                return getTemplateEl(getFile(id), selectorClasses.editFilenameInput);\n\t            },\n\t            isEditInput: function(el) {\n\t                return qq(el).hasClass(selectorClasses.editFilenameInput, true);\n\t            },\n\t            updateProgress: function(id, loaded, total) {\n\t                var bar = getProgress(id), percent;\n\t                if (bar && total > 0) {\n\t                    percent = Math.round(loaded / total * 100);\n\t                    if (percent === 100) {\n\t                        hide(bar);\n\t                    } else {\n\t                        show(bar);\n\t                    }\n\t                    setProgressBarWidth(id, percent);\n\t                }\n\t            },\n\t            updateTotalProgress: function(loaded, total) {\n\t                this.updateProgress(null, loaded, total);\n\t            },\n\t            hideProgress: function(id) {\n\t                var bar = getProgress(id);\n\t                bar && hide(bar);\n\t            },\n\t            hideTotalProgress: function() {\n\t                this.hideProgress();\n\t            },\n\t            resetProgress: function(id) {\n\t                setProgressBarWidth(id, 0);\n\t                this.hideTotalProgress(id);\n\t            },\n\t            resetTotalProgress: function() {\n\t                this.resetProgress();\n\t            },\n\t            showCancel: function(id) {\n\t                if (!isCancelDisabled) {\n\t                    var cancel = getCancel(id);\n\t                    cancel && qq(cancel).removeClass(options.classes.hide);\n\t                }\n\t            },\n\t            hideCancel: function(id) {\n\t                hide(getCancel(id));\n\t            },\n\t            isCancel: function(el) {\n\t                return qq(el).hasClass(selectorClasses.cancel, true);\n\t            },\n\t            allowPause: function(id) {\n\t                show(getPause(id));\n\t                hide(getContinue(id));\n\t            },\n\t            uploadPaused: function(id) {\n\t                this.setStatusText(id, options.text.paused);\n\t                this.allowContinueButton(id);\n\t                hide(getSpinner(id));\n\t            },\n\t            hidePause: function(id) {\n\t                hide(getPause(id));\n\t            },\n\t            isPause: function(el) {\n\t                return qq(el).hasClass(selectorClasses.pause, true);\n\t            },\n\t            isContinueButton: function(el) {\n\t                return qq(el).hasClass(selectorClasses.continueButton, true);\n\t            },\n\t            allowContinueButton: function(id) {\n\t                show(getContinue(id));\n\t                hide(getPause(id));\n\t            },\n\t            uploadContinued: function(id) {\n\t                this.setStatusText(id, \"\");\n\t                this.allowPause(id);\n\t                show(getSpinner(id));\n\t            },\n\t            showDeleteButton: function(id) {\n\t                show(getDelete(id));\n\t            },\n\t            hideDeleteButton: function(id) {\n\t                hide(getDelete(id));\n\t            },\n\t            isDeleteButton: function(el) {\n\t                return qq(el).hasClass(selectorClasses.deleteButton, true);\n\t            },\n\t            isRetry: function(el) {\n\t                return qq(el).hasClass(selectorClasses.retry, true);\n\t            },\n\t            updateSize: function(id, text) {\n\t                var size = getSize(id);\n\t                if (size) {\n\t                    show(size);\n\t                    qq(size).setText(text);\n\t                }\n\t            },\n\t            setStatusText: function(id, text) {\n\t                var textEl = getTemplateEl(getFile(id), selectorClasses.statusText);\n\t                if (textEl) {\n\t                    if (text == null) {\n\t                        qq(textEl).clearText();\n\t                    } else {\n\t                        qq(textEl).setText(text);\n\t                    }\n\t                }\n\t            },\n\t            hideSpinner: function(id) {\n\t                qq(getFile(id)).removeClass(IN_PROGRESS_CLASS);\n\t                hide(getSpinner(id));\n\t            },\n\t            showSpinner: function(id) {\n\t                qq(getFile(id)).addClass(IN_PROGRESS_CLASS);\n\t                show(getSpinner(id));\n\t            },\n\t            generatePreview: function(id, optFileOrBlob, customResizeFunction) {\n\t                if (!this.isHiddenForever(id)) {\n\t                    thumbGenerationQueue.push({\n\t                        id: id,\n\t                        customResizeFunction: customResizeFunction,\n\t                        optFileOrBlob: optFileOrBlob\n\t                    });\n\t                    !thumbnailQueueMonitorRunning && generateNextQueuedPreview();\n\t                }\n\t            },\n\t            updateThumbnail: function(id, thumbnailUrl, showWaitingImg, customResizeFunction) {\n\t                if (!this.isHiddenForever(id)) {\n\t                    thumbGenerationQueue.push({\n\t                        customResizeFunction: customResizeFunction,\n\t                        update: true,\n\t                        id: id,\n\t                        thumbnailUrl: thumbnailUrl,\n\t                        showWaitingImg: showWaitingImg\n\t                    });\n\t                    !thumbnailQueueMonitorRunning && generateNextQueuedPreview();\n\t                }\n\t            },\n\t            hasDialog: function(type) {\n\t                return qq.supportedFeatures.dialogElement && !!getDialog(type);\n\t            },\n\t            showDialog: function(type, message, defaultValue) {\n\t                var dialog = getDialog(type), messageEl = getTemplateEl(dialog, selectorClasses.dialogMessage), inputEl = dialog.getElementsByTagName(\"INPUT\")[0], cancelBtn = getTemplateEl(dialog, selectorClasses.dialogCancelButton), okBtn = getTemplateEl(dialog, selectorClasses.dialogOkButton), promise = new qq.Promise(), closeHandler = function() {\n\t                    cancelBtn.removeEventListener(\"click\", cancelClickHandler);\n\t                    okBtn && okBtn.removeEventListener(\"click\", okClickHandler);\n\t                    promise.failure();\n\t                }, cancelClickHandler = function() {\n\t                    cancelBtn.removeEventListener(\"click\", cancelClickHandler);\n\t                    dialog.close();\n\t                }, okClickHandler = function() {\n\t                    dialog.removeEventListener(\"close\", closeHandler);\n\t                    okBtn.removeEventListener(\"click\", okClickHandler);\n\t                    dialog.close();\n\t                    promise.success(inputEl && inputEl.value);\n\t                };\n\t                dialog.addEventListener(\"close\", closeHandler);\n\t                cancelBtn.addEventListener(\"click\", cancelClickHandler);\n\t                okBtn && okBtn.addEventListener(\"click\", okClickHandler);\n\t                if (inputEl) {\n\t                    inputEl.value = defaultValue;\n\t                }\n\t                messageEl.textContent = message;\n\t                dialog.showModal();\n\t                return promise;\n\t            }\n\t        });\n\t    };\n\t    qq.UiEventHandler = function(s, protectedApi) {\n\t        \"use strict\";\n\t        var disposer = new qq.DisposeSupport(), spec = {\n\t            eventType: \"click\",\n\t            attachTo: null,\n\t            onHandled: function(target, event) {}\n\t        };\n\t        qq.extend(this, {\n\t            addHandler: function(element) {\n\t                addHandler(element);\n\t            },\n\t            dispose: function() {\n\t                disposer.dispose();\n\t            }\n\t        });\n\t        function addHandler(element) {\n\t            disposer.attach(element, spec.eventType, function(event) {\n\t                event = event || window.event;\n\t                var target = event.target || event.srcElement;\n\t                spec.onHandled(target, event);\n\t            });\n\t        }\n\t        qq.extend(protectedApi, {\n\t            getFileIdFromItem: function(item) {\n\t                return item.qqFileId;\n\t            },\n\t            getDisposeSupport: function() {\n\t                return disposer;\n\t            }\n\t        });\n\t        qq.extend(spec, s);\n\t        if (spec.attachTo) {\n\t            addHandler(spec.attachTo);\n\t        }\n\t    };\n\t    qq.FileButtonsClickHandler = function(s) {\n\t        \"use strict\";\n\t        var inheritedInternalApi = {}, spec = {\n\t            templating: null,\n\t            log: function(message, lvl) {},\n\t            onDeleteFile: function(fileId) {},\n\t            onCancel: function(fileId) {},\n\t            onRetry: function(fileId) {},\n\t            onPause: function(fileId) {},\n\t            onContinue: function(fileId) {},\n\t            onGetName: function(fileId) {}\n\t        }, buttonHandlers = {\n\t            cancel: function(id) {\n\t                spec.onCancel(id);\n\t            },\n\t            retry: function(id) {\n\t                spec.onRetry(id);\n\t            },\n\t            deleteButton: function(id) {\n\t                spec.onDeleteFile(id);\n\t            },\n\t            pause: function(id) {\n\t                spec.onPause(id);\n\t            },\n\t            continueButton: function(id) {\n\t                spec.onContinue(id);\n\t            }\n\t        };\n\t        function examineEvent(target, event) {\n\t            qq.each(buttonHandlers, function(buttonType, handler) {\n\t                var firstLetterCapButtonType = buttonType.charAt(0).toUpperCase() + buttonType.slice(1), fileId;\n\t                if (spec.templating[\"is\" + firstLetterCapButtonType](target)) {\n\t                    fileId = spec.templating.getFileId(target);\n\t                    qq.preventDefault(event);\n\t                    spec.log(qq.format(\"Detected valid file button click event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n\t                    handler(fileId);\n\t                    return false;\n\t                }\n\t            });\n\t        }\n\t        qq.extend(spec, s);\n\t        spec.eventType = \"click\";\n\t        spec.onHandled = examineEvent;\n\t        spec.attachTo = spec.templating.getFileList();\n\t        qq.extend(this, new qq.UiEventHandler(spec, inheritedInternalApi));\n\t    };\n\t    qq.FilenameClickHandler = function(s) {\n\t        \"use strict\";\n\t        var inheritedInternalApi = {}, spec = {\n\t            templating: null,\n\t            log: function(message, lvl) {},\n\t            classes: {\n\t                file: \"qq-upload-file\",\n\t                editNameIcon: \"qq-edit-filename-icon\"\n\t            },\n\t            onGetUploadStatus: function(fileId) {},\n\t            onGetName: function(fileId) {}\n\t        };\n\t        qq.extend(spec, s);\n\t        function examineEvent(target, event) {\n\t            if (spec.templating.isFileName(target) || spec.templating.isEditIcon(target)) {\n\t                var fileId = spec.templating.getFileId(target), status = spec.onGetUploadStatus(fileId);\n\t                if (status === qq.status.SUBMITTED) {\n\t                    spec.log(qq.format(\"Detected valid filename click event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n\t                    qq.preventDefault(event);\n\t                    inheritedInternalApi.handleFilenameEdit(fileId, target, true);\n\t                }\n\t            }\n\t        }\n\t        spec.eventType = \"click\";\n\t        spec.onHandled = examineEvent;\n\t        qq.extend(this, new qq.FilenameEditHandler(spec, inheritedInternalApi));\n\t    };\n\t    qq.FilenameInputFocusInHandler = function(s, inheritedInternalApi) {\n\t        \"use strict\";\n\t        var spec = {\n\t            templating: null,\n\t            onGetUploadStatus: function(fileId) {},\n\t            log: function(message, lvl) {}\n\t        };\n\t        if (!inheritedInternalApi) {\n\t            inheritedInternalApi = {};\n\t        }\n\t        function handleInputFocus(target, event) {\n\t            if (spec.templating.isEditInput(target)) {\n\t                var fileId = spec.templating.getFileId(target), status = spec.onGetUploadStatus(fileId);\n\t                if (status === qq.status.SUBMITTED) {\n\t                    spec.log(qq.format(\"Detected valid filename input focus event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n\t                    inheritedInternalApi.handleFilenameEdit(fileId, target);\n\t                }\n\t            }\n\t        }\n\t        spec.eventType = \"focusin\";\n\t        spec.onHandled = handleInputFocus;\n\t        qq.extend(spec, s);\n\t        qq.extend(this, new qq.FilenameEditHandler(spec, inheritedInternalApi));\n\t    };\n\t    qq.FilenameInputFocusHandler = function(spec) {\n\t        \"use strict\";\n\t        spec.eventType = \"focus\";\n\t        spec.attachTo = null;\n\t        qq.extend(this, new qq.FilenameInputFocusInHandler(spec, {}));\n\t    };\n\t    qq.FilenameEditHandler = function(s, inheritedInternalApi) {\n\t        \"use strict\";\n\t        var spec = {\n\t            templating: null,\n\t            log: function(message, lvl) {},\n\t            onGetUploadStatus: function(fileId) {},\n\t            onGetName: function(fileId) {},\n\t            onSetName: function(fileId, newName) {},\n\t            onEditingStatusChange: function(fileId, isEditing) {}\n\t        };\n\t        function getFilenameSansExtension(fileId) {\n\t            var filenameSansExt = spec.onGetName(fileId), extIdx = filenameSansExt.lastIndexOf(\".\");\n\t            if (extIdx > 0) {\n\t                filenameSansExt = filenameSansExt.substr(0, extIdx);\n\t            }\n\t            return filenameSansExt;\n\t        }\n\t        function getOriginalExtension(fileId) {\n\t            var origName = spec.onGetName(fileId);\n\t            return qq.getExtension(origName);\n\t        }\n\t        function handleNameUpdate(newFilenameInputEl, fileId) {\n\t            var newName = newFilenameInputEl.value, origExtension;\n\t            if (newName !== undefined && qq.trimStr(newName).length > 0) {\n\t                origExtension = getOriginalExtension(fileId);\n\t                if (origExtension !== undefined) {\n\t                    newName = newName + \".\" + origExtension;\n\t                }\n\t                spec.onSetName(fileId, newName);\n\t            }\n\t            spec.onEditingStatusChange(fileId, false);\n\t        }\n\t        function registerInputBlurHandler(inputEl, fileId) {\n\t            inheritedInternalApi.getDisposeSupport().attach(inputEl, \"blur\", function() {\n\t                handleNameUpdate(inputEl, fileId);\n\t            });\n\t        }\n\t        function registerInputEnterKeyHandler(inputEl, fileId) {\n\t            inheritedInternalApi.getDisposeSupport().attach(inputEl, \"keyup\", function(event) {\n\t                var code = event.keyCode || event.which;\n\t                if (code === 13) {\n\t                    handleNameUpdate(inputEl, fileId);\n\t                }\n\t            });\n\t        }\n\t        qq.extend(spec, s);\n\t        spec.attachTo = spec.templating.getFileList();\n\t        qq.extend(this, new qq.UiEventHandler(spec, inheritedInternalApi));\n\t        qq.extend(inheritedInternalApi, {\n\t            handleFilenameEdit: function(id, target, focusInput) {\n\t                var newFilenameInputEl = spec.templating.getEditInput(id);\n\t                spec.onEditingStatusChange(id, true);\n\t                newFilenameInputEl.value = getFilenameSansExtension(id);\n\t                if (focusInput) {\n\t                    newFilenameInputEl.focus();\n\t                }\n\t                registerInputBlurHandler(newFilenameInputEl, id);\n\t                registerInputEnterKeyHandler(newFilenameInputEl, id);\n\t            }\n\t        });\n\t    };\n\t    qq.CryptoJS = function(Math, undefined) {\n\t        var C = {};\n\t        var C_lib = C.lib = {};\n\t        var Base = C_lib.Base = function() {\n\t            function F() {}\n\t            return {\n\t                extend: function(overrides) {\n\t                    F.prototype = this;\n\t                    var subtype = new F();\n\t                    if (overrides) {\n\t                        subtype.mixIn(overrides);\n\t                    }\n\t                    if (!subtype.hasOwnProperty(\"init\")) {\n\t                        subtype.init = function() {\n\t                            subtype.$super.init.apply(this, arguments);\n\t                        };\n\t                    }\n\t                    subtype.init.prototype = subtype;\n\t                    subtype.$super = this;\n\t                    return subtype;\n\t                },\n\t                create: function() {\n\t                    var instance = this.extend();\n\t                    instance.init.apply(instance, arguments);\n\t                    return instance;\n\t                },\n\t                init: function() {},\n\t                mixIn: function(properties) {\n\t                    for (var propertyName in properties) {\n\t                        if (properties.hasOwnProperty(propertyName)) {\n\t                            this[propertyName] = properties[propertyName];\n\t                        }\n\t                    }\n\t                    if (properties.hasOwnProperty(\"toString\")) {\n\t                        this.toString = properties.toString;\n\t                    }\n\t                },\n\t                clone: function() {\n\t                    return this.init.prototype.extend(this);\n\t                }\n\t            };\n\t        }();\n\t        var WordArray = C_lib.WordArray = Base.extend({\n\t            init: function(words, sigBytes) {\n\t                words = this.words = words || [];\n\t                if (sigBytes != undefined) {\n\t                    this.sigBytes = sigBytes;\n\t                } else {\n\t                    this.sigBytes = words.length * 4;\n\t                }\n\t            },\n\t            toString: function(encoder) {\n\t                return (encoder || Hex).stringify(this);\n\t            },\n\t            concat: function(wordArray) {\n\t                var thisWords = this.words;\n\t                var thatWords = wordArray.words;\n\t                var thisSigBytes = this.sigBytes;\n\t                var thatSigBytes = wordArray.sigBytes;\n\t                this.clamp();\n\t                if (thisSigBytes % 4) {\n\t                    for (var i = 0; i < thatSigBytes; i++) {\n\t                        var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n\t                        thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;\n\t                    }\n\t                } else if (thatWords.length > 65535) {\n\t                    for (var i = 0; i < thatSigBytes; i += 4) {\n\t                        thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];\n\t                    }\n\t                } else {\n\t                    thisWords.push.apply(thisWords, thatWords);\n\t                }\n\t                this.sigBytes += thatSigBytes;\n\t                return this;\n\t            },\n\t            clamp: function() {\n\t                var words = this.words;\n\t                var sigBytes = this.sigBytes;\n\t                words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;\n\t                words.length = Math.ceil(sigBytes / 4);\n\t            },\n\t            clone: function() {\n\t                var clone = Base.clone.call(this);\n\t                clone.words = this.words.slice(0);\n\t                return clone;\n\t            },\n\t            random: function(nBytes) {\n\t                var words = [];\n\t                for (var i = 0; i < nBytes; i += 4) {\n\t                    words.push(Math.random() * 4294967296 | 0);\n\t                }\n\t                return new WordArray.init(words, nBytes);\n\t            }\n\t        });\n\t        var C_enc = C.enc = {};\n\t        var Hex = C_enc.Hex = {\n\t            stringify: function(wordArray) {\n\t                var words = wordArray.words;\n\t                var sigBytes = wordArray.sigBytes;\n\t                var hexChars = [];\n\t                for (var i = 0; i < sigBytes; i++) {\n\t                    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n\t                    hexChars.push((bite >>> 4).toString(16));\n\t                    hexChars.push((bite & 15).toString(16));\n\t                }\n\t                return hexChars.join(\"\");\n\t            },\n\t            parse: function(hexStr) {\n\t                var hexStrLength = hexStr.length;\n\t                var words = [];\n\t                for (var i = 0; i < hexStrLength; i += 2) {\n\t                    words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;\n\t                }\n\t                return new WordArray.init(words, hexStrLength / 2);\n\t            }\n\t        };\n\t        var Latin1 = C_enc.Latin1 = {\n\t            stringify: function(wordArray) {\n\t                var words = wordArray.words;\n\t                var sigBytes = wordArray.sigBytes;\n\t                var latin1Chars = [];\n\t                for (var i = 0; i < sigBytes; i++) {\n\t                    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n\t                    latin1Chars.push(String.fromCharCode(bite));\n\t                }\n\t                return latin1Chars.join(\"\");\n\t            },\n\t            parse: function(latin1Str) {\n\t                var latin1StrLength = latin1Str.length;\n\t                var words = [];\n\t                for (var i = 0; i < latin1StrLength; i++) {\n\t                    words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;\n\t                }\n\t                return new WordArray.init(words, latin1StrLength);\n\t            }\n\t        };\n\t        var Utf8 = C_enc.Utf8 = {\n\t            stringify: function(wordArray) {\n\t                try {\n\t                    return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t                } catch (e) {\n\t                    throw new Error(\"Malformed UTF-8 data\");\n\t                }\n\t            },\n\t            parse: function(utf8Str) {\n\t                return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t            }\n\t        };\n\t        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t            reset: function() {\n\t                this._data = new WordArray.init();\n\t                this._nDataBytes = 0;\n\t            },\n\t            _append: function(data) {\n\t                if (typeof data == \"string\") {\n\t                    data = Utf8.parse(data);\n\t                }\n\t                this._data.concat(data);\n\t                this._nDataBytes += data.sigBytes;\n\t            },\n\t            _process: function(doFlush) {\n\t                var data = this._data;\n\t                var dataWords = data.words;\n\t                var dataSigBytes = data.sigBytes;\n\t                var blockSize = this.blockSize;\n\t                var blockSizeBytes = blockSize * 4;\n\t                var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t                if (doFlush) {\n\t                    nBlocksReady = Math.ceil(nBlocksReady);\n\t                } else {\n\t                    nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t                }\n\t                var nWordsReady = nBlocksReady * blockSize;\n\t                var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\t                if (nWordsReady) {\n\t                    for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                        this._doProcessBlock(dataWords, offset);\n\t                    }\n\t                    var processedWords = dataWords.splice(0, nWordsReady);\n\t                    data.sigBytes -= nBytesReady;\n\t                }\n\t                return new WordArray.init(processedWords, nBytesReady);\n\t            },\n\t            clone: function() {\n\t                var clone = Base.clone.call(this);\n\t                clone._data = this._data.clone();\n\t                return clone;\n\t            },\n\t            _minBufferSize: 0\n\t        });\n\t        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t            cfg: Base.extend(),\n\t            init: function(cfg) {\n\t                this.cfg = this.cfg.extend(cfg);\n\t                this.reset();\n\t            },\n\t            reset: function() {\n\t                BufferedBlockAlgorithm.reset.call(this);\n\t                this._doReset();\n\t            },\n\t            update: function(messageUpdate) {\n\t                this._append(messageUpdate);\n\t                this._process();\n\t                return this;\n\t            },\n\t            finalize: function(messageUpdate) {\n\t                if (messageUpdate) {\n\t                    this._append(messageUpdate);\n\t                }\n\t                var hash = this._doFinalize();\n\t                return hash;\n\t            },\n\t            blockSize: 512 / 32,\n\t            _createHelper: function(hasher) {\n\t                return function(message, cfg) {\n\t                    return new hasher.init(cfg).finalize(message);\n\t                };\n\t            },\n\t            _createHmacHelper: function(hasher) {\n\t                return function(message, key) {\n\t                    return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t                };\n\t            }\n\t        });\n\t        var C_algo = C.algo = {};\n\t        return C;\n\t    }(Math);\n\t    (function() {\n\t        var C = qq.CryptoJS;\n\t        var C_lib = C.lib;\n\t        var WordArray = C_lib.WordArray;\n\t        var C_enc = C.enc;\n\t        var Base64 = C_enc.Base64 = {\n\t            stringify: function(wordArray) {\n\t                var words = wordArray.words;\n\t                var sigBytes = wordArray.sigBytes;\n\t                var map = this._map;\n\t                wordArray.clamp();\n\t                var base64Chars = [];\n\t                for (var i = 0; i < sigBytes; i += 3) {\n\t                    var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n\t                    var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;\n\t                    var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;\n\t                    var triplet = byte1 << 16 | byte2 << 8 | byte3;\n\t                    for (var j = 0; j < 4 && i + j * .75 < sigBytes; j++) {\n\t                        base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));\n\t                    }\n\t                }\n\t                var paddingChar = map.charAt(64);\n\t                if (paddingChar) {\n\t                    while (base64Chars.length % 4) {\n\t                        base64Chars.push(paddingChar);\n\t                    }\n\t                }\n\t                return base64Chars.join(\"\");\n\t            },\n\t            parse: function(base64Str) {\n\t                var base64StrLength = base64Str.length;\n\t                var map = this._map;\n\t                var paddingChar = map.charAt(64);\n\t                if (paddingChar) {\n\t                    var paddingIndex = base64Str.indexOf(paddingChar);\n\t                    if (paddingIndex != -1) {\n\t                        base64StrLength = paddingIndex;\n\t                    }\n\t                }\n\t                var words = [];\n\t                var nBytes = 0;\n\t                for (var i = 0; i < base64StrLength; i++) {\n\t                    if (i % 4) {\n\t                        var bits1 = map.indexOf(base64Str.charAt(i - 1)) << i % 4 * 2;\n\t                        var bits2 = map.indexOf(base64Str.charAt(i)) >>> 6 - i % 4 * 2;\n\t                        words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;\n\t                        nBytes++;\n\t                    }\n\t                }\n\t                return WordArray.create(words, nBytes);\n\t            },\n\t            _map: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n\t        };\n\t    })();\n\t    (function() {\n\t        var C = qq.CryptoJS;\n\t        var C_lib = C.lib;\n\t        var Base = C_lib.Base;\n\t        var C_enc = C.enc;\n\t        var Utf8 = C_enc.Utf8;\n\t        var C_algo = C.algo;\n\t        var HMAC = C_algo.HMAC = Base.extend({\n\t            init: function(hasher, key) {\n\t                hasher = this._hasher = new hasher.init();\n\t                if (typeof key == \"string\") {\n\t                    key = Utf8.parse(key);\n\t                }\n\t                var hasherBlockSize = hasher.blockSize;\n\t                var hasherBlockSizeBytes = hasherBlockSize * 4;\n\t                if (key.sigBytes > hasherBlockSizeBytes) {\n\t                    key = hasher.finalize(key);\n\t                }\n\t                key.clamp();\n\t                var oKey = this._oKey = key.clone();\n\t                var iKey = this._iKey = key.clone();\n\t                var oKeyWords = oKey.words;\n\t                var iKeyWords = iKey.words;\n\t                for (var i = 0; i < hasherBlockSize; i++) {\n\t                    oKeyWords[i] ^= 1549556828;\n\t                    iKeyWords[i] ^= 909522486;\n\t                }\n\t                oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;\n\t                this.reset();\n\t            },\n\t            reset: function() {\n\t                var hasher = this._hasher;\n\t                hasher.reset();\n\t                hasher.update(this._iKey);\n\t            },\n\t            update: function(messageUpdate) {\n\t                this._hasher.update(messageUpdate);\n\t                return this;\n\t            },\n\t            finalize: function(messageUpdate) {\n\t                var hasher = this._hasher;\n\t                var innerHash = hasher.finalize(messageUpdate);\n\t                hasher.reset();\n\t                var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n\t                return hmac;\n\t            }\n\t        });\n\t    })();\n\t    (function() {\n\t        var C = qq.CryptoJS;\n\t        var C_lib = C.lib;\n\t        var WordArray = C_lib.WordArray;\n\t        var Hasher = C_lib.Hasher;\n\t        var C_algo = C.algo;\n\t        var W = [];\n\t        var SHA1 = C_algo.SHA1 = Hasher.extend({\n\t            _doReset: function() {\n\t                this._hash = new WordArray.init([ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ]);\n\t            },\n\t            _doProcessBlock: function(M, offset) {\n\t                var H = this._hash.words;\n\t                var a = H[0];\n\t                var b = H[1];\n\t                var c = H[2];\n\t                var d = H[3];\n\t                var e = H[4];\n\t                for (var i = 0; i < 80; i++) {\n\t                    if (i < 16) {\n\t                        W[i] = M[offset + i] | 0;\n\t                    } else {\n\t                        var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n\t                        W[i] = n << 1 | n >>> 31;\n\t                    }\n\t                    var t = (a << 5 | a >>> 27) + e + W[i];\n\t                    if (i < 20) {\n\t                        t += (b & c | ~b & d) + 1518500249;\n\t                    } else if (i < 40) {\n\t                        t += (b ^ c ^ d) + 1859775393;\n\t                    } else if (i < 60) {\n\t                        t += (b & c | b & d | c & d) - 1894007588;\n\t                    } else {\n\t                        t += (b ^ c ^ d) - 899497514;\n\t                    }\n\t                    e = d;\n\t                    d = c;\n\t                    c = b << 30 | b >>> 2;\n\t                    b = a;\n\t                    a = t;\n\t                }\n\t                H[0] = H[0] + a | 0;\n\t                H[1] = H[1] + b | 0;\n\t                H[2] = H[2] + c | 0;\n\t                H[3] = H[3] + d | 0;\n\t                H[4] = H[4] + e | 0;\n\t            },\n\t            _doFinalize: function() {\n\t                var data = this._data;\n\t                var dataWords = data.words;\n\t                var nBitsTotal = this._nDataBytes * 8;\n\t                var nBitsLeft = data.sigBytes * 8;\n\t                dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n\t                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);\n\t                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n\t                data.sigBytes = dataWords.length * 4;\n\t                this._process();\n\t                return this._hash;\n\t            },\n\t            clone: function() {\n\t                var clone = Hasher.clone.call(this);\n\t                clone._hash = this._hash.clone();\n\t                return clone;\n\t            }\n\t        });\n\t        C.SHA1 = Hasher._createHelper(SHA1);\n\t        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);\n\t    })();\n\t    (function(Math) {\n\t        var C = qq.CryptoJS;\n\t        var C_lib = C.lib;\n\t        var WordArray = C_lib.WordArray;\n\t        var Hasher = C_lib.Hasher;\n\t        var C_algo = C.algo;\n\t        var H = [];\n\t        var K = [];\n\t        (function() {\n\t            function isPrime(n) {\n\t                var sqrtN = Math.sqrt(n);\n\t                for (var factor = 2; factor <= sqrtN; factor++) {\n\t                    if (!(n % factor)) {\n\t                        return false;\n\t                    }\n\t                }\n\t                return true;\n\t            }\n\t            function getFractionalBits(n) {\n\t                return (n - (n | 0)) * 4294967296 | 0;\n\t            }\n\t            var n = 2;\n\t            var nPrime = 0;\n\t            while (nPrime < 64) {\n\t                if (isPrime(n)) {\n\t                    if (nPrime < 8) {\n\t                        H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                    }\n\t                    K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\t                    nPrime++;\n\t                }\n\t                n++;\n\t            }\n\t        })();\n\t        var W = [];\n\t        var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t            _doReset: function() {\n\t                this._hash = new WordArray.init(H.slice(0));\n\t            },\n\t            _doProcessBlock: function(M, offset) {\n\t                var H = this._hash.words;\n\t                var a = H[0];\n\t                var b = H[1];\n\t                var c = H[2];\n\t                var d = H[3];\n\t                var e = H[4];\n\t                var f = H[5];\n\t                var g = H[6];\n\t                var h = H[7];\n\t                for (var i = 0; i < 64; i++) {\n\t                    if (i < 16) {\n\t                        W[i] = M[offset + i] | 0;\n\t                    } else {\n\t                        var gamma0x = W[i - 15];\n\t                        var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n\t                        var gamma1x = W[i - 2];\n\t                        var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n\t                        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                    }\n\t                    var ch = e & f ^ ~e & g;\n\t                    var maj = a & b ^ a & c ^ b & c;\n\t                    var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n\t                    var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n\t                    var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                    var t2 = sigma0 + maj;\n\t                    h = g;\n\t                    g = f;\n\t                    f = e;\n\t                    e = d + t1 | 0;\n\t                    d = c;\n\t                    c = b;\n\t                    b = a;\n\t                    a = t1 + t2 | 0;\n\t                }\n\t                H[0] = H[0] + a | 0;\n\t                H[1] = H[1] + b | 0;\n\t                H[2] = H[2] + c | 0;\n\t                H[3] = H[3] + d | 0;\n\t                H[4] = H[4] + e | 0;\n\t                H[5] = H[5] + f | 0;\n\t                H[6] = H[6] + g | 0;\n\t                H[7] = H[7] + h | 0;\n\t            },\n\t            _doFinalize: function() {\n\t                var data = this._data;\n\t                var dataWords = data.words;\n\t                var nBitsTotal = this._nDataBytes * 8;\n\t                var nBitsLeft = data.sigBytes * 8;\n\t                dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n\t                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);\n\t                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n\t                data.sigBytes = dataWords.length * 4;\n\t                this._process();\n\t                return this._hash;\n\t            },\n\t            clone: function() {\n\t                var clone = Hasher.clone.call(this);\n\t                clone._hash = this._hash.clone();\n\t                return clone;\n\t            }\n\t        });\n\t        C.SHA256 = Hasher._createHelper(SHA256);\n\t        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t    })(Math);\n\t    (function() {\n\t        if (typeof ArrayBuffer != \"function\") {\n\t            return;\n\t        }\n\t        var C = qq.CryptoJS;\n\t        var C_lib = C.lib;\n\t        var WordArray = C_lib.WordArray;\n\t        var superInit = WordArray.init;\n\t        var subInit = WordArray.init = function(typedArray) {\n\t            if (typedArray instanceof ArrayBuffer) {\n\t                typedArray = new Uint8Array(typedArray);\n\t            }\n\t            if (typedArray instanceof Int8Array || typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {\n\t                typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n\t            }\n\t            if (typedArray instanceof Uint8Array) {\n\t                var typedArrayByteLength = typedArray.byteLength;\n\t                var words = [];\n\t                for (var i = 0; i < typedArrayByteLength; i++) {\n\t                    words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;\n\t                }\n\t                superInit.call(this, words, typedArrayByteLength);\n\t            } else {\n\t                superInit.apply(this, arguments);\n\t            }\n\t        };\n\t        subInit.prototype = WordArray;\n\t    })();\n\t    qq.s3 = qq.s3 || {};\n\t    qq.s3.util = qq.s3.util || function() {\n\t        \"use strict\";\n\t        return {\n\t            ALGORITHM_PARAM_NAME: \"x-amz-algorithm\",\n\t            AWS_PARAM_PREFIX: \"x-amz-meta-\",\n\t            CREDENTIAL_PARAM_NAME: \"x-amz-credential\",\n\t            DATE_PARAM_NAME: \"x-amz-date\",\n\t            REDUCED_REDUNDANCY_PARAM_NAME: \"x-amz-storage-class\",\n\t            REDUCED_REDUNDANCY_PARAM_VALUE: \"REDUCED_REDUNDANCY\",\n\t            SERVER_SIDE_ENCRYPTION_PARAM_NAME: \"x-amz-server-side-encryption\",\n\t            SERVER_SIDE_ENCRYPTION_PARAM_VALUE: \"AES256\",\n\t            SESSION_TOKEN_PARAM_NAME: \"x-amz-security-token\",\n\t            V4_ALGORITHM_PARAM_VALUE: \"AWS4-HMAC-SHA256\",\n\t            V4_SIGNATURE_PARAM_NAME: \"x-amz-signature\",\n\t            CASE_SENSITIVE_PARAM_NAMES: [ \"Cache-Control\", \"Content-Disposition\", \"Content-Encoding\", \"Content-MD5\" ],\n\t            UNSIGNABLE_REST_HEADER_NAMES: [ \"Cache-Control\", \"Content-Disposition\", \"Content-Encoding\", \"Content-MD5\" ],\n\t            UNPREFIXED_PARAM_NAMES: [ \"Cache-Control\", \"Content-Disposition\", \"Content-Encoding\", \"Content-MD5\", \"x-amz-server-side-encryption-customer-algorithm\", \"x-amz-server-side-encryption-customer-key\", \"x-amz-server-side-encryption-customer-key-MD5\" ],\n\t            getBucket: function(endpoint) {\n\t                var patterns = [ /^(?:https?:\\/\\/)?([a-z0-9.\\-_]+)\\.s3(?:-[a-z0-9\\-]+)?\\.amazonaws\\.com/i, /^(?:https?:\\/\\/)?s3(?:-[a-z0-9\\-]+)?\\.amazonaws\\.com\\/([a-z0-9.\\-_]+)/i, /^(?:https?:\\/\\/)?([a-z0-9.\\-_]+)/i ], bucket;\n\t                qq.each(patterns, function(idx, pattern) {\n\t                    var match = pattern.exec(endpoint);\n\t                    if (match) {\n\t                        bucket = match[1];\n\t                        return false;\n\t                    }\n\t                });\n\t                return bucket;\n\t            },\n\t            _getPrefixedParamName: function(name) {\n\t                if (qq.indexOf(qq.s3.util.UNPREFIXED_PARAM_NAMES, name) >= 0) {\n\t                    return name;\n\t                }\n\t                return qq.s3.util.AWS_PARAM_PREFIX + name;\n\t            },\n\t            getPolicy: function(spec) {\n\t                var policy = {}, conditions = [], bucket = spec.bucket, date = spec.date, drift = spec.clockDrift, key = spec.key, accessKey = spec.accessKey, acl = spec.acl, type = spec.type, expectedStatus = spec.expectedStatus, sessionToken = spec.sessionToken, params = spec.params, successRedirectUrl = qq.s3.util.getSuccessRedirectAbsoluteUrl(spec.successRedirectUrl), minFileSize = spec.minFileSize, maxFileSize = spec.maxFileSize, reducedRedundancy = spec.reducedRedundancy, region = spec.region, serverSideEncryption = spec.serverSideEncryption, signatureVersion = spec.signatureVersion;\n\t                policy.expiration = qq.s3.util.getPolicyExpirationDate(date, drift);\n\t                conditions.push({\n\t                    acl: acl\n\t                });\n\t                conditions.push({\n\t                    bucket: bucket\n\t                });\n\t                if (type) {\n\t                    conditions.push({\n\t                        \"Content-Type\": type\n\t                    });\n\t                }\n\t                if (expectedStatus) {\n\t                    conditions.push({\n\t                        success_action_status: expectedStatus.toString()\n\t                    });\n\t                }\n\t                if (successRedirectUrl) {\n\t                    conditions.push({\n\t                        success_action_redirect: successRedirectUrl\n\t                    });\n\t                }\n\t                if (reducedRedundancy) {\n\t                    conditions.push({});\n\t                    conditions[conditions.length - 1][qq.s3.util.REDUCED_REDUNDANCY_PARAM_NAME] = qq.s3.util.REDUCED_REDUNDANCY_PARAM_VALUE;\n\t                }\n\t                if (sessionToken) {\n\t                    conditions.push({});\n\t                    conditions[conditions.length - 1][qq.s3.util.SESSION_TOKEN_PARAM_NAME] = sessionToken;\n\t                }\n\t                if (serverSideEncryption) {\n\t                    conditions.push({});\n\t                    conditions[conditions.length - 1][qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_NAME] = qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_VALUE;\n\t                }\n\t                if (signatureVersion === 2) {\n\t                    conditions.push({\n\t                        key: key\n\t                    });\n\t                } else if (signatureVersion === 4) {\n\t                    conditions.push({});\n\t                    conditions[conditions.length - 1][qq.s3.util.ALGORITHM_PARAM_NAME] = qq.s3.util.V4_ALGORITHM_PARAM_VALUE;\n\t                    conditions.push({});\n\t                    conditions[conditions.length - 1].key = key;\n\t                    conditions.push({});\n\t                    conditions[conditions.length - 1][qq.s3.util.CREDENTIAL_PARAM_NAME] = qq.s3.util.getV4CredentialsString({\n\t                        date: date,\n\t                        key: accessKey,\n\t                        region: region\n\t                    });\n\t                    conditions.push({});\n\t                    conditions[conditions.length - 1][qq.s3.util.DATE_PARAM_NAME] = qq.s3.util.getV4PolicyDate(date, drift);\n\t                }\n\t                qq.each(params, function(name, val) {\n\t                    var awsParamName = qq.s3.util._getPrefixedParamName(name), param = {};\n\t                    if (qq.indexOf(qq.s3.util.UNPREFIXED_PARAM_NAMES, awsParamName) >= 0) {\n\t                        param[awsParamName] = val;\n\t                    } else {\n\t                        param[awsParamName] = encodeURIComponent(val);\n\t                    }\n\t                    conditions.push(param);\n\t                });\n\t                policy.conditions = conditions;\n\t                qq.s3.util.enforceSizeLimits(policy, minFileSize, maxFileSize);\n\t                return policy;\n\t            },\n\t            refreshPolicyCredentials: function(policy, newSessionToken) {\n\t                var sessionTokenFound = false;\n\t                qq.each(policy.conditions, function(oldCondIdx, oldCondObj) {\n\t                    qq.each(oldCondObj, function(oldCondName, oldCondVal) {\n\t                        if (oldCondName === qq.s3.util.SESSION_TOKEN_PARAM_NAME) {\n\t                            oldCondObj[oldCondName] = newSessionToken;\n\t                            sessionTokenFound = true;\n\t                        }\n\t                    });\n\t                });\n\t                if (!sessionTokenFound) {\n\t                    policy.conditions.push({});\n\t                    policy.conditions[policy.conditions.length - 1][qq.s3.util.SESSION_TOKEN_PARAM_NAME] = newSessionToken;\n\t                }\n\t            },\n\t            generateAwsParams: function(spec, signPolicyCallback) {\n\t                var awsParams = {}, customParams = spec.params, promise = new qq.Promise(), sessionToken = spec.sessionToken, drift = spec.clockDrift, type = spec.type, key = spec.key, accessKey = spec.accessKey, acl = spec.acl, expectedStatus = spec.expectedStatus, successRedirectUrl = qq.s3.util.getSuccessRedirectAbsoluteUrl(spec.successRedirectUrl), reducedRedundancy = spec.reducedRedundancy, region = spec.region, serverSideEncryption = spec.serverSideEncryption, signatureVersion = spec.signatureVersion, now = new Date(), log = spec.log, policyJson;\n\t                spec.date = now;\n\t                policyJson = qq.s3.util.getPolicy(spec);\n\t                awsParams.key = key;\n\t                if (type) {\n\t                    awsParams[\"Content-Type\"] = type;\n\t                }\n\t                if (expectedStatus) {\n\t                    awsParams.success_action_status = expectedStatus;\n\t                }\n\t                if (successRedirectUrl) {\n\t                    awsParams.success_action_redirect = successRedirectUrl;\n\t                }\n\t                if (reducedRedundancy) {\n\t                    awsParams[qq.s3.util.REDUCED_REDUNDANCY_PARAM_NAME] = qq.s3.util.REDUCED_REDUNDANCY_PARAM_VALUE;\n\t                }\n\t                if (serverSideEncryption) {\n\t                    awsParams[qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_NAME] = qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_VALUE;\n\t                }\n\t                if (sessionToken) {\n\t                    awsParams[qq.s3.util.SESSION_TOKEN_PARAM_NAME] = sessionToken;\n\t                }\n\t                awsParams.acl = acl;\n\t                qq.each(customParams, function(name, val) {\n\t                    var awsParamName = qq.s3.util._getPrefixedParamName(name);\n\t                    if (qq.indexOf(qq.s3.util.UNPREFIXED_PARAM_NAMES, awsParamName) >= 0) {\n\t                        awsParams[awsParamName] = val;\n\t                    } else {\n\t                        awsParams[awsParamName] = encodeURIComponent(val);\n\t                    }\n\t                });\n\t                if (signatureVersion === 2) {\n\t                    awsParams.AWSAccessKeyId = accessKey;\n\t                } else if (signatureVersion === 4) {\n\t                    awsParams[qq.s3.util.ALGORITHM_PARAM_NAME] = qq.s3.util.V4_ALGORITHM_PARAM_VALUE;\n\t                    awsParams[qq.s3.util.CREDENTIAL_PARAM_NAME] = qq.s3.util.getV4CredentialsString({\n\t                        date: now,\n\t                        key: accessKey,\n\t                        region: region\n\t                    });\n\t                    awsParams[qq.s3.util.DATE_PARAM_NAME] = qq.s3.util.getV4PolicyDate(now, drift);\n\t                }\n\t                signPolicyCallback(policyJson).then(function(policyAndSignature, updatedAccessKey, updatedSessionToken) {\n\t                    awsParams.policy = policyAndSignature.policy;\n\t                    if (spec.signatureVersion === 2) {\n\t                        awsParams.signature = policyAndSignature.signature;\n\t                        if (updatedAccessKey) {\n\t                            awsParams.AWSAccessKeyId = updatedAccessKey;\n\t                        }\n\t                    } else if (spec.signatureVersion === 4) {\n\t                        awsParams[qq.s3.util.V4_SIGNATURE_PARAM_NAME] = policyAndSignature.signature;\n\t                    }\n\t                    if (updatedSessionToken) {\n\t                        awsParams[qq.s3.util.SESSION_TOKEN_PARAM_NAME] = updatedSessionToken;\n\t                    }\n\t                    promise.success(awsParams);\n\t                }, function(errorMessage) {\n\t                    errorMessage = errorMessage || \"Can't continue further with request to S3 as we did not receive \" + \"a valid signature and policy from the server.\";\n\t                    log(\"Policy signing failed.  \" + errorMessage, \"error\");\n\t                    promise.failure(errorMessage);\n\t                });\n\t                return promise;\n\t            },\n\t            enforceSizeLimits: function(policy, minSize, maxSize) {\n\t                var adjustedMinSize = minSize < 0 ? 0 : minSize, adjustedMaxSize = maxSize <= 0 ? 9007199254740992 : maxSize;\n\t                if (minSize > 0 || maxSize > 0) {\n\t                    policy.conditions.push([ \"content-length-range\", adjustedMinSize.toString(), adjustedMaxSize.toString() ]);\n\t                }\n\t            },\n\t            getPolicyExpirationDate: function(date, drift) {\n\t                var adjustedDate = new Date(date.getTime() + drift);\n\t                return qq.s3.util.getPolicyDate(adjustedDate, 5);\n\t            },\n\t            getCredentialsDate: function(date) {\n\t                return date.getUTCFullYear() + \"\" + (\"0\" + (date.getUTCMonth() + 1)).slice(-2) + (\"0\" + date.getUTCDate()).slice(-2);\n\t            },\n\t            getPolicyDate: function(date, _minutesToAdd_) {\n\t                var minutesToAdd = _minutesToAdd_ || 0, pad, r;\n\t                date.setMinutes(date.getMinutes() + (minutesToAdd || 0));\n\t                if (Date.prototype.toISOString) {\n\t                    return date.toISOString();\n\t                } else {\n\t                    pad = function(number) {\n\t                        r = String(number);\n\t                        if (r.length === 1) {\n\t                            r = \"0\" + r;\n\t                        }\n\t                        return r;\n\t                    };\n\t                    return date.getUTCFullYear() + \"-\" + pad(date.getUTCMonth() + 1) + \"-\" + pad(date.getUTCDate()) + \"T\" + pad(date.getUTCHours()) + \":\" + pad(date.getUTCMinutes()) + \":\" + pad(date.getUTCSeconds()) + \".\" + String((date.getUTCMilliseconds() / 1e3).toFixed(3)).slice(2, 5) + \"Z\";\n\t                }\n\t            },\n\t            parseIframeResponse: function(iframe) {\n\t                var doc = iframe.contentDocument || iframe.contentWindow.document, queryString = doc.location.search, match = /bucket=(.+)&key=(.+)&etag=(.+)/.exec(queryString);\n\t                if (match) {\n\t                    return {\n\t                        bucket: match[1],\n\t                        key: match[2],\n\t                        etag: match[3].replace(/%22/g, \"\")\n\t                    };\n\t                }\n\t            },\n\t            getSuccessRedirectAbsoluteUrl: function(successRedirectUrl) {\n\t                if (successRedirectUrl) {\n\t                    var targetAnchorContainer = document.createElement(\"div\"), targetAnchor;\n\t                    if (qq.ie7()) {\n\t                        targetAnchorContainer.innerHTML = \"<a href='\" + successRedirectUrl + \"'></a>\";\n\t                        targetAnchor = targetAnchorContainer.firstChild;\n\t                        return targetAnchor.href;\n\t                    } else {\n\t                        targetAnchor = document.createElement(\"a\");\n\t                        targetAnchor.href = successRedirectUrl;\n\t                        targetAnchor.href = targetAnchor.href;\n\t                        return targetAnchor.href;\n\t                    }\n\t                }\n\t            },\n\t            getV4CredentialsString: function(spec) {\n\t                return spec.key + \"/\" + qq.s3.util.getCredentialsDate(spec.date) + \"/\" + spec.region + \"/s3/aws4_request\";\n\t            },\n\t            getV4PolicyDate: function(date, drift) {\n\t                var adjustedDate = new Date(date.getTime() + drift);\n\t                return qq.s3.util.getCredentialsDate(adjustedDate) + \"T\" + (\"0\" + adjustedDate.getUTCHours()).slice(-2) + (\"0\" + adjustedDate.getUTCMinutes()).slice(-2) + (\"0\" + adjustedDate.getUTCSeconds()).slice(-2) + \"Z\";\n\t            },\n\t            encodeQueryStringParam: function(param) {\n\t                var percentEncoded = encodeURIComponent(param);\n\t                percentEncoded = percentEncoded.replace(/[!'()]/g, escape);\n\t                percentEncoded = percentEncoded.replace(/\\*/g, \"%2A\");\n\t                return percentEncoded.replace(/%20/g, \"+\");\n\t            },\n\t            uriEscape: function(string) {\n\t                var output = encodeURIComponent(string);\n\t                output = output.replace(/[^A-Za-z0-9_.~\\-%]+/g, escape);\n\t                output = output.replace(/[*]/g, function(ch) {\n\t                    return \"%\" + ch.charCodeAt(0).toString(16).toUpperCase();\n\t                });\n\t                return output;\n\t            },\n\t            uriEscapePath: function(path) {\n\t                var parts = [];\n\t                qq.each(path.split(\"/\"), function(idx, item) {\n\t                    parts.push(qq.s3.util.uriEscape(item));\n\t                });\n\t                return parts.join(\"/\");\n\t            }\n\t        };\n\t    }();\n\t    (function() {\n\t        \"use strict\";\n\t        qq.nonTraditionalBasePublicApi = {\n\t            setUploadSuccessParams: function(params, id) {\n\t                this._uploadSuccessParamsStore.set(params, id);\n\t            },\n\t            setUploadSuccessEndpoint: function(endpoint, id) {\n\t                this._uploadSuccessEndpointStore.set(endpoint, id);\n\t            }\n\t        };\n\t        qq.nonTraditionalBasePrivateApi = {\n\t            _onComplete: function(id, name, result, xhr) {\n\t                var success = result.success ? true : false, self = this, onCompleteArgs = arguments, successEndpoint = this._uploadSuccessEndpointStore.get(id), successCustomHeaders = this._options.uploadSuccess.customHeaders, successMethod = this._options.uploadSuccess.method, cors = this._options.cors, promise = new qq.Promise(), uploadSuccessParams = this._uploadSuccessParamsStore.get(id), fileParams = this._paramsStore.get(id), onSuccessFromServer = function(successRequestResult) {\n\t                    delete self._failedSuccessRequestCallbacks[id];\n\t                    qq.extend(result, successRequestResult);\n\t                    qq.FineUploaderBasic.prototype._onComplete.apply(self, onCompleteArgs);\n\t                    promise.success(successRequestResult);\n\t                }, onFailureFromServer = function(successRequestResult) {\n\t                    var callback = submitSuccessRequest;\n\t                    qq.extend(result, successRequestResult);\n\t                    if (result && result.reset) {\n\t                        callback = null;\n\t                    }\n\t                    if (!callback) {\n\t                        delete self._failedSuccessRequestCallbacks[id];\n\t                    } else {\n\t                        self._failedSuccessRequestCallbacks[id] = callback;\n\t                    }\n\t                    if (!self._onAutoRetry(id, name, result, xhr, callback)) {\n\t                        qq.FineUploaderBasic.prototype._onComplete.apply(self, onCompleteArgs);\n\t                        promise.failure(successRequestResult);\n\t                    }\n\t                }, submitSuccessRequest, successAjaxRequester;\n\t                if (success && successEndpoint) {\n\t                    successAjaxRequester = new qq.UploadSuccessAjaxRequester({\n\t                        endpoint: successEndpoint,\n\t                        method: successMethod,\n\t                        customHeaders: successCustomHeaders,\n\t                        cors: cors,\n\t                        log: qq.bind(this.log, this)\n\t                    });\n\t                    qq.extend(uploadSuccessParams, self._getEndpointSpecificParams(id, result, xhr), true);\n\t                    fileParams && qq.extend(uploadSuccessParams, fileParams, true);\n\t                    submitSuccessRequest = qq.bind(function() {\n\t                        successAjaxRequester.sendSuccessRequest(id, uploadSuccessParams).then(onSuccessFromServer, onFailureFromServer);\n\t                    }, self);\n\t                    submitSuccessRequest();\n\t                    return promise;\n\t                }\n\t                return qq.FineUploaderBasic.prototype._onComplete.apply(this, arguments);\n\t            },\n\t            _manualRetry: function(id) {\n\t                var successRequestCallback = this._failedSuccessRequestCallbacks[id];\n\t                return qq.FineUploaderBasic.prototype._manualRetry.call(this, id, successRequestCallback);\n\t            }\n\t        };\n\t    })();\n\t    (function() {\n\t        \"use strict\";\n\t        qq.s3.FineUploaderBasic = function(o) {\n\t            var options = {\n\t                request: {\n\t                    accessKey: null,\n\t                    clockDrift: 0\n\t                },\n\t                objectProperties: {\n\t                    acl: \"private\",\n\t                    bucket: qq.bind(function(id) {\n\t                        return qq.s3.util.getBucket(this.getEndpoint(id));\n\t                    }, this),\n\t                    host: qq.bind(function(id) {\n\t                        return /(?:http|https):\\/\\/(.+)(?:\\/.+)?/.exec(this._endpointStore.get(id))[1];\n\t                    }, this),\n\t                    key: \"uuid\",\n\t                    reducedRedundancy: false,\n\t                    region: \"us-east-1\",\n\t                    serverSideEncryption: false\n\t                },\n\t                credentials: {\n\t                    accessKey: null,\n\t                    secretKey: null,\n\t                    expiration: null,\n\t                    sessionToken: null\n\t                },\n\t                signature: {\n\t                    customHeaders: {},\n\t                    endpoint: null,\n\t                    version: 2\n\t                },\n\t                uploadSuccess: {\n\t                    endpoint: null,\n\t                    method: \"POST\",\n\t                    params: {},\n\t                    customHeaders: {}\n\t                },\n\t                iframeSupport: {\n\t                    localBlankPagePath: null\n\t                },\n\t                chunking: {\n\t                    partSize: 5242880\n\t                },\n\t                cors: {\n\t                    allowXdr: true\n\t                },\n\t                callbacks: {\n\t                    onCredentialsExpired: function() {}\n\t                }\n\t            };\n\t            qq.extend(options, o, true);\n\t            if (!this.setCredentials(options.credentials, true)) {\n\t                this._currentCredentials.accessKey = options.request.accessKey;\n\t            }\n\t            this._aclStore = this._createStore(options.objectProperties.acl);\n\t            qq.FineUploaderBasic.call(this, options);\n\t            this._uploadSuccessParamsStore = this._createStore(this._options.uploadSuccess.params);\n\t            this._uploadSuccessEndpointStore = this._createStore(this._options.uploadSuccess.endpoint);\n\t            this._failedSuccessRequestCallbacks = {};\n\t            this._cannedKeys = {};\n\t            this._cannedBuckets = {};\n\t            this._buckets = {};\n\t            this._hosts = {};\n\t        };\n\t        qq.extend(qq.s3.FineUploaderBasic.prototype, qq.basePublicApi);\n\t        qq.extend(qq.s3.FineUploaderBasic.prototype, qq.basePrivateApi);\n\t        qq.extend(qq.s3.FineUploaderBasic.prototype, qq.nonTraditionalBasePublicApi);\n\t        qq.extend(qq.s3.FineUploaderBasic.prototype, qq.nonTraditionalBasePrivateApi);\n\t        qq.extend(qq.s3.FineUploaderBasic.prototype, {\n\t            getBucket: function(id) {\n\t                if (this._cannedBuckets[id] == null) {\n\t                    return this._buckets[id];\n\t                }\n\t                return this._cannedBuckets[id];\n\t            },\n\t            getKey: function(id) {\n\t                if (this._cannedKeys[id] == null) {\n\t                    return this._handler.getThirdPartyFileId(id);\n\t                }\n\t                return this._cannedKeys[id];\n\t            },\n\t            reset: function() {\n\t                qq.FineUploaderBasic.prototype.reset.call(this);\n\t                this._failedSuccessRequestCallbacks = [];\n\t                this._buckets = {};\n\t                this._hosts = {};\n\t            },\n\t            setCredentials: function(credentials, ignoreEmpty) {\n\t                if (credentials && credentials.secretKey) {\n\t                    if (!credentials.accessKey) {\n\t                        throw new qq.Error(\"Invalid credentials: no accessKey\");\n\t                    } else if (!credentials.expiration) {\n\t                        throw new qq.Error(\"Invalid credentials: no expiration\");\n\t                    } else {\n\t                        this._currentCredentials = qq.extend({}, credentials);\n\t                        if (qq.isString(credentials.expiration)) {\n\t                            this._currentCredentials.expiration = new Date(credentials.expiration);\n\t                        }\n\t                    }\n\t                    return true;\n\t                } else if (!ignoreEmpty) {\n\t                    throw new qq.Error(\"Invalid credentials parameter!\");\n\t                } else {\n\t                    this._currentCredentials = {};\n\t                }\n\t            },\n\t            setAcl: function(acl, id) {\n\t                this._aclStore.set(acl, id);\n\t            },\n\t            _createUploadHandler: function() {\n\t                var self = this, additionalOptions = {\n\t                    aclStore: this._aclStore,\n\t                    getBucket: qq.bind(this._determineBucket, this),\n\t                    getHost: qq.bind(this._determineHost, this),\n\t                    getKeyName: qq.bind(this._determineKeyName, this),\n\t                    iframeSupport: this._options.iframeSupport,\n\t                    objectProperties: this._options.objectProperties,\n\t                    signature: this._options.signature,\n\t                    clockDrift: this._options.request.clockDrift,\n\t                    validation: {\n\t                        minSizeLimit: this._options.validation.minSizeLimit,\n\t                        maxSizeLimit: this._options.validation.sizeLimit\n\t                    }\n\t                };\n\t                qq.override(this._endpointStore, function(super_) {\n\t                    return {\n\t                        get: function(id) {\n\t                            var endpoint = super_.get(id);\n\t                            if (endpoint.indexOf(\"http\") < 0) {\n\t                                return \"http://\" + endpoint;\n\t                            }\n\t                            return endpoint;\n\t                        }\n\t                    };\n\t                });\n\t                qq.override(this._paramsStore, function(super_) {\n\t                    return {\n\t                        get: function(id) {\n\t                            var oldParams = super_.get(id), modifiedParams = {};\n\t                            qq.each(oldParams, function(name, val) {\n\t                                var paramName = name;\n\t                                if (qq.indexOf(qq.s3.util.CASE_SENSITIVE_PARAM_NAMES, paramName) < 0) {\n\t                                    paramName = paramName.toLowerCase();\n\t                                }\n\t                                modifiedParams[paramName] = qq.isFunction(val) ? val() : val;\n\t                            });\n\t                            return modifiedParams;\n\t                        }\n\t                    };\n\t                });\n\t                additionalOptions.signature.credentialsProvider = {\n\t                    get: function() {\n\t                        return self._currentCredentials;\n\t                    },\n\t                    onExpired: function() {\n\t                        var updateCredentials = new qq.Promise(), callbackRetVal = self._options.callbacks.onCredentialsExpired();\n\t                        if (qq.isGenericPromise(callbackRetVal)) {\n\t                            callbackRetVal.then(function(credentials) {\n\t                                try {\n\t                                    self.setCredentials(credentials);\n\t                                    updateCredentials.success();\n\t                                } catch (error) {\n\t                                    self.log(\"Invalid credentials returned from onCredentialsExpired callback! (\" + error.message + \")\", \"error\");\n\t                                    updateCredentials.failure(\"onCredentialsExpired did not return valid credentials.\");\n\t                                }\n\t                            }, function(errorMsg) {\n\t                                self.log(\"onCredentialsExpired callback indicated failure! (\" + errorMsg + \")\", \"error\");\n\t                                updateCredentials.failure(\"onCredentialsExpired callback failed.\");\n\t                            });\n\t                        } else {\n\t                            self.log(\"onCredentialsExpired callback did not return a promise!\", \"error\");\n\t                            updateCredentials.failure(\"Unexpected return value for onCredentialsExpired.\");\n\t                        }\n\t                        return updateCredentials;\n\t                    }\n\t                };\n\t                return qq.FineUploaderBasic.prototype._createUploadHandler.call(this, additionalOptions, \"s3\");\n\t            },\n\t            _determineObjectPropertyValue: function(id, property) {\n\t                var maybe = this._options.objectProperties[property], promise = new qq.Promise(), self = this;\n\t                if (qq.isFunction(maybe)) {\n\t                    maybe = maybe(id);\n\t                    if (qq.isGenericPromise(maybe)) {\n\t                        promise = maybe;\n\t                    } else {\n\t                        promise.success(maybe);\n\t                    }\n\t                } else if (qq.isString(maybe)) {\n\t                    promise.success(maybe);\n\t                }\n\t                promise.then(function success(value) {\n\t                    self[\"_\" + property + \"s\"][id] = value;\n\t                }, function failure(errorMsg) {\n\t                    qq.log(\"Problem determining \" + property + \" for ID \" + id + \" (\" + errorMsg + \")\", \"error\");\n\t                });\n\t                return promise;\n\t            },\n\t            _determineBucket: function(id) {\n\t                return this._determineObjectPropertyValue(id, \"bucket\");\n\t            },\n\t            _determineHost: function(id) {\n\t                return this._determineObjectPropertyValue(id, \"host\");\n\t            },\n\t            _determineKeyName: function(id, filename) {\n\t                var promise = new qq.Promise(), keynameLogic = this._options.objectProperties.key, extension = qq.getExtension(filename), onGetKeynameFailure = promise.failure, onGetKeynameSuccess = function(keyname, extension) {\n\t                    var keynameToUse = keyname;\n\t                    if (extension !== undefined) {\n\t                        keynameToUse += \".\" + extension;\n\t                    }\n\t                    promise.success(keynameToUse);\n\t                };\n\t                switch (keynameLogic) {\n\t                  case \"uuid\":\n\t                    onGetKeynameSuccess(this.getUuid(id), extension);\n\t                    break;\n\t\n\t                  case \"filename\":\n\t                    onGetKeynameSuccess(filename);\n\t                    break;\n\t\n\t                  default:\n\t                    if (qq.isFunction(keynameLogic)) {\n\t                        this._handleKeynameFunction(keynameLogic, id, onGetKeynameSuccess, onGetKeynameFailure);\n\t                    } else {\n\t                        this.log(keynameLogic + \" is not a valid value for the s3.keyname option!\", \"error\");\n\t                        onGetKeynameFailure();\n\t                    }\n\t                }\n\t                return promise;\n\t            },\n\t            _handleKeynameFunction: function(keynameFunc, id, successCallback, failureCallback) {\n\t                var self = this, onSuccess = function(keyname) {\n\t                    successCallback(keyname);\n\t                }, onFailure = function(reason) {\n\t                    self.log(qq.format(\"Failed to retrieve key name for {}.  Reason: {}\", id, reason || \"null\"), \"error\");\n\t                    failureCallback(reason);\n\t                }, keyname = keynameFunc.call(this, id);\n\t                if (qq.isGenericPromise(keyname)) {\n\t                    keyname.then(onSuccess, onFailure);\n\t                } else if (keyname == null) {\n\t                    onFailure();\n\t                } else {\n\t                    onSuccess(keyname);\n\t                }\n\t            },\n\t            _getEndpointSpecificParams: function(id, response, maybeXhr) {\n\t                var params = {\n\t                    key: this.getKey(id),\n\t                    uuid: this.getUuid(id),\n\t                    name: this.getName(id),\n\t                    bucket: this.getBucket(id)\n\t                };\n\t                if (maybeXhr && maybeXhr.getResponseHeader(\"ETag\")) {\n\t                    params.etag = maybeXhr.getResponseHeader(\"ETag\");\n\t                } else if (response.etag) {\n\t                    params.etag = response.etag;\n\t                }\n\t                return params;\n\t            },\n\t            _onSubmitDelete: function(id, onSuccessCallback) {\n\t                var additionalMandatedParams = {\n\t                    key: this.getKey(id),\n\t                    bucket: this.getBucket(id)\n\t                };\n\t                return qq.FineUploaderBasic.prototype._onSubmitDelete.call(this, id, onSuccessCallback, additionalMandatedParams);\n\t            },\n\t            _addCannedFile: function(sessionData) {\n\t                var id;\n\t                if (sessionData.s3Key == null) {\n\t                    throw new qq.Error(\"Did not find s3Key property in server session response.  This is required!\");\n\t                } else {\n\t                    id = qq.FineUploaderBasic.prototype._addCannedFile.apply(this, arguments);\n\t                    this._cannedKeys[id] = sessionData.s3Key;\n\t                    this._cannedBuckets[id] = sessionData.s3Bucket;\n\t                }\n\t                return id;\n\t            }\n\t        });\n\t    })();\n\t    if (!window.Uint8ClampedArray) {\n\t        window.Uint8ClampedArray = function() {};\n\t    }\n\t    qq.s3.RequestSigner = function(o) {\n\t        \"use strict\";\n\t        var requester, thisSignatureRequester = this, pendingSignatures = {}, options = {\n\t            expectingPolicy: false,\n\t            method: \"POST\",\n\t            signatureSpec: {\n\t                drift: 0,\n\t                credentialsProvider: {},\n\t                endpoint: null,\n\t                customHeaders: {},\n\t                version: 2\n\t            },\n\t            maxConnections: 3,\n\t            endpointStore: {},\n\t            paramsStore: {},\n\t            cors: {\n\t                expected: false,\n\t                sendCredentials: false\n\t            },\n\t            log: function(str, level) {}\n\t        }, credentialsProvider, generateHeaders = function(signatureConstructor, signature, promise) {\n\t            var headers = signatureConstructor.getHeaders();\n\t            if (options.signatureSpec.version === 4) {\n\t                headers.Authorization = qq.s3.util.V4_ALGORITHM_PARAM_VALUE + \" Credential=\" + options.signatureSpec.credentialsProvider.get().accessKey + \"/\" + qq.s3.util.getCredentialsDate(signatureConstructor.getRequestDate()) + \"/\" + options.signatureSpec.region + \"/\" + \"s3/aws4_request,\" + \"SignedHeaders=\" + signatureConstructor.getSignedHeaders() + \",\" + \"Signature=\" + signature;\n\t            } else {\n\t                headers.Authorization = \"AWS \" + options.signatureSpec.credentialsProvider.get().accessKey + \":\" + signature;\n\t            }\n\t            promise.success(headers, signatureConstructor.getEndOfUrl());\n\t        }, v2 = {\n\t            getStringToSign: function(signatureSpec) {\n\t                return qq.format(\"{}\\n{}\\n{}\\n\\n{}/{}/{}\", signatureSpec.method, signatureSpec.contentMd5 || \"\", signatureSpec.contentType || \"\", signatureSpec.headersStr || \"\\n\", signatureSpec.bucket, signatureSpec.endOfUrl);\n\t            },\n\t            signApiRequest: function(signatureConstructor, headersStr, signatureEffort) {\n\t                var headersWordArray = qq.CryptoJS.enc.Utf8.parse(headersStr), headersHmacSha1 = qq.CryptoJS.HmacSHA1(headersWordArray, credentialsProvider.get().secretKey), headersHmacSha1Base64 = qq.CryptoJS.enc.Base64.stringify(headersHmacSha1);\n\t                generateHeaders(signatureConstructor, headersHmacSha1Base64, signatureEffort);\n\t            },\n\t            signPolicy: function(policy, signatureEffort, updatedAccessKey, updatedSessionToken) {\n\t                var policyStr = JSON.stringify(policy), policyWordArray = qq.CryptoJS.enc.Utf8.parse(policyStr), base64Policy = qq.CryptoJS.enc.Base64.stringify(policyWordArray), policyHmacSha1 = qq.CryptoJS.HmacSHA1(base64Policy, credentialsProvider.get().secretKey), policyHmacSha1Base64 = qq.CryptoJS.enc.Base64.stringify(policyHmacSha1);\n\t                signatureEffort.success({\n\t                    policy: base64Policy,\n\t                    signature: policyHmacSha1Base64\n\t                }, updatedAccessKey, updatedSessionToken);\n\t            }\n\t        }, v4 = {\n\t            getCanonicalQueryString: function(endOfUri) {\n\t                var queryParamIdx = endOfUri.indexOf(\"?\"), canonicalQueryString = \"\", encodedQueryParams, encodedQueryParamNames, queryStrings;\n\t                if (queryParamIdx >= 0) {\n\t                    encodedQueryParams = {};\n\t                    queryStrings = endOfUri.substr(queryParamIdx + 1).split(\"&\");\n\t                    qq.each(queryStrings, function(idx, queryString) {\n\t                        var nameAndVal = queryString.split(\"=\"), paramVal = nameAndVal[1];\n\t                        if (paramVal == null) {\n\t                            paramVal = \"\";\n\t                        }\n\t                        encodedQueryParams[encodeURIComponent(nameAndVal[0])] = encodeURIComponent(paramVal);\n\t                    });\n\t                    encodedQueryParamNames = Object.keys(encodedQueryParams).sort();\n\t                    encodedQueryParamNames.forEach(function(encodedQueryParamName, idx) {\n\t                        canonicalQueryString += encodedQueryParamName + \"=\" + encodedQueryParams[encodedQueryParamName];\n\t                        if (idx < encodedQueryParamNames.length - 1) {\n\t                            canonicalQueryString += \"&\";\n\t                        }\n\t                    });\n\t                }\n\t                return canonicalQueryString;\n\t            },\n\t            getCanonicalRequest: function(signatureSpec) {\n\t                return qq.format(\"{}\\n{}\\n{}\\n{}\\n{}\\n{}\", signatureSpec.method, v4.getCanonicalUri(signatureSpec.endOfUrl), v4.getCanonicalQueryString(signatureSpec.endOfUrl), signatureSpec.headersStr || \"\\n\", v4.getSignedHeaders(signatureSpec.headerNames), signatureSpec.hashedContent);\n\t            },\n\t            getCanonicalUri: function(endOfUri) {\n\t                var path = endOfUri, queryParamIdx = endOfUri.indexOf(\"?\");\n\t                if (queryParamIdx > 0) {\n\t                    path = endOfUri.substr(0, queryParamIdx);\n\t                }\n\t                return \"/\" + path;\n\t            },\n\t            getEncodedHashedPayload: function(body) {\n\t                var promise = new qq.Promise(), reader;\n\t                if (qq.isBlob(body)) {\n\t                    reader = new FileReader();\n\t                    reader.onloadend = function(e) {\n\t                        if (e.target.readyState === FileReader.DONE) {\n\t                            if (e.target.error) {\n\t                                promise.failure(e.target.error);\n\t                            } else {\n\t                                var wordArray = qq.CryptoJS.lib.WordArray.create(e.target.result);\n\t                                promise.success(qq.CryptoJS.SHA256(wordArray).toString());\n\t                            }\n\t                        }\n\t                    };\n\t                    reader.readAsArrayBuffer(body);\n\t                } else {\n\t                    body = body || \"\";\n\t                    promise.success(qq.CryptoJS.SHA256(body).toString());\n\t                }\n\t                return promise;\n\t            },\n\t            getScope: function(date, region) {\n\t                return qq.s3.util.getCredentialsDate(date) + \"/\" + region + \"/s3/aws4_request\";\n\t            },\n\t            getStringToSign: function(signatureSpec) {\n\t                var canonicalRequest = v4.getCanonicalRequest(signatureSpec), date = qq.s3.util.getV4PolicyDate(signatureSpec.date, signatureSpec.drift), hashedRequest = qq.CryptoJS.SHA256(canonicalRequest).toString(), scope = v4.getScope(signatureSpec.date, options.signatureSpec.region), stringToSignTemplate = \"AWS4-HMAC-SHA256\\n{}\\n{}\\n{}\";\n\t                return {\n\t                    hashed: qq.format(stringToSignTemplate, date, scope, hashedRequest),\n\t                    raw: qq.format(stringToSignTemplate, date, scope, canonicalRequest)\n\t                };\n\t            },\n\t            getSignedHeaders: function(headerNames) {\n\t                var signedHeaders = \"\";\n\t                headerNames.forEach(function(headerName, idx) {\n\t                    signedHeaders += headerName.toLowerCase();\n\t                    if (idx < headerNames.length - 1) {\n\t                        signedHeaders += \";\";\n\t                    }\n\t                });\n\t                return signedHeaders;\n\t            },\n\t            signApiRequest: function(signatureConstructor, headersStr, signatureEffort) {\n\t                var secretKey = credentialsProvider.get().secretKey, headersPattern = /.+\\n.+\\n(\\d+)\\/(.+)\\/s3\\/.+\\n(.+)/, matches = headersPattern.exec(headersStr), dateKey, dateRegionKey, dateRegionServiceKey, signingKey;\n\t                dateKey = qq.CryptoJS.HmacSHA256(matches[1], \"AWS4\" + secretKey);\n\t                dateRegionKey = qq.CryptoJS.HmacSHA256(matches[2], dateKey);\n\t                dateRegionServiceKey = qq.CryptoJS.HmacSHA256(\"s3\", dateRegionKey);\n\t                signingKey = qq.CryptoJS.HmacSHA256(\"aws4_request\", dateRegionServiceKey);\n\t                generateHeaders(signatureConstructor, qq.CryptoJS.HmacSHA256(headersStr, signingKey), signatureEffort);\n\t            },\n\t            signPolicy: function(policy, signatureEffort, updatedAccessKey, updatedSessionToken) {\n\t                var policyStr = JSON.stringify(policy), policyWordArray = qq.CryptoJS.enc.Utf8.parse(policyStr), base64Policy = qq.CryptoJS.enc.Base64.stringify(policyWordArray), secretKey = credentialsProvider.get().secretKey, credentialPattern = /.+\\/(.+)\\/(.+)\\/s3\\/aws4_request/, credentialCondition = function() {\n\t                    var credential = null;\n\t                    qq.each(policy.conditions, function(key, condition) {\n\t                        var val = condition[\"x-amz-credential\"];\n\t                        if (val) {\n\t                            credential = val;\n\t                            return false;\n\t                        }\n\t                    });\n\t                    return credential;\n\t                }(), matches, dateKey, dateRegionKey, dateRegionServiceKey, signingKey;\n\t                matches = credentialPattern.exec(credentialCondition);\n\t                dateKey = qq.CryptoJS.HmacSHA256(matches[1], \"AWS4\" + secretKey);\n\t                dateRegionKey = qq.CryptoJS.HmacSHA256(matches[2], dateKey);\n\t                dateRegionServiceKey = qq.CryptoJS.HmacSHA256(\"s3\", dateRegionKey);\n\t                signingKey = qq.CryptoJS.HmacSHA256(\"aws4_request\", dateRegionServiceKey);\n\t                signatureEffort.success({\n\t                    policy: base64Policy,\n\t                    signature: qq.CryptoJS.HmacSHA256(base64Policy, signingKey).toString()\n\t                }, updatedAccessKey, updatedSessionToken);\n\t            }\n\t        };\n\t        qq.extend(options, o, true);\n\t        credentialsProvider = options.signatureSpec.credentialsProvider;\n\t        function handleSignatureReceived(id, xhrOrXdr, isError) {\n\t            var responseJson = xhrOrXdr.responseText, pendingSignatureData = pendingSignatures[id], promise = pendingSignatureData.promise, signatureConstructor = pendingSignatureData.signatureConstructor, errorMessage, response;\n\t            delete pendingSignatures[id];\n\t            if (responseJson) {\n\t                try {\n\t                    response = qq.parseJson(responseJson);\n\t                } catch (error) {\n\t                    options.log(\"Error attempting to parse signature response: \" + error, \"error\");\n\t                }\n\t            }\n\t            if (response && response.invalid) {\n\t                isError = true;\n\t                errorMessage = \"Invalid policy document or request headers!\";\n\t            } else if (response) {\n\t                if (options.expectingPolicy && !response.policy) {\n\t                    isError = true;\n\t                    errorMessage = \"Response does not include the base64 encoded policy!\";\n\t                } else if (!response.signature) {\n\t                    isError = true;\n\t                    errorMessage = \"Response does not include the signature!\";\n\t                }\n\t            } else {\n\t                isError = true;\n\t                errorMessage = \"Received an empty or invalid response from the server!\";\n\t            }\n\t            if (isError) {\n\t                if (errorMessage) {\n\t                    options.log(errorMessage, \"error\");\n\t                }\n\t                promise.failure(errorMessage);\n\t            } else if (signatureConstructor) {\n\t                generateHeaders(signatureConstructor, response.signature, promise);\n\t            } else {\n\t                promise.success(response);\n\t            }\n\t        }\n\t        function getStringToSignArtifacts(id, version, requestInfo) {\n\t            var promise = new qq.Promise(), method = \"POST\", headerNames = [], headersStr = \"\", now = new Date(), endOfUrl, signatureSpec, toSign, generateStringToSign = function(requestInfo) {\n\t                var contentMd5, headerIndexesToRemove = [];\n\t                qq.each(requestInfo.headers, function(name) {\n\t                    headerNames.push(name);\n\t                });\n\t                headerNames.sort();\n\t                qq.each(headerNames, function(idx, headerName) {\n\t                    if (qq.indexOf(qq.s3.util.UNSIGNABLE_REST_HEADER_NAMES, headerName) < 0) {\n\t                        headersStr += headerName.toLowerCase() + \":\" + requestInfo.headers[headerName].trim() + \"\\n\";\n\t                    } else if (headerName === \"Content-MD5\") {\n\t                        contentMd5 = requestInfo.headers[headerName];\n\t                    } else {\n\t                        headerIndexesToRemove.unshift(idx);\n\t                    }\n\t                });\n\t                qq.each(headerIndexesToRemove, function(idx, headerIdx) {\n\t                    headerNames.splice(headerIdx, 1);\n\t                });\n\t                signatureSpec = {\n\t                    bucket: requestInfo.bucket,\n\t                    contentMd5: contentMd5,\n\t                    contentType: requestInfo.contentType,\n\t                    date: now,\n\t                    drift: options.signatureSpec.drift,\n\t                    endOfUrl: endOfUrl,\n\t                    hashedContent: requestInfo.hashedContent,\n\t                    headerNames: headerNames,\n\t                    headersStr: headersStr,\n\t                    method: method\n\t                };\n\t                toSign = version === 2 ? v2.getStringToSign(signatureSpec) : v4.getStringToSign(signatureSpec);\n\t                return {\n\t                    date: now,\n\t                    endOfUrl: endOfUrl,\n\t                    signedHeaders: version === 4 ? v4.getSignedHeaders(signatureSpec.headerNames) : null,\n\t                    toSign: version === 4 ? toSign.hashed : toSign,\n\t                    toSignRaw: version === 4 ? toSign.raw : toSign\n\t                };\n\t            };\n\t            switch (requestInfo.type) {\n\t              case thisSignatureRequester.REQUEST_TYPE.MULTIPART_ABORT:\n\t                method = \"DELETE\";\n\t                endOfUrl = qq.format(\"uploadId={}\", requestInfo.uploadId);\n\t                break;\n\t\n\t              case thisSignatureRequester.REQUEST_TYPE.MULTIPART_INITIATE:\n\t                endOfUrl = \"uploads\";\n\t                break;\n\t\n\t              case thisSignatureRequester.REQUEST_TYPE.MULTIPART_COMPLETE:\n\t                endOfUrl = qq.format(\"uploadId={}\", requestInfo.uploadId);\n\t                break;\n\t\n\t              case thisSignatureRequester.REQUEST_TYPE.MULTIPART_UPLOAD:\n\t                method = \"PUT\";\n\t                endOfUrl = qq.format(\"partNumber={}&uploadId={}\", requestInfo.partNum, requestInfo.uploadId);\n\t                break;\n\t            }\n\t            endOfUrl = requestInfo.key + \"?\" + endOfUrl;\n\t            if (version === 4) {\n\t                v4.getEncodedHashedPayload(requestInfo.content).then(function(hashedContent) {\n\t                    requestInfo.headers[\"x-amz-content-sha256\"] = hashedContent;\n\t                    requestInfo.headers.Host = requestInfo.host;\n\t                    requestInfo.headers[\"x-amz-date\"] = qq.s3.util.getV4PolicyDate(now, options.signatureSpec.drift);\n\t                    requestInfo.hashedContent = hashedContent;\n\t                    promise.success(generateStringToSign(requestInfo));\n\t                }, function(err) {\n\t                    promise.failure(err);\n\t                });\n\t            } else {\n\t                promise.success(generateStringToSign(requestInfo));\n\t            }\n\t            return promise;\n\t        }\n\t        function determineSignatureClientSide(id, toBeSigned, signatureEffort, updatedAccessKey, updatedSessionToken) {\n\t            var updatedHeaders;\n\t            if (toBeSigned.signatureConstructor) {\n\t                if (updatedSessionToken) {\n\t                    updatedHeaders = toBeSigned.signatureConstructor.getHeaders();\n\t                    updatedHeaders[qq.s3.util.SESSION_TOKEN_PARAM_NAME] = updatedSessionToken;\n\t                    toBeSigned.signatureConstructor.withHeaders(updatedHeaders);\n\t                }\n\t                toBeSigned.signatureConstructor.getToSign(id).then(function(signatureArtifacts) {\n\t                    signApiRequest(toBeSigned.signatureConstructor, signatureArtifacts.stringToSign, signatureEffort);\n\t                }, function(err) {\n\t                    signatureEffort.failure(err);\n\t                });\n\t            } else {\n\t                updatedSessionToken && qq.s3.util.refreshPolicyCredentials(toBeSigned, updatedSessionToken);\n\t                signPolicy(toBeSigned, signatureEffort, updatedAccessKey, updatedSessionToken);\n\t            }\n\t        }\n\t        function signPolicy(policy, signatureEffort, updatedAccessKey, updatedSessionToken) {\n\t            if (options.signatureSpec.version === 4) {\n\t                v4.signPolicy(policy, signatureEffort, updatedAccessKey, updatedSessionToken);\n\t            } else {\n\t                v2.signPolicy(policy, signatureEffort, updatedAccessKey, updatedSessionToken);\n\t            }\n\t        }\n\t        function signApiRequest(signatureConstructor, headersStr, signatureEffort) {\n\t            if (options.signatureSpec.version === 4) {\n\t                v4.signApiRequest(signatureConstructor, headersStr, signatureEffort);\n\t            } else {\n\t                v2.signApiRequest(signatureConstructor, headersStr, signatureEffort);\n\t            }\n\t        }\n\t        requester = qq.extend(this, new qq.AjaxRequester({\n\t            acceptHeader: \"application/json\",\n\t            method: options.method,\n\t            contentType: \"application/json; charset=utf-8\",\n\t            endpointStore: {\n\t                get: function() {\n\t                    return options.signatureSpec.endpoint;\n\t                }\n\t            },\n\t            paramsStore: options.paramsStore,\n\t            maxConnections: options.maxConnections,\n\t            customHeaders: options.signatureSpec.customHeaders,\n\t            log: options.log,\n\t            onComplete: handleSignatureReceived,\n\t            cors: options.cors\n\t        }));\n\t        qq.extend(this, {\n\t            getSignature: function(id, toBeSigned) {\n\t                var params = toBeSigned, signatureConstructor = toBeSigned.signatureConstructor, signatureEffort = new qq.Promise(), queryParams;\n\t                if (options.signatureSpec.version === 4) {\n\t                    queryParams = {\n\t                        v4: true\n\t                    };\n\t                }\n\t                if (credentialsProvider.get().secretKey && qq.CryptoJS) {\n\t                    if (credentialsProvider.get().expiration.getTime() > Date.now()) {\n\t                        determineSignatureClientSide(id, toBeSigned, signatureEffort);\n\t                    } else {\n\t                        credentialsProvider.onExpired().then(function() {\n\t                            determineSignatureClientSide(id, toBeSigned, signatureEffort, credentialsProvider.get().accessKey, credentialsProvider.get().sessionToken);\n\t                        }, function(errorMsg) {\n\t                            options.log(\"Attempt to update expired credentials apparently failed! Unable to sign request.  \", \"error\");\n\t                            signatureEffort.failure(\"Unable to sign request - expired credentials.\");\n\t                        });\n\t                    }\n\t                } else {\n\t                    options.log(\"Submitting S3 signature request for \" + id);\n\t                    if (signatureConstructor) {\n\t                        signatureConstructor.getToSign(id).then(function(signatureArtifacts) {\n\t                            params = {\n\t                                headers: signatureArtifacts.stringToSignRaw\n\t                            };\n\t                            requester.initTransport(id).withParams(params).withQueryParams(queryParams).send();\n\t                        }, function(err) {\n\t                            options.log(\"Failed to construct signature. \", \"error\");\n\t                            signatureEffort.failure(\"Failed to construct signature.\");\n\t                        });\n\t                    } else {\n\t                        requester.initTransport(id).withParams(params).withQueryParams(queryParams).send();\n\t                    }\n\t                    pendingSignatures[id] = {\n\t                        promise: signatureEffort,\n\t                        signatureConstructor: signatureConstructor\n\t                    };\n\t                }\n\t                return signatureEffort;\n\t            },\n\t            constructStringToSign: function(type, bucket, host, key) {\n\t                var headers = {}, uploadId, content, contentType, partNum, artifacts;\n\t                return {\n\t                    withHeaders: function(theHeaders) {\n\t                        headers = theHeaders;\n\t                        return this;\n\t                    },\n\t                    withUploadId: function(theUploadId) {\n\t                        uploadId = theUploadId;\n\t                        return this;\n\t                    },\n\t                    withContent: function(theContent) {\n\t                        content = theContent;\n\t                        return this;\n\t                    },\n\t                    withContentType: function(theContentType) {\n\t                        contentType = theContentType;\n\t                        return this;\n\t                    },\n\t                    withPartNum: function(thePartNum) {\n\t                        partNum = thePartNum;\n\t                        return this;\n\t                    },\n\t                    getToSign: function(id) {\n\t                        var sessionToken = credentialsProvider.get().sessionToken, promise = new qq.Promise(), adjustedDate = new Date(Date.now() + options.signatureSpec.drift);\n\t                        headers[\"x-amz-date\"] = adjustedDate.toUTCString();\n\t                        if (sessionToken) {\n\t                            headers[qq.s3.util.SESSION_TOKEN_PARAM_NAME] = sessionToken;\n\t                        }\n\t                        getStringToSignArtifacts(id, options.signatureSpec.version, {\n\t                            bucket: bucket,\n\t                            content: content,\n\t                            contentType: contentType,\n\t                            headers: headers,\n\t                            host: host,\n\t                            key: key,\n\t                            partNum: partNum,\n\t                            type: type,\n\t                            uploadId: uploadId\n\t                        }).then(function(_artifacts_) {\n\t                            artifacts = _artifacts_;\n\t                            promise.success({\n\t                                headers: function() {\n\t                                    if (contentType) {\n\t                                        headers[\"Content-Type\"] = contentType;\n\t                                    }\n\t                                    delete headers.Host;\n\t                                    return headers;\n\t                                }(),\n\t                                date: artifacts.date,\n\t                                endOfUrl: artifacts.endOfUrl,\n\t                                signedHeaders: artifacts.signedHeaders,\n\t                                stringToSign: artifacts.toSign,\n\t                                stringToSignRaw: artifacts.toSignRaw\n\t                            });\n\t                        }, function(err) {\n\t                            promise.failure(err);\n\t                        });\n\t                        return promise;\n\t                    },\n\t                    getHeaders: function() {\n\t                        return qq.extend({}, headers);\n\t                    },\n\t                    getEndOfUrl: function() {\n\t                        return artifacts && artifacts.endOfUrl;\n\t                    },\n\t                    getRequestDate: function() {\n\t                        return artifacts && artifacts.date;\n\t                    },\n\t                    getSignedHeaders: function() {\n\t                        return artifacts && artifacts.signedHeaders;\n\t                    }\n\t                };\n\t            }\n\t        });\n\t    };\n\t    qq.s3.RequestSigner.prototype.REQUEST_TYPE = {\n\t        MULTIPART_INITIATE: \"multipart_initiate\",\n\t        MULTIPART_COMPLETE: \"multipart_complete\",\n\t        MULTIPART_ABORT: \"multipart_abort\",\n\t        MULTIPART_UPLOAD: \"multipart_upload\"\n\t    };\n\t    qq.UploadSuccessAjaxRequester = function(o) {\n\t        \"use strict\";\n\t        var requester, pendingRequests = [], options = {\n\t            method: \"POST\",\n\t            endpoint: null,\n\t            maxConnections: 3,\n\t            customHeaders: {},\n\t            paramsStore: {},\n\t            cors: {\n\t                expected: false,\n\t                sendCredentials: false\n\t            },\n\t            log: function(str, level) {}\n\t        };\n\t        qq.extend(options, o);\n\t        function handleSuccessResponse(id, xhrOrXdr, isError) {\n\t            var promise = pendingRequests[id], responseJson = xhrOrXdr.responseText, successIndicator = {\n\t                success: true\n\t            }, failureIndicator = {\n\t                success: false\n\t            }, parsedResponse;\n\t            delete pendingRequests[id];\n\t            options.log(qq.format(\"Received the following response body to an upload success request for id {}: {}\", id, responseJson));\n\t            try {\n\t                parsedResponse = qq.parseJson(responseJson);\n\t                if (isError || parsedResponse && (parsedResponse.error || parsedResponse.success === false)) {\n\t                    options.log(\"Upload success request was rejected by the server.\", \"error\");\n\t                    promise.failure(qq.extend(parsedResponse, failureIndicator));\n\t                } else {\n\t                    options.log(\"Upload success was acknowledged by the server.\");\n\t                    promise.success(qq.extend(parsedResponse, successIndicator));\n\t                }\n\t            } catch (error) {\n\t                if (isError) {\n\t                    options.log(qq.format(\"Your server indicated failure in its upload success request response for id {}!\", id), \"error\");\n\t                    promise.failure(failureIndicator);\n\t                } else {\n\t                    options.log(\"Upload success was acknowledged by the server.\");\n\t                    promise.success(successIndicator);\n\t                }\n\t            }\n\t        }\n\t        requester = qq.extend(this, new qq.AjaxRequester({\n\t            acceptHeader: \"application/json\",\n\t            method: options.method,\n\t            endpointStore: {\n\t                get: function() {\n\t                    return options.endpoint;\n\t                }\n\t            },\n\t            paramsStore: options.paramsStore,\n\t            maxConnections: options.maxConnections,\n\t            customHeaders: options.customHeaders,\n\t            log: options.log,\n\t            onComplete: handleSuccessResponse,\n\t            cors: options.cors\n\t        }));\n\t        qq.extend(this, {\n\t            sendSuccessRequest: function(id, spec) {\n\t                var promise = new qq.Promise();\n\t                options.log(\"Submitting upload success request/notification for \" + id);\n\t                requester.initTransport(id).withParams(spec).send();\n\t                pendingRequests[id] = promise;\n\t                return promise;\n\t            }\n\t        });\n\t    };\n\t    qq.s3.InitiateMultipartAjaxRequester = function(o) {\n\t        \"use strict\";\n\t        var requester, pendingInitiateRequests = {}, options = {\n\t            filenameParam: \"qqfilename\",\n\t            method: \"POST\",\n\t            endpointStore: null,\n\t            paramsStore: null,\n\t            signatureSpec: null,\n\t            aclStore: null,\n\t            reducedRedundancy: false,\n\t            serverSideEncryption: false,\n\t            maxConnections: 3,\n\t            getContentType: function(id) {},\n\t            getBucket: function(id) {},\n\t            getHost: function(id) {},\n\t            getKey: function(id) {},\n\t            getName: function(id) {},\n\t            log: function(str, level) {}\n\t        }, getSignatureAjaxRequester;\n\t        qq.extend(options, o);\n\t        getSignatureAjaxRequester = new qq.s3.RequestSigner({\n\t            endpointStore: options.endpointStore,\n\t            signatureSpec: options.signatureSpec,\n\t            cors: options.cors,\n\t            log: options.log\n\t        });\n\t        function getHeaders(id) {\n\t            var bucket = options.getBucket(id), host = options.getHost(id), headers = {}, promise = new qq.Promise(), key = options.getKey(id), signatureConstructor;\n\t            headers[\"x-amz-acl\"] = options.aclStore.get(id);\n\t            if (options.reducedRedundancy) {\n\t                headers[qq.s3.util.REDUCED_REDUNDANCY_PARAM_NAME] = qq.s3.util.REDUCED_REDUNDANCY_PARAM_VALUE;\n\t            }\n\t            if (options.serverSideEncryption) {\n\t                headers[qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_NAME] = qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_VALUE;\n\t            }\n\t            headers[qq.s3.util.AWS_PARAM_PREFIX + options.filenameParam] = encodeURIComponent(options.getName(id));\n\t            qq.each(options.paramsStore.get(id), function(name, val) {\n\t                if (qq.indexOf(qq.s3.util.UNPREFIXED_PARAM_NAMES, name) >= 0) {\n\t                    headers[name] = val;\n\t                } else {\n\t                    headers[qq.s3.util.AWS_PARAM_PREFIX + name] = encodeURIComponent(val);\n\t                }\n\t            });\n\t            signatureConstructor = getSignatureAjaxRequester.constructStringToSign(getSignatureAjaxRequester.REQUEST_TYPE.MULTIPART_INITIATE, bucket, host, key).withContentType(options.getContentType(id)).withHeaders(headers);\n\t            getSignatureAjaxRequester.getSignature(id, {\n\t                signatureConstructor: signatureConstructor\n\t            }).then(promise.success, promise.failure);\n\t            return promise;\n\t        }\n\t        function handleInitiateRequestComplete(id, xhr, isError) {\n\t            var promise = pendingInitiateRequests[id], domParser = new DOMParser(), responseDoc = domParser.parseFromString(xhr.responseText, \"application/xml\"), uploadIdElements, messageElements, uploadId, errorMessage, status;\n\t            delete pendingInitiateRequests[id];\n\t            if (isError) {\n\t                status = xhr.status;\n\t                messageElements = responseDoc.getElementsByTagName(\"Message\");\n\t                if (messageElements.length > 0) {\n\t                    errorMessage = messageElements[0].textContent;\n\t                }\n\t            } else {\n\t                uploadIdElements = responseDoc.getElementsByTagName(\"UploadId\");\n\t                if (uploadIdElements.length > 0) {\n\t                    uploadId = uploadIdElements[0].textContent;\n\t                } else {\n\t                    errorMessage = \"Upload ID missing from request\";\n\t                }\n\t            }\n\t            if (uploadId === undefined) {\n\t                if (errorMessage) {\n\t                    options.log(qq.format(\"Specific problem detected initiating multipart upload request for {}: '{}'.\", id, errorMessage), \"error\");\n\t                } else {\n\t                    options.log(qq.format(\"Unexplained error with initiate multipart upload request for {}.  Status code {}.\", id, status), \"error\");\n\t                }\n\t                promise.failure(\"Problem initiating upload request.\", xhr);\n\t            } else {\n\t                options.log(qq.format(\"Initiate multipart upload request successful for {}.  Upload ID is {}\", id, uploadId));\n\t                promise.success(uploadId, xhr);\n\t            }\n\t        }\n\t        requester = qq.extend(this, new qq.AjaxRequester({\n\t            method: options.method,\n\t            contentType: null,\n\t            endpointStore: options.endpointStore,\n\t            maxConnections: options.maxConnections,\n\t            allowXRequestedWithAndCacheControl: false,\n\t            log: options.log,\n\t            onComplete: handleInitiateRequestComplete,\n\t            successfulResponseCodes: {\n\t                POST: [ 200 ]\n\t            }\n\t        }));\n\t        qq.extend(this, {\n\t            send: function(id) {\n\t                var promise = new qq.Promise();\n\t                getHeaders(id).then(function(headers, endOfUrl) {\n\t                    options.log(\"Submitting S3 initiate multipart upload request for \" + id);\n\t                    pendingInitiateRequests[id] = promise;\n\t                    requester.initTransport(id).withPath(endOfUrl).withHeaders(headers).send();\n\t                }, promise.failure);\n\t                return promise;\n\t            }\n\t        });\n\t    };\n\t    qq.s3.CompleteMultipartAjaxRequester = function(o) {\n\t        \"use strict\";\n\t        var requester, pendingCompleteRequests = {}, options = {\n\t            method: \"POST\",\n\t            contentType: \"text/xml\",\n\t            endpointStore: null,\n\t            signatureSpec: null,\n\t            maxConnections: 3,\n\t            getBucket: function(id) {},\n\t            getHost: function(id) {},\n\t            getKey: function(id) {},\n\t            log: function(str, level) {}\n\t        }, getSignatureAjaxRequester;\n\t        qq.extend(options, o);\n\t        getSignatureAjaxRequester = new qq.s3.RequestSigner({\n\t            endpointStore: options.endpointStore,\n\t            signatureSpec: options.signatureSpec,\n\t            cors: options.cors,\n\t            log: options.log\n\t        });\n\t        function getHeaders(id, uploadId, body) {\n\t            var headers = {}, promise = new qq.Promise(), bucket = options.getBucket(id), host = options.getHost(id), signatureConstructor = getSignatureAjaxRequester.constructStringToSign(getSignatureAjaxRequester.REQUEST_TYPE.MULTIPART_COMPLETE, bucket, host, options.getKey(id)).withUploadId(uploadId).withContent(body).withContentType(\"application/xml; charset=UTF-8\");\n\t            getSignatureAjaxRequester.getSignature(id, {\n\t                signatureConstructor: signatureConstructor\n\t            }).then(promise.success, promise.failure);\n\t            return promise;\n\t        }\n\t        function handleCompleteRequestComplete(id, xhr, isError) {\n\t            var promise = pendingCompleteRequests[id], domParser = new DOMParser(), bucket = options.getBucket(id), key = options.getKey(id), responseDoc = domParser.parseFromString(xhr.responseText, \"application/xml\"), bucketEls = responseDoc.getElementsByTagName(\"Bucket\"), keyEls = responseDoc.getElementsByTagName(\"Key\");\n\t            delete pendingCompleteRequests[id];\n\t            options.log(qq.format(\"Complete response status {}, body = {}\", xhr.status, xhr.responseText));\n\t            if (isError) {\n\t                options.log(qq.format(\"Complete Multipart Upload request for {} failed with status {}.\", id, xhr.status), \"error\");\n\t            } else {\n\t                if (bucketEls.length && keyEls.length) {\n\t                    if (bucketEls[0].textContent !== bucket) {\n\t                        isError = true;\n\t                        options.log(qq.format(\"Wrong bucket in response to Complete Multipart Upload request for {}.\", id), \"error\");\n\t                    }\n\t                } else {\n\t                    isError = true;\n\t                    options.log(qq.format(\"Missing bucket and/or key in response to Complete Multipart Upload request for {}.\", id), \"error\");\n\t                }\n\t            }\n\t            if (isError) {\n\t                promise.failure(\"Problem combining the file parts!\", xhr);\n\t            } else {\n\t                promise.success({}, xhr);\n\t            }\n\t        }\n\t        function getCompleteRequestBody(etagEntries) {\n\t            var doc = document.implementation.createDocument(null, \"CompleteMultipartUpload\", null);\n\t            etagEntries.sort(function(a, b) {\n\t                return a.part - b.part;\n\t            });\n\t            qq.each(etagEntries, function(idx, etagEntry) {\n\t                var part = etagEntry.part, etag = etagEntry.etag, partEl = doc.createElement(\"Part\"), partNumEl = doc.createElement(\"PartNumber\"), partNumTextEl = doc.createTextNode(part), etagTextEl = doc.createTextNode(etag), etagEl = doc.createElement(\"ETag\");\n\t                etagEl.appendChild(etagTextEl);\n\t                partNumEl.appendChild(partNumTextEl);\n\t                partEl.appendChild(partNumEl);\n\t                partEl.appendChild(etagEl);\n\t                qq(doc).children()[0].appendChild(partEl);\n\t            });\n\t            return new XMLSerializer().serializeToString(doc);\n\t        }\n\t        requester = qq.extend(this, new qq.AjaxRequester({\n\t            method: options.method,\n\t            contentType: \"application/xml; charset=UTF-8\",\n\t            endpointStore: options.endpointStore,\n\t            maxConnections: options.maxConnections,\n\t            allowXRequestedWithAndCacheControl: false,\n\t            log: options.log,\n\t            onComplete: handleCompleteRequestComplete,\n\t            successfulResponseCodes: {\n\t                POST: [ 200 ]\n\t            }\n\t        }));\n\t        qq.extend(this, {\n\t            send: function(id, uploadId, etagEntries) {\n\t                var promise = new qq.Promise(), body = getCompleteRequestBody(etagEntries);\n\t                getHeaders(id, uploadId, body).then(function(headers, endOfUrl) {\n\t                    options.log(\"Submitting S3 complete multipart upload request for \" + id);\n\t                    pendingCompleteRequests[id] = promise;\n\t                    delete headers[\"Content-Type\"];\n\t                    requester.initTransport(id).withPath(endOfUrl).withHeaders(headers).withPayload(body).send();\n\t                }, promise.failure);\n\t                return promise;\n\t            }\n\t        });\n\t    };\n\t    qq.s3.AbortMultipartAjaxRequester = function(o) {\n\t        \"use strict\";\n\t        var requester, options = {\n\t            method: \"DELETE\",\n\t            endpointStore: null,\n\t            signatureSpec: null,\n\t            maxConnections: 3,\n\t            getBucket: function(id) {},\n\t            getHost: function(id) {},\n\t            getKey: function(id) {},\n\t            log: function(str, level) {}\n\t        }, getSignatureAjaxRequester;\n\t        qq.extend(options, o);\n\t        getSignatureAjaxRequester = new qq.s3.RequestSigner({\n\t            endpointStore: options.endpointStore,\n\t            signatureSpec: options.signatureSpec,\n\t            cors: options.cors,\n\t            log: options.log\n\t        });\n\t        function getHeaders(id, uploadId) {\n\t            var headers = {}, promise = new qq.Promise(), bucket = options.getBucket(id), host = options.getHost(id), signatureConstructor = getSignatureAjaxRequester.constructStringToSign(getSignatureAjaxRequester.REQUEST_TYPE.MULTIPART_ABORT, bucket, host, options.getKey(id)).withUploadId(uploadId);\n\t            getSignatureAjaxRequester.getSignature(id, {\n\t                signatureConstructor: signatureConstructor\n\t            }).then(promise.success, promise.failure);\n\t            return promise;\n\t        }\n\t        function handleAbortRequestComplete(id, xhr, isError) {\n\t            var domParser = new DOMParser(), responseDoc = domParser.parseFromString(xhr.responseText, \"application/xml\"), errorEls = responseDoc.getElementsByTagName(\"Error\"), awsErrorMsg;\n\t            options.log(qq.format(\"Abort response status {}, body = {}\", xhr.status, xhr.responseText));\n\t            if (isError) {\n\t                options.log(qq.format(\"Abort Multipart Upload request for {} failed with status {}.\", id, xhr.status), \"error\");\n\t            } else {\n\t                if (errorEls.length) {\n\t                    isError = true;\n\t                    awsErrorMsg = responseDoc.getElementsByTagName(\"Message\")[0].textContent;\n\t                    options.log(qq.format(\"Failed to Abort Multipart Upload request for {}.  Error: {}\", id, awsErrorMsg), \"error\");\n\t                } else {\n\t                    options.log(qq.format(\"Abort MPU request succeeded for file ID {}.\", id));\n\t                }\n\t            }\n\t        }\n\t        requester = qq.extend(this, new qq.AjaxRequester({\n\t            validMethods: [ \"DELETE\" ],\n\t            method: options.method,\n\t            contentType: null,\n\t            endpointStore: options.endpointStore,\n\t            maxConnections: options.maxConnections,\n\t            allowXRequestedWithAndCacheControl: false,\n\t            log: options.log,\n\t            onComplete: handleAbortRequestComplete,\n\t            successfulResponseCodes: {\n\t                DELETE: [ 204 ]\n\t            }\n\t        }));\n\t        qq.extend(this, {\n\t            send: function(id, uploadId) {\n\t                getHeaders(id, uploadId).then(function(headers, endOfUrl) {\n\t                    options.log(\"Submitting S3 Abort multipart upload request for \" + id);\n\t                    requester.initTransport(id).withPath(endOfUrl).withHeaders(headers).send();\n\t                });\n\t            }\n\t        });\n\t    };\n\t    qq.s3.XhrUploadHandler = function(spec, proxy) {\n\t        \"use strict\";\n\t        var getName = proxy.getName, log = proxy.log, clockDrift = spec.clockDrift, expectedStatus = 200, onGetBucket = spec.getBucket, onGetHost = spec.getHost, onGetKeyName = spec.getKeyName, filenameParam = spec.filenameParam, paramsStore = spec.paramsStore, endpointStore = spec.endpointStore, aclStore = spec.aclStore, reducedRedundancy = spec.objectProperties.reducedRedundancy, region = spec.objectProperties.region, serverSideEncryption = spec.objectProperties.serverSideEncryption, validation = spec.validation, signature = qq.extend({\n\t            region: region,\n\t            drift: clockDrift\n\t        }, spec.signature), handler = this, credentialsProvider = spec.signature.credentialsProvider, chunked = {\n\t            combine: function(id) {\n\t                var uploadId = handler._getPersistableData(id).uploadId, etagMap = handler._getPersistableData(id).etags, result = new qq.Promise();\n\t                requesters.completeMultipart.send(id, uploadId, etagMap).then(result.success, function failure(reason, xhr) {\n\t                    result.failure(upload.done(id, xhr).response, xhr);\n\t                });\n\t                return result;\n\t            },\n\t            done: function(id, xhr, chunkIdx) {\n\t                var response = upload.response.parse(id, xhr), etag;\n\t                if (response.success) {\n\t                    etag = xhr.getResponseHeader(\"ETag\");\n\t                    if (!handler._getPersistableData(id).etags) {\n\t                        handler._getPersistableData(id).etags = [];\n\t                    }\n\t                    handler._getPersistableData(id).etags.push({\n\t                        part: chunkIdx + 1,\n\t                        etag: etag\n\t                    });\n\t                }\n\t            },\n\t            initHeaders: function(id, chunkIdx, blob) {\n\t                var headers = {}, bucket = upload.bucket.getName(id), host = upload.host.getName(id), key = upload.key.urlSafe(id), promise = new qq.Promise(), signatureConstructor = requesters.restSignature.constructStringToSign(requesters.restSignature.REQUEST_TYPE.MULTIPART_UPLOAD, bucket, host, key).withPartNum(chunkIdx + 1).withContent(blob).withUploadId(handler._getPersistableData(id).uploadId);\n\t                requesters.restSignature.getSignature(id + \".\" + chunkIdx, {\n\t                    signatureConstructor: signatureConstructor\n\t                }).then(promise.success, promise.failure);\n\t                return promise;\n\t            },\n\t            put: function(id, chunkIdx) {\n\t                var xhr = handler._createXhr(id, chunkIdx), chunkData = handler._getChunkData(id, chunkIdx), domain = spec.endpointStore.get(id), promise = new qq.Promise();\n\t                chunked.initHeaders(id, chunkIdx, chunkData.blob).then(function(headers, endOfUrl) {\n\t                    if (xhr._cancelled) {\n\t                        log(qq.format(\"Upload of item {}.{} cancelled. Upload will not start after successful signature request.\", id, chunkIdx));\n\t                        promise.failure({\n\t                            error: \"Chunk upload cancelled\"\n\t                        });\n\t                    } else {\n\t                        var url = domain + \"/\" + endOfUrl;\n\t                        handler._registerProgressHandler(id, chunkIdx, chunkData.size);\n\t                        upload.track(id, xhr, chunkIdx).then(promise.success, promise.failure);\n\t                        xhr.open(\"PUT\", url, true);\n\t                        qq.each(headers, function(name, val) {\n\t                            xhr.setRequestHeader(name, val);\n\t                        });\n\t                        xhr.send(chunkData.blob);\n\t                    }\n\t                }, function() {\n\t                    promise.failure({\n\t                        error: \"Problem signing the chunk!\"\n\t                    }, xhr);\n\t                });\n\t                return promise;\n\t            },\n\t            send: function(id, chunkIdx) {\n\t                var promise = new qq.Promise();\n\t                chunked.setup(id).then(function() {\n\t                    chunked.put(id, chunkIdx).then(promise.success, promise.failure);\n\t                }, function(errorMessage, xhr) {\n\t                    promise.failure({\n\t                        error: errorMessage\n\t                    }, xhr);\n\t                });\n\t                return promise;\n\t            },\n\t            setup: function(id) {\n\t                var promise = new qq.Promise(), uploadId = handler._getPersistableData(id).uploadId, uploadIdPromise = new qq.Promise();\n\t                if (!uploadId) {\n\t                    handler._getPersistableData(id).uploadId = uploadIdPromise;\n\t                    requesters.initiateMultipart.send(id).then(function(uploadId) {\n\t                        handler._getPersistableData(id).uploadId = uploadId;\n\t                        uploadIdPromise.success(uploadId);\n\t                        promise.success(uploadId);\n\t                    }, function(errorMsg, xhr) {\n\t                        handler._getPersistableData(id).uploadId = null;\n\t                        promise.failure(errorMsg, xhr);\n\t                        uploadIdPromise.failure(errorMsg, xhr);\n\t                    });\n\t                } else if (uploadId instanceof qq.Promise) {\n\t                    uploadId.then(function(uploadId) {\n\t                        promise.success(uploadId);\n\t                    });\n\t                } else {\n\t                    promise.success(uploadId);\n\t                }\n\t                return promise;\n\t            }\n\t        }, requesters = {\n\t            abortMultipart: new qq.s3.AbortMultipartAjaxRequester({\n\t                endpointStore: endpointStore,\n\t                signatureSpec: signature,\n\t                cors: spec.cors,\n\t                log: log,\n\t                getBucket: function(id) {\n\t                    return upload.bucket.getName(id);\n\t                },\n\t                getHost: function(id) {\n\t                    return upload.host.getName(id);\n\t                },\n\t                getKey: function(id) {\n\t                    return upload.key.urlSafe(id);\n\t                }\n\t            }),\n\t            completeMultipart: new qq.s3.CompleteMultipartAjaxRequester({\n\t                endpointStore: endpointStore,\n\t                signatureSpec: signature,\n\t                cors: spec.cors,\n\t                log: log,\n\t                getBucket: function(id) {\n\t                    return upload.bucket.getName(id);\n\t                },\n\t                getHost: function(id) {\n\t                    return upload.host.getName(id);\n\t                },\n\t                getKey: function(id) {\n\t                    return upload.key.urlSafe(id);\n\t                }\n\t            }),\n\t            initiateMultipart: new qq.s3.InitiateMultipartAjaxRequester({\n\t                filenameParam: filenameParam,\n\t                endpointStore: endpointStore,\n\t                paramsStore: paramsStore,\n\t                signatureSpec: signature,\n\t                aclStore: aclStore,\n\t                reducedRedundancy: reducedRedundancy,\n\t                serverSideEncryption: serverSideEncryption,\n\t                cors: spec.cors,\n\t                log: log,\n\t                getContentType: function(id) {\n\t                    return handler._getMimeType(id);\n\t                },\n\t                getBucket: function(id) {\n\t                    return upload.bucket.getName(id);\n\t                },\n\t                getHost: function(id) {\n\t                    return upload.host.getName(id);\n\t                },\n\t                getKey: function(id) {\n\t                    return upload.key.urlSafe(id);\n\t                },\n\t                getName: function(id) {\n\t                    return getName(id);\n\t                }\n\t            }),\n\t            policySignature: new qq.s3.RequestSigner({\n\t                expectingPolicy: true,\n\t                signatureSpec: signature,\n\t                cors: spec.cors,\n\t                log: log\n\t            }),\n\t            restSignature: new qq.s3.RequestSigner({\n\t                endpointStore: endpointStore,\n\t                signatureSpec: signature,\n\t                cors: spec.cors,\n\t                log: log\n\t            })\n\t        }, simple = {\n\t            initParams: function(id) {\n\t                var customParams = paramsStore.get(id);\n\t                customParams[filenameParam] = getName(id);\n\t                return qq.s3.util.generateAwsParams({\n\t                    endpoint: endpointStore.get(id),\n\t                    clockDrift: clockDrift,\n\t                    params: customParams,\n\t                    type: handler._getMimeType(id),\n\t                    bucket: upload.bucket.getName(id),\n\t                    key: handler.getThirdPartyFileId(id),\n\t                    accessKey: credentialsProvider.get().accessKey,\n\t                    sessionToken: credentialsProvider.get().sessionToken,\n\t                    acl: aclStore.get(id),\n\t                    expectedStatus: expectedStatus,\n\t                    minFileSize: validation.minSizeLimit,\n\t                    maxFileSize: validation.maxSizeLimit,\n\t                    reducedRedundancy: reducedRedundancy,\n\t                    region: region,\n\t                    serverSideEncryption: serverSideEncryption,\n\t                    signatureVersion: signature.version,\n\t                    log: log\n\t                }, qq.bind(requesters.policySignature.getSignature, this, id));\n\t            },\n\t            send: function(id) {\n\t                var promise = new qq.Promise(), xhr = handler._createXhr(id), fileOrBlob = handler.getFile(id);\n\t                handler._registerProgressHandler(id);\n\t                upload.track(id, xhr).then(promise.success, promise.failure);\n\t                simple.setup(id, xhr, fileOrBlob).then(function(toSend) {\n\t                    log(\"Sending upload request for \" + id);\n\t                    xhr.send(toSend);\n\t                }, promise.failure);\n\t                return promise;\n\t            },\n\t            setup: function(id, xhr, fileOrBlob) {\n\t                var formData = new FormData(), endpoint = endpointStore.get(id), url = endpoint, promise = new qq.Promise();\n\t                simple.initParams(id).then(function(awsParams) {\n\t                    xhr.open(\"POST\", url, true);\n\t                    qq.obj2FormData(awsParams, formData);\n\t                    formData.append(\"file\", fileOrBlob);\n\t                    promise.success(formData);\n\t                }, function(errorMessage) {\n\t                    promise.failure({\n\t                        error: errorMessage\n\t                    });\n\t                });\n\t                return promise;\n\t            }\n\t        }, upload = {\n\t            bucket: {\n\t                promise: function(id) {\n\t                    var promise = new qq.Promise(), cachedBucket = handler._getFileState(id).bucket;\n\t                    if (cachedBucket) {\n\t                        promise.success(cachedBucket);\n\t                    } else {\n\t                        onGetBucket(id).then(function(bucket) {\n\t                            handler._getFileState(id).bucket = bucket;\n\t                            promise.success(bucket);\n\t                        }, promise.failure);\n\t                    }\n\t                    return promise;\n\t                },\n\t                getName: function(id) {\n\t                    return handler._getFileState(id).bucket;\n\t                }\n\t            },\n\t            host: {\n\t                promise: function(id) {\n\t                    var promise = new qq.Promise(), cachedHost = handler._getFileState(id).host;\n\t                    if (cachedHost) {\n\t                        promise.success(cachedHost);\n\t                    } else {\n\t                        onGetHost(id).then(function(host) {\n\t                            handler._getFileState(id).host = host;\n\t                            promise.success(host);\n\t                        }, promise.failure);\n\t                    }\n\t                    return promise;\n\t                },\n\t                getName: function(id) {\n\t                    return handler._getFileState(id).host;\n\t                }\n\t            },\n\t            done: function(id, xhr) {\n\t                var response = upload.response.parse(id, xhr), isError = response.success !== true;\n\t                if (isError && upload.response.shouldReset(response.code)) {\n\t                    log(\"This is an unrecoverable error, we must restart the upload entirely on the next retry attempt.\", \"error\");\n\t                    response.reset = true;\n\t                }\n\t                return {\n\t                    success: !isError,\n\t                    response: response\n\t                };\n\t            },\n\t            key: {\n\t                promise: function(id) {\n\t                    var promise = new qq.Promise(), key = handler.getThirdPartyFileId(id);\n\t                    if (key == null) {\n\t                        handler._setThirdPartyFileId(id, promise);\n\t                        onGetKeyName(id, getName(id)).then(function(keyName) {\n\t                            handler._setThirdPartyFileId(id, keyName);\n\t                            promise.success(keyName);\n\t                        }, function(errorReason) {\n\t                            handler._setThirdPartyFileId(id, null);\n\t                            promise.failure(errorReason);\n\t                        });\n\t                    } else if (qq.isGenericPromise(key)) {\n\t                        key.then(promise.success, promise.failure);\n\t                    } else {\n\t                        promise.success(key);\n\t                    }\n\t                    return promise;\n\t                },\n\t                urlSafe: function(id) {\n\t                    var encodedKey = handler.getThirdPartyFileId(id);\n\t                    return qq.s3.util.uriEscapePath(encodedKey);\n\t                }\n\t            },\n\t            response: {\n\t                parse: function(id, xhr) {\n\t                    var response = {}, parsedErrorProps;\n\t                    try {\n\t                        log(qq.format(\"Received response status {} with body: {}\", xhr.status, xhr.responseText));\n\t                        if (xhr.status === expectedStatus) {\n\t                            response.success = true;\n\t                        } else {\n\t                            parsedErrorProps = upload.response.parseError(xhr.responseText);\n\t                            if (parsedErrorProps) {\n\t                                response.error = parsedErrorProps.message;\n\t                                response.code = parsedErrorProps.code;\n\t                            }\n\t                        }\n\t                    } catch (error) {\n\t                        log(\"Error when attempting to parse xhr response text (\" + error.message + \")\", \"error\");\n\t                    }\n\t                    return response;\n\t                },\n\t                parseError: function(awsResponseXml) {\n\t                    var parser = new DOMParser(), parsedDoc = parser.parseFromString(awsResponseXml, \"application/xml\"), errorEls = parsedDoc.getElementsByTagName(\"Error\"), errorDetails = {}, codeEls, messageEls;\n\t                    if (errorEls.length) {\n\t                        codeEls = parsedDoc.getElementsByTagName(\"Code\");\n\t                        messageEls = parsedDoc.getElementsByTagName(\"Message\");\n\t                        if (messageEls.length) {\n\t                            errorDetails.message = messageEls[0].textContent;\n\t                        }\n\t                        if (codeEls.length) {\n\t                            errorDetails.code = codeEls[0].textContent;\n\t                        }\n\t                        return errorDetails;\n\t                    }\n\t                },\n\t                shouldReset: function(errorCode) {\n\t                    return errorCode === \"EntityTooSmall\" || errorCode === \"InvalidPart\" || errorCode === \"InvalidPartOrder\" || errorCode === \"NoSuchUpload\";\n\t                }\n\t            },\n\t            start: function(id, optChunkIdx) {\n\t                var promise = new qq.Promise();\n\t                upload.key.promise(id).then(function() {\n\t                    upload.bucket.promise(id).then(function() {\n\t                        upload.host.promise(id).then(function() {\n\t                            if (optChunkIdx == null) {\n\t                                simple.send(id).then(promise.success, promise.failure);\n\t                            } else {\n\t                                chunked.send(id, optChunkIdx).then(promise.success, promise.failure);\n\t                            }\n\t                        });\n\t                    });\n\t                }, function(errorReason) {\n\t                    promise.failure({\n\t                        error: errorReason\n\t                    });\n\t                });\n\t                return promise;\n\t            },\n\t            track: function(id, xhr, optChunkIdx) {\n\t                var promise = new qq.Promise();\n\t                xhr.onreadystatechange = function() {\n\t                    if (xhr.readyState === 4) {\n\t                        var result;\n\t                        if (optChunkIdx == null) {\n\t                            result = upload.done(id, xhr);\n\t                            promise[result.success ? \"success\" : \"failure\"](result.response, xhr);\n\t                        } else {\n\t                            chunked.done(id, xhr, optChunkIdx);\n\t                            result = upload.done(id, xhr);\n\t                            promise[result.success ? \"success\" : \"failure\"](result.response, xhr);\n\t                        }\n\t                    }\n\t                };\n\t                return promise;\n\t            }\n\t        };\n\t        qq.extend(this, {\n\t            uploadChunk: upload.start,\n\t            uploadFile: upload.start\n\t        });\n\t        qq.extend(this, new qq.XhrUploadHandler({\n\t            options: qq.extend({\n\t                namespace: \"s3\"\n\t            }, spec),\n\t            proxy: qq.extend({\n\t                getEndpoint: spec.endpointStore.get\n\t            }, proxy)\n\t        }));\n\t        qq.override(this, function(super_) {\n\t            return {\n\t                expunge: function(id) {\n\t                    var uploadId = handler._getPersistableData(id) && handler._getPersistableData(id).uploadId, existedInLocalStorage = handler._maybeDeletePersistedChunkData(id);\n\t                    if (uploadId !== undefined && existedInLocalStorage) {\n\t                        requesters.abortMultipart.send(id, uploadId);\n\t                    }\n\t                    super_.expunge(id);\n\t                },\n\t                finalizeChunks: function(id) {\n\t                    return chunked.combine(id);\n\t                },\n\t                _getLocalStorageId: function(id) {\n\t                    var baseStorageId = super_._getLocalStorageId(id), bucketName = upload.bucket.getName(id);\n\t                    return baseStorageId + \"-\" + bucketName;\n\t                }\n\t            };\n\t        });\n\t    };\n\t    qq.s3.FormUploadHandler = function(options, proxy) {\n\t        \"use strict\";\n\t        var handler = this, clockDrift = options.clockDrift, onUuidChanged = proxy.onUuidChanged, getName = proxy.getName, getUuid = proxy.getUuid, log = proxy.log, onGetBucket = options.getBucket, onGetKeyName = options.getKeyName, filenameParam = options.filenameParam, paramsStore = options.paramsStore, endpointStore = options.endpointStore, aclStore = options.aclStore, reducedRedundancy = options.objectProperties.reducedRedundancy, region = options.objectProperties.region, serverSideEncryption = options.objectProperties.serverSideEncryption, validation = options.validation, signature = options.signature, successRedirectUrl = options.iframeSupport.localBlankPagePath, credentialsProvider = options.signature.credentialsProvider, getSignatureAjaxRequester = new qq.s3.RequestSigner({\n\t            signatureSpec: signature,\n\t            cors: options.cors,\n\t            log: log\n\t        });\n\t        if (successRedirectUrl === undefined) {\n\t            throw new Error(\"successRedirectEndpoint MUST be defined if you intend to use browsers that do not support the File API!\");\n\t        }\n\t        function isValidResponse(id, iframe) {\n\t            var response, endpoint = options.endpointStore.get(id), bucket = handler._getFileState(id).bucket, doc, innerHtml, responseData;\n\t            try {\n\t                doc = iframe.contentDocument || iframe.contentWindow.document;\n\t                innerHtml = doc.body.innerHTML;\n\t                responseData = qq.s3.util.parseIframeResponse(iframe);\n\t                if (responseData.bucket === bucket && responseData.key === qq.s3.util.encodeQueryStringParam(handler.getThirdPartyFileId(id))) {\n\t                    return true;\n\t                }\n\t                log(\"Response from AWS included an unexpected bucket or key name.\", \"error\");\n\t            } catch (error) {\n\t                log(\"Error when attempting to parse form upload response (\" + error.message + \")\", \"error\");\n\t            }\n\t            return false;\n\t        }\n\t        function generateAwsParams(id) {\n\t            var customParams = paramsStore.get(id);\n\t            customParams[filenameParam] = getName(id);\n\t            return qq.s3.util.generateAwsParams({\n\t                endpoint: endpointStore.get(id),\n\t                clockDrift: clockDrift,\n\t                params: customParams,\n\t                bucket: handler._getFileState(id).bucket,\n\t                key: handler.getThirdPartyFileId(id),\n\t                accessKey: credentialsProvider.get().accessKey,\n\t                sessionToken: credentialsProvider.get().sessionToken,\n\t                acl: aclStore.get(id),\n\t                minFileSize: validation.minSizeLimit,\n\t                maxFileSize: validation.maxSizeLimit,\n\t                successRedirectUrl: successRedirectUrl,\n\t                reducedRedundancy: reducedRedundancy,\n\t                region: region,\n\t                serverSideEncryption: serverSideEncryption,\n\t                signatureVersion: signature.version,\n\t                log: log\n\t            }, qq.bind(getSignatureAjaxRequester.getSignature, this, id));\n\t        }\n\t        function createForm(id, iframe) {\n\t            var promise = new qq.Promise(), method = \"POST\", endpoint = options.endpointStore.get(id), fileName = getName(id);\n\t            generateAwsParams(id).then(function(params) {\n\t                var form = handler._initFormForUpload({\n\t                    method: method,\n\t                    endpoint: endpoint,\n\t                    params: params,\n\t                    paramsInBody: true,\n\t                    targetName: iframe.name\n\t                });\n\t                promise.success(form);\n\t            }, function(errorMessage) {\n\t                promise.failure(errorMessage);\n\t                handleFinishedUpload(id, iframe, fileName, {\n\t                    error: errorMessage\n\t                });\n\t            });\n\t            return promise;\n\t        }\n\t        function handleUpload(id) {\n\t            var iframe = handler._createIframe(id), input = handler.getInput(id), promise = new qq.Promise();\n\t            createForm(id, iframe).then(function(form) {\n\t                form.appendChild(input);\n\t                handler._attachLoadEvent(iframe, function(response) {\n\t                    log(\"iframe loaded\");\n\t                    if (response) {\n\t                        if (response.success === false) {\n\t                            log(\"Amazon likely rejected the upload request\", \"error\");\n\t                            promise.failure(response);\n\t                        }\n\t                    } else {\n\t                        response = {};\n\t                        response.success = isValidResponse(id, iframe);\n\t                        if (response.success === false) {\n\t                            log(\"A success response was received by Amazon, but it was invalid in some way.\", \"error\");\n\t                            promise.failure(response);\n\t                        } else {\n\t                            qq.extend(response, qq.s3.util.parseIframeResponse(iframe));\n\t                            promise.success(response);\n\t                        }\n\t                    }\n\t                    handleFinishedUpload(id, iframe);\n\t                });\n\t                log(\"Sending upload request for \" + id);\n\t                form.submit();\n\t                qq(form).remove();\n\t            }, promise.failure);\n\t            return promise;\n\t        }\n\t        function handleFinishedUpload(id, iframe) {\n\t            handler._detachLoadEvent(id);\n\t            iframe && qq(iframe).remove();\n\t        }\n\t        qq.extend(this, new qq.FormUploadHandler({\n\t            options: {\n\t                isCors: false,\n\t                inputName: \"file\"\n\t            },\n\t            proxy: {\n\t                onCancel: options.onCancel,\n\t                onUuidChanged: onUuidChanged,\n\t                getName: getName,\n\t                getUuid: getUuid,\n\t                log: log\n\t            }\n\t        }));\n\t        qq.extend(this, {\n\t            uploadFile: function(id) {\n\t                var name = getName(id), promise = new qq.Promise();\n\t                if (handler.getThirdPartyFileId(id)) {\n\t                    if (handler._getFileState(id).bucket) {\n\t                        handleUpload(id).then(promise.success, promise.failure);\n\t                    } else {\n\t                        onGetBucket(id).then(function(bucket) {\n\t                            handler._getFileState(id).bucket = bucket;\n\t                            handleUpload(id).then(promise.success, promise.failure);\n\t                        });\n\t                    }\n\t                } else {\n\t                    onGetKeyName(id, name).then(function(key) {\n\t                        onGetBucket(id).then(function(bucket) {\n\t                            handler._getFileState(id).bucket = bucket;\n\t                            handler._setThirdPartyFileId(id, key);\n\t                            handleUpload(id).then(promise.success, promise.failure);\n\t                        }, function(errorReason) {\n\t                            promise.failure({\n\t                                error: errorReason\n\t                            });\n\t                        });\n\t                    }, function(errorReason) {\n\t                        promise.failure({\n\t                            error: errorReason\n\t                        });\n\t                    });\n\t                }\n\t                return promise;\n\t            }\n\t        });\n\t    };\n\t    (function() {\n\t        \"use strict\";\n\t        qq.s3.FineUploader = function(o) {\n\t            var options = {\n\t                failedUploadTextDisplay: {\n\t                    mode: \"custom\"\n\t                }\n\t            };\n\t            qq.extend(options, o, true);\n\t            qq.FineUploader.call(this, options, \"s3\");\n\t            if (!qq.supportedFeatures.ajaxUploading && options.iframeSupport.localBlankPagePath === undefined) {\n\t                this._options.element.innerHTML = \"<div>You MUST set the <code>localBlankPagePath</code> property \" + \"of the <code>iframeSupport</code> option since this browser does not support the File API!</div>\";\n\t            }\n\t        };\n\t        qq.extend(qq.s3.FineUploader.prototype, qq.s3.FineUploaderBasic.prototype);\n\t        qq.extend(qq.s3.FineUploader.prototype, qq.uiPublicApi);\n\t        qq.extend(qq.s3.FineUploader.prototype, qq.uiPrivateApi);\n\t    })();\n\t    qq.azure = qq.azure || {};\n\t    qq.azure.util = qq.azure.util || function() {\n\t        \"use strict\";\n\t        return {\n\t            AZURE_PARAM_PREFIX: \"x-ms-meta-\",\n\t            _paramNameMatchesAzureParameter: function(name) {\n\t                switch (name) {\n\t                  case \"Cache-Control\":\n\t                  case \"Content-Disposition\":\n\t                  case \"Content-Encoding\":\n\t                  case \"Content-MD5\":\n\t                  case \"x-ms-blob-content-encoding\":\n\t                  case \"x-ms-blob-content-disposition\":\n\t                  case \"x-ms-blob-content-md5\":\n\t                  case \"x-ms-blob-cache-control\":\n\t                    return true;\n\t\n\t                  default:\n\t                    return false;\n\t                }\n\t            },\n\t            _getPrefixedParamName: function(name) {\n\t                if (qq.azure.util._paramNameMatchesAzureParameter(name)) {\n\t                    return name;\n\t                } else {\n\t                    return qq.azure.util.AZURE_PARAM_PREFIX + name;\n\t                }\n\t            },\n\t            getParamsAsHeaders: function(params) {\n\t                var headers = {};\n\t                qq.each(params, function(name, val) {\n\t                    var headerName = qq.azure.util._getPrefixedParamName(name), value = null;\n\t                    if (qq.isFunction(val)) {\n\t                        value = String(val());\n\t                    } else if (qq.isObject(val)) {\n\t                        qq.extend(headers, qq.azure.util.getParamsAsHeaders(val));\n\t                    } else {\n\t                        value = String(val);\n\t                    }\n\t                    if (value !== null) {\n\t                        if (qq.azure.util._paramNameMatchesAzureParameter(name)) {\n\t                            headers[headerName] = value;\n\t                        } else {\n\t                            headers[headerName] = encodeURIComponent(value);\n\t                        }\n\t                    }\n\t                });\n\t                return headers;\n\t            },\n\t            parseAzureError: function(responseText, log) {\n\t                var domParser = new DOMParser(), responseDoc = domParser.parseFromString(responseText, \"application/xml\"), errorTag = responseDoc.getElementsByTagName(\"Error\")[0], errorDetails = {}, codeTag, messageTag;\n\t                log(\"Received error response: \" + responseText, \"error\");\n\t                if (errorTag) {\n\t                    messageTag = errorTag.getElementsByTagName(\"Message\")[0];\n\t                    if (messageTag) {\n\t                        errorDetails.message = messageTag.textContent;\n\t                    }\n\t                    codeTag = errorTag.getElementsByTagName(\"Code\")[0];\n\t                    if (codeTag) {\n\t                        errorDetails.code = codeTag.textContent;\n\t                    }\n\t                    log(\"Parsed Azure error: \" + JSON.stringify(errorDetails), \"error\");\n\t                    return errorDetails;\n\t                }\n\t            }\n\t        };\n\t    }();\n\t    (function() {\n\t        \"use strict\";\n\t        qq.nonTraditionalBasePublicApi = {\n\t            setUploadSuccessParams: function(params, id) {\n\t                this._uploadSuccessParamsStore.set(params, id);\n\t            },\n\t            setUploadSuccessEndpoint: function(endpoint, id) {\n\t                this._uploadSuccessEndpointStore.set(endpoint, id);\n\t            }\n\t        };\n\t        qq.nonTraditionalBasePrivateApi = {\n\t            _onComplete: function(id, name, result, xhr) {\n\t                var success = result.success ? true : false, self = this, onCompleteArgs = arguments, successEndpoint = this._uploadSuccessEndpointStore.get(id), successCustomHeaders = this._options.uploadSuccess.customHeaders, successMethod = this._options.uploadSuccess.method, cors = this._options.cors, promise = new qq.Promise(), uploadSuccessParams = this._uploadSuccessParamsStore.get(id), fileParams = this._paramsStore.get(id), onSuccessFromServer = function(successRequestResult) {\n\t                    delete self._failedSuccessRequestCallbacks[id];\n\t                    qq.extend(result, successRequestResult);\n\t                    qq.FineUploaderBasic.prototype._onComplete.apply(self, onCompleteArgs);\n\t                    promise.success(successRequestResult);\n\t                }, onFailureFromServer = function(successRequestResult) {\n\t                    var callback = submitSuccessRequest;\n\t                    qq.extend(result, successRequestResult);\n\t                    if (result && result.reset) {\n\t                        callback = null;\n\t                    }\n\t                    if (!callback) {\n\t                        delete self._failedSuccessRequestCallbacks[id];\n\t                    } else {\n\t                        self._failedSuccessRequestCallbacks[id] = callback;\n\t                    }\n\t                    if (!self._onAutoRetry(id, name, result, xhr, callback)) {\n\t                        qq.FineUploaderBasic.prototype._onComplete.apply(self, onCompleteArgs);\n\t                        promise.failure(successRequestResult);\n\t                    }\n\t                }, submitSuccessRequest, successAjaxRequester;\n\t                if (success && successEndpoint) {\n\t                    successAjaxRequester = new qq.UploadSuccessAjaxRequester({\n\t                        endpoint: successEndpoint,\n\t                        method: successMethod,\n\t                        customHeaders: successCustomHeaders,\n\t                        cors: cors,\n\t                        log: qq.bind(this.log, this)\n\t                    });\n\t                    qq.extend(uploadSuccessParams, self._getEndpointSpecificParams(id, result, xhr), true);\n\t                    fileParams && qq.extend(uploadSuccessParams, fileParams, true);\n\t                    submitSuccessRequest = qq.bind(function() {\n\t                        successAjaxRequester.sendSuccessRequest(id, uploadSuccessParams).then(onSuccessFromServer, onFailureFromServer);\n\t                    }, self);\n\t                    submitSuccessRequest();\n\t                    return promise;\n\t                }\n\t                return qq.FineUploaderBasic.prototype._onComplete.apply(this, arguments);\n\t            },\n\t            _manualRetry: function(id) {\n\t                var successRequestCallback = this._failedSuccessRequestCallbacks[id];\n\t                return qq.FineUploaderBasic.prototype._manualRetry.call(this, id, successRequestCallback);\n\t            }\n\t        };\n\t    })();\n\t    (function() {\n\t        \"use strict\";\n\t        qq.azure.FineUploaderBasic = function(o) {\n\t            if (!qq.supportedFeatures.ajaxUploading) {\n\t                throw new qq.Error(\"Uploading directly to Azure is not possible in this browser.\");\n\t            }\n\t            var options = {\n\t                signature: {\n\t                    endpoint: null,\n\t                    customHeaders: {}\n\t                },\n\t                blobProperties: {\n\t                    name: \"uuid\"\n\t                },\n\t                uploadSuccess: {\n\t                    endpoint: null,\n\t                    method: \"POST\",\n\t                    params: {},\n\t                    customHeaders: {}\n\t                },\n\t                chunking: {\n\t                    partSize: 4e6,\n\t                    minFileSize: 4000001\n\t                }\n\t            };\n\t            qq.extend(options, o, true);\n\t            qq.FineUploaderBasic.call(this, options);\n\t            this._uploadSuccessParamsStore = this._createStore(this._options.uploadSuccess.params);\n\t            this._uploadSuccessEndpointStore = this._createStore(this._options.uploadSuccess.endpoint);\n\t            this._failedSuccessRequestCallbacks = {};\n\t            this._cannedBlobNames = {};\n\t        };\n\t        qq.extend(qq.azure.FineUploaderBasic.prototype, qq.basePublicApi);\n\t        qq.extend(qq.azure.FineUploaderBasic.prototype, qq.basePrivateApi);\n\t        qq.extend(qq.azure.FineUploaderBasic.prototype, qq.nonTraditionalBasePublicApi);\n\t        qq.extend(qq.azure.FineUploaderBasic.prototype, qq.nonTraditionalBasePrivateApi);\n\t        qq.extend(qq.azure.FineUploaderBasic.prototype, {\n\t            getBlobName: function(id) {\n\t                if (this._cannedBlobNames[id] == null) {\n\t                    return this._handler.getThirdPartyFileId(id);\n\t                }\n\t                return this._cannedBlobNames[id];\n\t            },\n\t            _getEndpointSpecificParams: function(id) {\n\t                return {\n\t                    blob: this.getBlobName(id),\n\t                    uuid: this.getUuid(id),\n\t                    name: this.getName(id),\n\t                    container: this._endpointStore.get(id)\n\t                };\n\t            },\n\t            _createUploadHandler: function() {\n\t                return qq.FineUploaderBasic.prototype._createUploadHandler.call(this, {\n\t                    signature: this._options.signature,\n\t                    onGetBlobName: qq.bind(this._determineBlobName, this),\n\t                    deleteBlob: qq.bind(this._deleteBlob, this, true)\n\t                }, \"azure\");\n\t            },\n\t            _determineBlobName: function(id) {\n\t                var self = this, blobNameOptionValue = this._options.blobProperties.name, uuid = this.getUuid(id), filename = this.getName(id), fileExtension = qq.getExtension(filename), blobNameToUse = uuid;\n\t                if (qq.isString(blobNameOptionValue)) {\n\t                    switch (blobNameOptionValue) {\n\t                      case \"uuid\":\n\t                        if (fileExtension !== undefined) {\n\t                            blobNameToUse += \".\" + fileExtension;\n\t                        }\n\t                        return new qq.Promise().success(blobNameToUse);\n\t\n\t                      case \"filename\":\n\t                        return new qq.Promise().success(filename);\n\t\n\t                      default:\n\t                        return new qq.Promise.failure(\"Invalid blobName option value - \" + blobNameOptionValue);\n\t                    }\n\t                } else {\n\t                    return blobNameOptionValue.call(this, id);\n\t                }\n\t            },\n\t            _addCannedFile: function(sessionData) {\n\t                var id;\n\t                if (sessionData.blobName == null) {\n\t                    throw new qq.Error(\"Did not find blob name property in server session response.  This is required!\");\n\t                } else {\n\t                    id = qq.FineUploaderBasic.prototype._addCannedFile.apply(this, arguments);\n\t                    this._cannedBlobNames[id] = sessionData.blobName;\n\t                }\n\t                return id;\n\t            },\n\t            _deleteBlob: function(relatedToCancel, id) {\n\t                var self = this, deleteBlobSasUri = {}, blobUriStore = {\n\t                    get: function(id) {\n\t                        return self._endpointStore.get(id) + \"/\" + self.getBlobName(id);\n\t                    }\n\t                }, deleteFileEndpointStore = {\n\t                    get: function(id) {\n\t                        return deleteBlobSasUri[id];\n\t                    }\n\t                }, getSasSuccess = function(id, sasUri) {\n\t                    deleteBlobSasUri[id] = sasUri;\n\t                    deleteBlob.send(id);\n\t                }, getSasFailure = function(id, reason, xhr) {\n\t                    if (relatedToCancel) {\n\t                        self.log(\"Will cancel upload, but cannot remove uncommitted parts from Azure due to issue retrieving SAS\", \"error\");\n\t                        qq.FineUploaderBasic.prototype._onCancel.call(self, id, self.getName(id));\n\t                    } else {\n\t                        self._onDeleteComplete(id, xhr, true);\n\t                        self._options.callbacks.onDeleteComplete(id, xhr, true);\n\t                    }\n\t                }, deleteBlob = new qq.azure.DeleteBlob({\n\t                    endpointStore: deleteFileEndpointStore,\n\t                    log: qq.bind(self.log, self),\n\t                    onDelete: function(id) {\n\t                        self._onDelete(id);\n\t                        self._options.callbacks.onDelete(id);\n\t                    },\n\t                    onDeleteComplete: function(id, xhrOrXdr, isError) {\n\t                        delete deleteBlobSasUri[id];\n\t                        if (isError) {\n\t                            if (relatedToCancel) {\n\t                                self.log(\"Will cancel upload, but failed to remove uncommitted parts from Azure.\", \"error\");\n\t                            } else {\n\t                                qq.azure.util.parseAzureError(xhrOrXdr.responseText, qq.bind(self.log, self));\n\t                            }\n\t                        }\n\t                        if (relatedToCancel) {\n\t                            qq.FineUploaderBasic.prototype._onCancel.call(self, id, self.getName(id));\n\t                            self.log(\"Deleted uncommitted blob chunks for \" + id);\n\t                        } else {\n\t                            self._onDeleteComplete(id, xhrOrXdr, isError);\n\t                            self._options.callbacks.onDeleteComplete(id, xhrOrXdr, isError);\n\t                        }\n\t                    }\n\t                }), getSas = new qq.azure.GetSas({\n\t                    cors: this._options.cors,\n\t                    customHeaders: this._options.signature.customHeaders,\n\t                    endpointStore: {\n\t                        get: function() {\n\t                            return self._options.signature.endpoint;\n\t                        }\n\t                    },\n\t                    restRequestVerb: deleteBlob.method,\n\t                    log: qq.bind(self.log, self)\n\t                });\n\t                getSas.request(id, blobUriStore.get(id)).then(qq.bind(getSasSuccess, self, id), qq.bind(getSasFailure, self, id));\n\t            },\n\t            _createDeleteHandler: function() {\n\t                var self = this;\n\t                return {\n\t                    sendDelete: function(id, uuid) {\n\t                        self._deleteBlob(false, id);\n\t                    }\n\t                };\n\t            }\n\t        });\n\t    })();\n\t    qq.azure.XhrUploadHandler = function(spec, proxy) {\n\t        \"use strict\";\n\t        var handler = this, log = proxy.log, cors = spec.cors, endpointStore = spec.endpointStore, paramsStore = spec.paramsStore, signature = spec.signature, filenameParam = spec.filenameParam, minFileSizeForChunking = spec.chunking.minFileSize, deleteBlob = spec.deleteBlob, onGetBlobName = spec.onGetBlobName, getName = proxy.getName, getSize = proxy.getSize, getBlobMetadata = function(id) {\n\t            var params = paramsStore.get(id);\n\t            params[filenameParam] = getName(id);\n\t            return params;\n\t        }, api = {\n\t            putBlob: new qq.azure.PutBlob({\n\t                getBlobMetadata: getBlobMetadata,\n\t                log: log\n\t            }),\n\t            putBlock: new qq.azure.PutBlock({\n\t                log: log\n\t            }),\n\t            putBlockList: new qq.azure.PutBlockList({\n\t                getBlobMetadata: getBlobMetadata,\n\t                log: log\n\t            }),\n\t            getSasForPutBlobOrBlock: new qq.azure.GetSas({\n\t                cors: cors,\n\t                customHeaders: signature.customHeaders,\n\t                endpointStore: {\n\t                    get: function() {\n\t                        return signature.endpoint;\n\t                    }\n\t                },\n\t                log: log,\n\t                restRequestVerb: \"PUT\"\n\t            })\n\t        };\n\t        function combineChunks(id) {\n\t            var promise = new qq.Promise();\n\t            getSignedUrl(id).then(function(sasUri) {\n\t                var mimeType = handler._getMimeType(id), blockIdEntries = handler._getPersistableData(id).blockIdEntries;\n\t                api.putBlockList.send(id, sasUri, blockIdEntries, mimeType, function(xhr) {\n\t                    handler._registerXhr(id, null, xhr, api.putBlockList);\n\t                }).then(function(xhr) {\n\t                    log(\"Success combining chunks for id \" + id);\n\t                    promise.success({}, xhr);\n\t                }, function(xhr) {\n\t                    log(\"Attempt to combine chunks failed for id \" + id, \"error\");\n\t                    handleFailure(xhr, promise);\n\t                });\n\t            }, promise.failure);\n\t            return promise;\n\t        }\n\t        function determineBlobUrl(id) {\n\t            var containerUrl = endpointStore.get(id), promise = new qq.Promise(), getBlobNameSuccess = function(blobName) {\n\t                handler._setThirdPartyFileId(id, blobName);\n\t                promise.success(containerUrl + \"/\" + blobName);\n\t            }, getBlobNameFailure = function(reason) {\n\t                promise.failure(reason);\n\t            };\n\t            onGetBlobName(id).then(getBlobNameSuccess, getBlobNameFailure);\n\t            return promise;\n\t        }\n\t        function getSignedUrl(id, optChunkIdx) {\n\t            var getSasId = optChunkIdx == null ? id : id + \".\" + optChunkIdx, promise = new qq.Promise(), getSasSuccess = function(sasUri) {\n\t                log(\"GET SAS request succeeded.\");\n\t                promise.success(sasUri);\n\t            }, getSasFailure = function(reason, getSasXhr) {\n\t                log(\"GET SAS request failed: \" + reason, \"error\");\n\t                promise.failure({\n\t                    error: \"Problem communicating with local server\"\n\t                }, getSasXhr);\n\t            }, determineBlobUrlSuccess = function(blobUrl) {\n\t                api.getSasForPutBlobOrBlock.request(getSasId, blobUrl).then(getSasSuccess, getSasFailure);\n\t            }, determineBlobUrlFailure = function(reason) {\n\t                log(qq.format(\"Failed to determine blob name for ID {} - {}\", id, reason), \"error\");\n\t                promise.failure({\n\t                    error: reason\n\t                });\n\t            };\n\t            determineBlobUrl(id).then(determineBlobUrlSuccess, determineBlobUrlFailure);\n\t            return promise;\n\t        }\n\t        function handleFailure(xhr, promise) {\n\t            var azureError = qq.azure.util.parseAzureError(xhr.responseText, log), errorMsg = \"Problem sending file to Azure\";\n\t            promise.failure({\n\t                error: errorMsg,\n\t                azureError: azureError && azureError.message,\n\t                reset: xhr.status === 403\n\t            });\n\t        }\n\t        qq.extend(this, {\n\t            uploadChunk: function(id, chunkIdx) {\n\t                var promise = new qq.Promise();\n\t                getSignedUrl(id, chunkIdx).then(function(sasUri) {\n\t                    var xhr = handler._createXhr(id, chunkIdx), chunkData = handler._getChunkData(id, chunkIdx);\n\t                    handler._registerProgressHandler(id, chunkIdx, chunkData.size);\n\t                    handler._registerXhr(id, chunkIdx, xhr, api.putBlock);\n\t                    api.putBlock.upload(id + \".\" + chunkIdx, xhr, sasUri, chunkIdx, chunkData.blob).then(function(blockIdEntry) {\n\t                        if (!handler._getPersistableData(id).blockIdEntries) {\n\t                            handler._getPersistableData(id).blockIdEntries = [];\n\t                        }\n\t                        handler._getPersistableData(id).blockIdEntries.push(blockIdEntry);\n\t                        log(\"Put Block call succeeded for \" + id);\n\t                        promise.success({}, xhr);\n\t                    }, function() {\n\t                        log(qq.format(\"Put Block call failed for ID {} on part {}\", id, chunkIdx), \"error\");\n\t                        handleFailure(xhr, promise);\n\t                    });\n\t                }, promise.failure);\n\t                return promise;\n\t            },\n\t            uploadFile: function(id) {\n\t                var promise = new qq.Promise(), fileOrBlob = handler.getFile(id);\n\t                getSignedUrl(id).then(function(sasUri) {\n\t                    var xhr = handler._createXhr(id);\n\t                    handler._registerProgressHandler(id);\n\t                    api.putBlob.upload(id, xhr, sasUri, fileOrBlob).then(function() {\n\t                        log(\"Put Blob call succeeded for \" + id);\n\t                        promise.success({}, xhr);\n\t                    }, function() {\n\t                        log(\"Put Blob call failed for \" + id, \"error\");\n\t                        handleFailure(xhr, promise);\n\t                    });\n\t                }, promise.failure);\n\t                return promise;\n\t            }\n\t        });\n\t        qq.extend(this, new qq.XhrUploadHandler({\n\t            options: qq.extend({\n\t                namespace: \"azure\"\n\t            }, spec),\n\t            proxy: qq.extend({\n\t                getEndpoint: spec.endpointStore.get\n\t            }, proxy)\n\t        }));\n\t        qq.override(this, function(super_) {\n\t            return {\n\t                expunge: function(id) {\n\t                    var relatedToCancel = handler._wasCanceled(id), chunkingData = handler._getPersistableData(id), blockIdEntries = chunkingData && chunkingData.blockIdEntries || [];\n\t                    if (relatedToCancel && blockIdEntries.length > 0) {\n\t                        deleteBlob(id);\n\t                    }\n\t                    super_.expunge(id);\n\t                },\n\t                finalizeChunks: function(id) {\n\t                    return combineChunks(id);\n\t                },\n\t                _shouldChunkThisFile: function(id) {\n\t                    var maybePossible = super_._shouldChunkThisFile(id);\n\t                    return maybePossible && getSize(id) >= minFileSizeForChunking;\n\t                }\n\t            };\n\t        });\n\t    };\n\t    qq.azure.GetSas = function(o) {\n\t        \"use strict\";\n\t        var requester, options = {\n\t            cors: {\n\t                expected: false,\n\t                sendCredentials: false\n\t            },\n\t            customHeaders: {},\n\t            restRequestVerb: \"PUT\",\n\t            endpointStore: null,\n\t            log: function(str, level) {}\n\t        }, requestPromises = {};\n\t        qq.extend(options, o);\n\t        function sasResponseReceived(id, xhr, isError) {\n\t            var promise = requestPromises[id];\n\t            if (isError) {\n\t                promise.failure(\"Received response code \" + xhr.status, xhr);\n\t            } else {\n\t                if (xhr.responseText.length) {\n\t                    promise.success(xhr.responseText);\n\t                } else {\n\t                    promise.failure(\"Empty response.\", xhr);\n\t                }\n\t            }\n\t            delete requestPromises[id];\n\t        }\n\t        requester = qq.extend(this, new qq.AjaxRequester({\n\t            acceptHeader: \"application/json\",\n\t            validMethods: [ \"GET\" ],\n\t            method: \"GET\",\n\t            successfulResponseCodes: {\n\t                GET: [ 200 ]\n\t            },\n\t            contentType: null,\n\t            customHeaders: options.customHeaders,\n\t            endpointStore: options.endpointStore,\n\t            cors: options.cors,\n\t            log: options.log,\n\t            onComplete: sasResponseReceived\n\t        }));\n\t        qq.extend(this, {\n\t            request: function(id, blobUri) {\n\t                var requestPromise = new qq.Promise(), restVerb = options.restRequestVerb;\n\t                options.log(qq.format(\"Submitting GET SAS request for a {} REST request related to file ID {}.\", restVerb, id));\n\t                requestPromises[id] = requestPromise;\n\t                requester.initTransport(id).withParams({\n\t                    bloburi: blobUri,\n\t                    _method: restVerb\n\t                }).withCacheBuster().send();\n\t                return requestPromise;\n\t            }\n\t        });\n\t    };\n\t    qq.UploadSuccessAjaxRequester = function(o) {\n\t        \"use strict\";\n\t        var requester, pendingRequests = [], options = {\n\t            method: \"POST\",\n\t            endpoint: null,\n\t            maxConnections: 3,\n\t            customHeaders: {},\n\t            paramsStore: {},\n\t            cors: {\n\t                expected: false,\n\t                sendCredentials: false\n\t            },\n\t            log: function(str, level) {}\n\t        };\n\t        qq.extend(options, o);\n\t        function handleSuccessResponse(id, xhrOrXdr, isError) {\n\t            var promise = pendingRequests[id], responseJson = xhrOrXdr.responseText, successIndicator = {\n\t                success: true\n\t            }, failureIndicator = {\n\t                success: false\n\t            }, parsedResponse;\n\t            delete pendingRequests[id];\n\t            options.log(qq.format(\"Received the following response body to an upload success request for id {}: {}\", id, responseJson));\n\t            try {\n\t                parsedResponse = qq.parseJson(responseJson);\n\t                if (isError || parsedResponse && (parsedResponse.error || parsedResponse.success === false)) {\n\t                    options.log(\"Upload success request was rejected by the server.\", \"error\");\n\t                    promise.failure(qq.extend(parsedResponse, failureIndicator));\n\t                } else {\n\t                    options.log(\"Upload success was acknowledged by the server.\");\n\t                    promise.success(qq.extend(parsedResponse, successIndicator));\n\t                }\n\t            } catch (error) {\n\t                if (isError) {\n\t                    options.log(qq.format(\"Your server indicated failure in its upload success request response for id {}!\", id), \"error\");\n\t                    promise.failure(failureIndicator);\n\t                } else {\n\t                    options.log(\"Upload success was acknowledged by the server.\");\n\t                    promise.success(successIndicator);\n\t                }\n\t            }\n\t        }\n\t        requester = qq.extend(this, new qq.AjaxRequester({\n\t            acceptHeader: \"application/json\",\n\t            method: options.method,\n\t            endpointStore: {\n\t                get: function() {\n\t                    return options.endpoint;\n\t                }\n\t            },\n\t            paramsStore: options.paramsStore,\n\t            maxConnections: options.maxConnections,\n\t            customHeaders: options.customHeaders,\n\t            log: options.log,\n\t            onComplete: handleSuccessResponse,\n\t            cors: options.cors\n\t        }));\n\t        qq.extend(this, {\n\t            sendSuccessRequest: function(id, spec) {\n\t                var promise = new qq.Promise();\n\t                options.log(\"Submitting upload success request/notification for \" + id);\n\t                requester.initTransport(id).withParams(spec).send();\n\t                pendingRequests[id] = promise;\n\t                return promise;\n\t            }\n\t        });\n\t    };\n\t    qq.azure.DeleteBlob = function(o) {\n\t        \"use strict\";\n\t        var requester, method = \"DELETE\", options = {\n\t            endpointStore: {},\n\t            onDelete: function(id) {},\n\t            onDeleteComplete: function(id, xhr, isError) {},\n\t            log: function(str, level) {}\n\t        };\n\t        qq.extend(options, o);\n\t        requester = qq.extend(this, new qq.AjaxRequester({\n\t            validMethods: [ method ],\n\t            method: method,\n\t            successfulResponseCodes: function() {\n\t                var codes = {};\n\t                codes[method] = [ 202 ];\n\t                return codes;\n\t            }(),\n\t            contentType: null,\n\t            endpointStore: options.endpointStore,\n\t            allowXRequestedWithAndCacheControl: false,\n\t            cors: {\n\t                expected: true\n\t            },\n\t            log: options.log,\n\t            onSend: options.onDelete,\n\t            onComplete: options.onDeleteComplete\n\t        }));\n\t        qq.extend(this, {\n\t            method: method,\n\t            send: function(id) {\n\t                options.log(\"Submitting Delete Blob request for \" + id);\n\t                return requester.initTransport(id).send();\n\t            }\n\t        });\n\t    };\n\t    qq.azure.PutBlob = function(o) {\n\t        \"use strict\";\n\t        var requester, method = \"PUT\", options = {\n\t            getBlobMetadata: function(id) {},\n\t            log: function(str, level) {}\n\t        }, endpoints = {}, promises = {}, endpointHandler = {\n\t            get: function(id) {\n\t                return endpoints[id];\n\t            }\n\t        };\n\t        qq.extend(options, o);\n\t        requester = qq.extend(this, new qq.AjaxRequester({\n\t            validMethods: [ method ],\n\t            method: method,\n\t            successfulResponseCodes: function() {\n\t                var codes = {};\n\t                codes[method] = [ 201 ];\n\t                return codes;\n\t            }(),\n\t            contentType: null,\n\t            customHeaders: function(id) {\n\t                var params = options.getBlobMetadata(id), headers = qq.azure.util.getParamsAsHeaders(params);\n\t                headers[\"x-ms-blob-type\"] = \"BlockBlob\";\n\t                return headers;\n\t            },\n\t            endpointStore: endpointHandler,\n\t            allowXRequestedWithAndCacheControl: false,\n\t            cors: {\n\t                expected: true\n\t            },\n\t            log: options.log,\n\t            onComplete: function(id, xhr, isError) {\n\t                var promise = promises[id];\n\t                delete endpoints[id];\n\t                delete promises[id];\n\t                if (isError) {\n\t                    promise.failure();\n\t                } else {\n\t                    promise.success();\n\t                }\n\t            }\n\t        }));\n\t        qq.extend(this, {\n\t            method: method,\n\t            upload: function(id, xhr, url, file) {\n\t                var promise = new qq.Promise();\n\t                options.log(\"Submitting Put Blob request for \" + id);\n\t                promises[id] = promise;\n\t                endpoints[id] = url;\n\t                requester.initTransport(id).withPayload(file).withHeaders({\n\t                    \"Content-Type\": file.type\n\t                }).send(xhr);\n\t                return promise;\n\t            }\n\t        });\n\t    };\n\t    qq.azure.PutBlock = function(o) {\n\t        \"use strict\";\n\t        var requester, method = \"PUT\", blockIdEntries = {}, promises = {}, options = {\n\t            log: function(str, level) {}\n\t        }, endpoints = {}, endpointHandler = {\n\t            get: function(id) {\n\t                return endpoints[id];\n\t            }\n\t        };\n\t        qq.extend(options, o);\n\t        requester = qq.extend(this, new qq.AjaxRequester({\n\t            validMethods: [ method ],\n\t            method: method,\n\t            successfulResponseCodes: function() {\n\t                var codes = {};\n\t                codes[method] = [ 201 ];\n\t                return codes;\n\t            }(),\n\t            contentType: null,\n\t            endpointStore: endpointHandler,\n\t            allowXRequestedWithAndCacheControl: false,\n\t            cors: {\n\t                expected: true\n\t            },\n\t            log: options.log,\n\t            onComplete: function(id, xhr, isError) {\n\t                var promise = promises[id], blockIdEntry = blockIdEntries[id];\n\t                delete endpoints[id];\n\t                delete promises[id];\n\t                delete blockIdEntries[id];\n\t                if (isError) {\n\t                    promise.failure();\n\t                } else {\n\t                    promise.success(blockIdEntry);\n\t                }\n\t            }\n\t        }));\n\t        function createBlockId(partNum) {\n\t            var digits = 5, zeros = new Array(digits + 1).join(\"0\"), paddedPartNum = (zeros + partNum).slice(-digits);\n\t            return btoa(paddedPartNum);\n\t        }\n\t        qq.extend(this, {\n\t            method: method,\n\t            upload: function(id, xhr, sasUri, partNum, blob) {\n\t                var promise = new qq.Promise(), blockId = createBlockId(partNum);\n\t                promises[id] = promise;\n\t                options.log(qq.format(\"Submitting Put Block request for {} = part {}\", id, partNum));\n\t                endpoints[id] = qq.format(\"{}&comp=block&blockid={}\", sasUri, encodeURIComponent(blockId));\n\t                blockIdEntries[id] = {\n\t                    part: partNum,\n\t                    id: blockId\n\t                };\n\t                requester.initTransport(id).withPayload(blob).send(xhr);\n\t                return promise;\n\t            }\n\t        });\n\t    };\n\t    qq.azure.PutBlockList = function(o) {\n\t        \"use strict\";\n\t        var requester, method = \"PUT\", promises = {}, options = {\n\t            getBlobMetadata: function(id) {},\n\t            log: function(str, level) {}\n\t        }, endpoints = {}, endpointHandler = {\n\t            get: function(id) {\n\t                return endpoints[id];\n\t            }\n\t        };\n\t        qq.extend(options, o);\n\t        requester = qq.extend(this, new qq.AjaxRequester({\n\t            validMethods: [ method ],\n\t            method: method,\n\t            successfulResponseCodes: function() {\n\t                var codes = {};\n\t                codes[method] = [ 201 ];\n\t                return codes;\n\t            }(),\n\t            customHeaders: function(id) {\n\t                var params = options.getBlobMetadata(id);\n\t                return qq.azure.util.getParamsAsHeaders(params);\n\t            },\n\t            contentType: \"text/plain\",\n\t            endpointStore: endpointHandler,\n\t            allowXRequestedWithAndCacheControl: false,\n\t            cors: {\n\t                expected: true\n\t            },\n\t            log: options.log,\n\t            onSend: function() {},\n\t            onComplete: function(id, xhr, isError) {\n\t                var promise = promises[id];\n\t                delete endpoints[id];\n\t                delete promises[id];\n\t                if (isError) {\n\t                    promise.failure(xhr);\n\t                } else {\n\t                    promise.success(xhr);\n\t                }\n\t            }\n\t        }));\n\t        function createRequestBody(blockIdEntries) {\n\t            var doc = document.implementation.createDocument(null, \"BlockList\", null);\n\t            blockIdEntries.sort(function(a, b) {\n\t                return a.part - b.part;\n\t            });\n\t            qq.each(blockIdEntries, function(idx, blockIdEntry) {\n\t                var latestEl = doc.createElement(\"Latest\"), latestTextEl = doc.createTextNode(blockIdEntry.id);\n\t                latestEl.appendChild(latestTextEl);\n\t                qq(doc).children()[0].appendChild(latestEl);\n\t            });\n\t            return new XMLSerializer().serializeToString(doc);\n\t        }\n\t        qq.extend(this, {\n\t            method: method,\n\t            send: function(id, sasUri, blockIdEntries, fileMimeType, registerXhrCallback) {\n\t                var promise = new qq.Promise(), blockIdsXml = createRequestBody(blockIdEntries), xhr;\n\t                promises[id] = promise;\n\t                options.log(qq.format(\"Submitting Put Block List request for {}\", id));\n\t                endpoints[id] = qq.format(\"{}&comp=blocklist\", sasUri);\n\t                xhr = requester.initTransport(id).withPayload(blockIdsXml).withHeaders({\n\t                    \"x-ms-blob-content-type\": fileMimeType\n\t                }).send();\n\t                registerXhrCallback(xhr);\n\t                return promise;\n\t            }\n\t        });\n\t    };\n\t    (function() {\n\t        \"use strict\";\n\t        qq.azure.FineUploader = function(o) {\n\t            var options = {\n\t                failedUploadTextDisplay: {\n\t                    mode: \"custom\"\n\t                }\n\t            };\n\t            qq.extend(options, o, true);\n\t            qq.FineUploader.call(this, options, \"azure\");\n\t        };\n\t        qq.extend(qq.azure.FineUploader.prototype, qq.azure.FineUploaderBasic.prototype);\n\t        qq.extend(qq.azure.FineUploader.prototype, qq.uiPublicApi);\n\t        qq.extend(qq.azure.FineUploader.prototype, qq.uiPrivateApi);\n\t        qq.extend(qq.azure.FineUploader.prototype, {});\n\t    })();\n\t})(window);\n\t//# sourceMappingURL=all.fine-uploader.js.map\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = __webpack_require__(70);\n\n\n/***/ },\n/* 72 */,\n/* 73 */,\n/* 74 */,\n/* 75 */,\n/* 76 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\n\t\tAuthor Tobias Koppers @sokra\n\t*/\n\tvar stylesInDom = {},\n\t\tmemoize = function(fn) {\n\t\t\tvar memo;\n\t\t\treturn function () {\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\t\treturn memo;\n\t\t\t};\n\t\t},\n\t\tisOldIE = memoize(function() {\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t\t}),\n\t\tgetHeadElement = memoize(function () {\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t\t}),\n\t\tsingletonElement = null,\n\t\tsingletonCounter = 0,\n\t\tstyleElementsInsertedAtTop = [];\n\t\n\tmodule.exports = function(list, options) {\n\t\tif(false) {\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t\t}\n\t\n\t\toptions = options || {};\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t\t// tags it will allow on a page\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\t\n\t\t// By default, add <style> tags to the bottom of <head>.\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\t\n\t\tvar styles = listToStyles(list);\n\t\taddStylesToDom(styles, options);\n\t\n\t\treturn function update(newList) {\n\t\t\tvar mayRemove = [];\n\t\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\t\tvar item = styles[i];\n\t\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\t\tdomStyle.refs--;\n\t\t\t\tmayRemove.push(domStyle);\n\t\t\t}\n\t\t\tif(newList) {\n\t\t\t\tvar newStyles = listToStyles(newList);\n\t\t\t\taddStylesToDom(newStyles, options);\n\t\t\t}\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\t\tvar domStyle = mayRemove[i];\n\t\t\t\tif(domStyle.refs === 0) {\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction addStylesToDom(styles, options) {\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tif(domStyle) {\n\t\t\t\tdomStyle.refs++;\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t\t}\n\t\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar parts = [];\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction listToStyles(list) {\n\t\tvar styles = [];\n\t\tvar newStyles = {};\n\t\tfor(var i = 0; i < list.length; i++) {\n\t\t\tvar item = list[i];\n\t\t\tvar id = item[0];\n\t\t\tvar css = item[1];\n\t\t\tvar media = item[2];\n\t\t\tvar sourceMap = item[3];\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\t\tif(!newStyles[id])\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\t\telse\n\t\t\t\tnewStyles[id].parts.push(part);\n\t\t}\n\t\treturn styles;\n\t}\n\t\n\tfunction insertStyleElement(options, styleElement) {\n\t\tvar head = getHeadElement();\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\t\tif (options.insertAt === \"top\") {\n\t\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t\t} else {\n\t\t\t\thead.appendChild(styleElement);\n\t\t\t}\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t\t} else if (options.insertAt === \"bottom\") {\n\t\t\thead.appendChild(styleElement);\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t\t}\n\t}\n\t\n\tfunction removeStyleElement(styleElement) {\n\t\tstyleElement.parentNode.removeChild(styleElement);\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\t\tif(idx >= 0) {\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t\t}\n\t}\n\t\n\tfunction createStyleElement(options) {\n\t\tvar styleElement = document.createElement(\"style\");\n\t\tstyleElement.type = \"text/css\";\n\t\tinsertStyleElement(options, styleElement);\n\t\treturn styleElement;\n\t}\n\t\n\tfunction addStyle(obj, options) {\n\t\tvar styleElement, update, remove;\n\t\n\t\tif (options.singleton) {\n\t\t\tvar styleIndex = singletonCounter++;\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t\t} else {\n\t\t\tstyleElement = createStyleElement(options);\n\t\t\tupdate = applyToTag.bind(null, styleElement);\n\t\t\tremove = function() {\n\t\t\t\tremoveStyleElement(styleElement);\n\t\t\t};\n\t\t}\n\t\n\t\tupdate(obj);\n\t\n\t\treturn function updateStyle(newObj) {\n\t\t\tif(newObj) {\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\t\treturn;\n\t\t\t\tupdate(obj = newObj);\n\t\t\t} else {\n\t\t\t\tremove();\n\t\t\t}\n\t\t};\n\t}\n\t\n\tvar replaceText = (function () {\n\t\tvar textStore = [];\n\t\n\t\treturn function (index, replacement) {\n\t\t\ttextStore[index] = replacement;\n\t\t\treturn textStore.filter(Boolean).join('\\n');\n\t\t};\n\t})();\n\t\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\t\tvar css = remove ? \"\" : obj.css;\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t\t} else {\n\t\t\tvar cssNode = document.createTextNode(css);\n\t\t\tvar childNodes = styleElement.childNodes;\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\t\tif (childNodes.length) {\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t\t} else {\n\t\t\t\tstyleElement.appendChild(cssNode);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction applyToTag(styleElement, obj) {\n\t\tvar css = obj.css;\n\t\tvar media = obj.media;\n\t\tvar sourceMap = obj.sourceMap;\n\t\n\t\tif (media) {\n\t\t\tstyleElement.setAttribute(\"media\", media);\n\t\t}\n\t\n\t\tif (sourceMap) {\n\t\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t\t// this makes source maps inside style tags work properly in Chrome\n\t\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t\t// http://stackoverflow.com/a/26603875\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t\t}\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = css;\n\t\t} else {\n\t\t\twhile(styleElement.firstChild) {\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t\t}\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\n\t\t}\n\t}\n\n\n/***/ }\n]);\n\n\n// WEBPACK FOOTER //\n// static/js/vendor.3e1f2576aadeeb10b05b.js","var store      = require('./_shared')('wks')\n  , uid        = require('./_uid')\n  , Symbol     = require('./_global').Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_wks.js\n// module id = 1\n// module chunks = 1","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_global.js\n// module id = 2\n// module chunks = 1","var isObject = require('./_is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_an-object.js\n// module id = 3\n// module chunks = 1","var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_core.js\n// module id = 4\n// module chunks = 1","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_descriptors.js\n// module id = 5\n// module chunks = 1","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_has.js\n// module id = 6\n// module chunks = 1","var dP         = require('./_object-dp')\n  , createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_hide.js\n// module id = 7\n// module chunks = 1","var anObject       = require('./_an-object')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , toPrimitive    = require('./_to-primitive')\n  , dP             = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-dp.js\n// module id = 8\n// module chunks = 1","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_defined.js\n// module id = 9\n// module chunks = 1","var global    = require('./_global')\n  , core      = require('./_core')\n  , ctx       = require('./_ctx')\n  , hide      = require('./_hide')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_export.js\n// module id = 10\n// module chunks = 1","module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_fails.js\n// module id = 11\n// module chunks = 1","module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_is-object.js\n// module id = 12\n// module chunks = 1","module.exports = {};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iterators.js\n// module id = 13\n// module chunks = 1","module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_property-desc.js\n// module id = 14\n// module chunks = 1","var shared = require('./_shared')('keys')\n  , uid    = require('./_uid');\nmodule.exports = function(key){\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_shared-key.js\n// module id = 15\n// module chunks = 1","// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-integer.js\n// module id = 16\n// module chunks = 1","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function(it){\n  return Object(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-object.js\n// module id = 17\n// module chunks = 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _assign = require(\"../core-js/object/assign\");\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _assign2.default || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/extends.js\n// module id = 18\n// module chunks = 1","var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_cof.js\n// module id = 19\n// module chunks = 1","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_ctx.js\n// module id = 20\n// module chunks = 1","var isObject = require('./_is-object')\n  , document = require('./_global').document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_dom-create.js\n// module id = 21\n// module chunks = 1","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_enum-bug-keys.js\n// module id = 22\n// module chunks = 1","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iobject.js\n// module id = 23\n// module chunks = 1","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys       = require('./_object-keys-internal')\n  , enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O){\n  return $keys(O, enumBugKeys);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-keys.js\n// module id = 24\n// module chunks = 1","var def = require('./_object-dp').f\n  , has = require('./_has')\n  , TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_set-to-string-tag.js\n// module id = 25\n// module chunks = 1","var global = require('./_global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_shared.js\n// module id = 26\n// module chunks = 1","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject')\n  , defined = require('./_defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-iobject.js\n// module id = 27\n// module chunks = 1","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer')\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-length.js\n// module id = 28\n// module chunks = 1","var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_uid.js\n// module id = 29\n// module chunks = 1","/*!\n * Vue.js v2.1.8\n * (c) 2014-2016 Evan You\n * Released under the MIT License.\n */\n'use strict';\n\n/*  */\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction _toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val, 10);\n  return (n || n === 0) ? n : val\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove$1 (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delmited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind$1 (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\nfunction isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    return JSON.stringify(a) === JSON.stringify(b)\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * List of asset types that a component can own.\n   */\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n\n  /**\n   * List of lifecycle hooks.\n   */\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n\n  /**\n   * Max circular updates allowed in a scheduler flush cycle.\n   */\n  _maxUpdateCount: 100\n};\n\n/*  */\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  } else {\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) { return }\n        obj = obj[segments[i]];\n      }\n      return obj\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return /native code/.test(Ctor.toString())\n}\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) { cb.call(ctx); }\n      if (_resolve) { _resolve(ctx); }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\nvar warn = noop;\nvar formatComponentName;\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm) {\n    if (vm.$root === vm) {\n      return 'root instance'\n    }\n    var name = vm._isVue\n      ? vm.$options.name || vm.$options._componentTag\n      : vm.name;\n    return (\n      (name ? (\"component <\" + name + \">\") : \"anonymous component\") +\n      (vm._isVue && vm.$options.__file ? (\" at \" + (vm.$options.__file)) : '')\n    )\n  };\n\n  var formatLocation = function (str) {\n    if (str === 'anonymous component') {\n      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n    }\n    return (\"\\n(found in \" + str + \")\")\n  };\n}\n\n/*  */\n\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid$1++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove$1(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stablize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set$1 (obj, key, val) {\n  if (Array.isArray(obj)) {\n    obj.length = Math.max(obj.length, key);\n    obj.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(obj, key)) {\n    obj[key] = val;\n    return\n  }\n  var ob = obj.__ob__;\n  if (obj._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return\n  }\n  if (!ob) {\n    obj[key] = val;\n    return\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (obj, key) {\n  var ob = obj.__ob__;\n  if (obj._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(obj, key)) {\n    return\n  }\n  delete obj[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set$1(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and param attributes are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nconfig._lifecycleHooks.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return parentVal }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return parentVal }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = typeof extendsFrom === 'function'\n      ? mergeOptions(parent, extendsFrom.options, vm)\n      : mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      if (mixin.prototype instanceof Vue$2) {\n        mixin = mixin.options;\n      }\n      parent = mergeOptions(parent, mixin, vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (isObject(def)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm[key] !== undefined) {\n    return vm[key]\n  }\n  // call factory function for non-Function types\n  return typeof def === 'function' && prop.type !== Function\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\n/**\n * Assert the type of a value\n */\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (expectedType === 'String') {\n    valid = typeof value === (expectedType = 'string');\n  } else if (expectedType === 'Number') {\n    valid = typeof value === (expectedType = 'number');\n  } else if (expectedType === 'Boolean') {\n    valid = typeof value === (expectedType = 'boolean');\n  } else if (expectedType === 'Function') {\n    valid = typeof value === (expectedType = 'function');\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match && match[1]\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n\n\nvar util = Object.freeze({\n\tdefineReactive: defineReactive$$1,\n\t_toString: _toString,\n\ttoNumber: toNumber,\n\tmakeMap: makeMap,\n\tisBuiltInTag: isBuiltInTag,\n\tremove: remove$1,\n\thasOwn: hasOwn,\n\tisPrimitive: isPrimitive,\n\tcached: cached,\n\tcamelize: camelize,\n\tcapitalize: capitalize,\n\thyphenate: hyphenate,\n\tbind: bind$1,\n\ttoArray: toArray,\n\textend: extend,\n\tisObject: isObject,\n\tisPlainObject: isPlainObject,\n\ttoObject: toObject,\n\tnoop: noop,\n\tno: no,\n\tidentity: identity,\n\tgenStaticKeys: genStaticKeys,\n\tlooseEqual: looseEqual,\n\tlooseIndexOf: looseIndexOf,\n\tisReserved: isReserved,\n\tdef: def,\n\tparsePath: parsePath,\n\thasProto: hasProto,\n\tinBrowser: inBrowser,\n\tUA: UA,\n\tisIE: isIE,\n\tisIE9: isIE9,\n\tisEdge: isEdge,\n\tisAndroid: isAndroid,\n\tisIOS: isIOS,\n\tisServerRendering: isServerRendering,\n\tdevtools: devtools,\n\tnextTick: nextTick,\n\tget _Set () { return _Set; },\n\tmergeOptions: mergeOptions,\n\tresolveAsset: resolveAsset,\n\tget warn () { return warn; },\n\tget formatComponentName () { return formatComponentName; },\n\tvalidateProp: validateProp\n});\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\n\nvar queue = [];\nvar has$1 = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  queue.length = 0;\n  has$1 = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    var watcher = queue[index];\n    var id = watcher.id;\n    has$1[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has$1[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n\n  resetSchedulerState();\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has$1[id] == null) {\n    has$1[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i >= 0 && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(Math.max(i, index) + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value = this.getter.call(this.vm, this.vm);\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          /* istanbul ignore else */\n          if (config.errorHandler) {\n            config.errorHandler.call(null, e, this.vm);\n          } else {\n            process.env.NODE_ENV !== 'production' && warn(\n              (\"Error in watcher \\\"\" + (this.expression) + \"\\\"\"),\n              this.vm\n            );\n            throw e\n          }\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove$1(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = { key: 1, ref: 1, slot: 1 };\n\nfunction initProps (vm, props) {\n  var propsData = vm.$options.propsData || {};\n  var keys = vm.$options._propKeys = Object.keys(props);\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( i ) {\n    var key = keys[i];\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedProp[key]) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm));\n    }\n  };\n\n  for (var i = 0; i < keys.length; i++) loop( i );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? data.call(vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else {\n      proxy(vm, keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nvar computedSharedDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction initComputed (vm, computed) {\n  for (var key in computed) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && key in vm) {\n      warn(\n        \"existing instance property \\\"\" + key + \"\\\" will be \" +\n        \"overwritten by a computed property with the same name.\",\n        vm\n      );\n    }\n    var userDef = computed[key];\n    if (typeof userDef === 'function') {\n      computedSharedDefinition.get = makeComputedGetter(userDef, vm);\n      computedSharedDefinition.set = noop;\n    } else {\n      computedSharedDefinition.get = userDef.get\n        ? userDef.cache !== false\n          ? makeComputedGetter(userDef.get, vm)\n          : bind$1(userDef.get, vm)\n        : noop;\n      computedSharedDefinition.set = userDef.set\n        ? bind$1(userDef.set, vm)\n        : noop;\n    }\n    Object.defineProperty(vm, key, computedSharedDefinition);\n  }\n}\n\nfunction makeComputedGetter (getter, owner) {\n  var watcher = new Watcher(owner, getter, noop, {\n    lazy: true\n  });\n  return function computedGetter () {\n    if (watcher.dirty) {\n      watcher.evaluate();\n    }\n    if (Dep.target) {\n      watcher.depend();\n    }\n    return watcher.value\n  }\n}\n\nfunction initMethods (vm, methods) {\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production' && methods[key] == null) {\n      warn(\n        \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n        \"Did you reference the function correctly?\",\n        vm\n      );\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () {\n    return this._data\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n\n  Vue.prototype.$set = set$1;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\nfunction proxy (vm, key) {\n  if (!isReserved(key)) {\n    Object.defineProperty(vm, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return vm._data[key]\n      },\n      set: function proxySetter (val) {\n        vm._data[key] = val;\n      }\n    });\n  }\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.child = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var res = new Array(vnodes.length);\n  for (var i = 0; i < vnodes.length; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook, key) {\n  key = key + hookKey;\n  var injectedHash = def.__injected || (def.__injected = {});\n  if (!injectedHash[key]) {\n    injectedHash[key] = true;\n    var oldHook = def[hookKey];\n    if (oldHook) {\n      def[hookKey] = function () {\n        oldHook.apply(this, arguments);\n        hook.apply(this, arguments);\n      };\n    } else {\n      def[hookKey] = hook;\n    }\n  }\n}\n\n/*  */\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, fn, event, capture, once;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    if (!cur) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + name + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (!old) {\n      once = name.charAt(0) === '~'; // Prefixed last, checked first\n      event = once ? name.slice(1) : name;\n      capture = event.charAt(0) === '!';\n      event = capture ? event.slice(1) : event;\n      if (Array.isArray(cur)) {\n        add(event, (cur.invoker = arrInvoker(cur)), once, capture);\n      } else {\n        if (!cur.invoker) {\n          fn = cur;\n          cur = on[name] = {};\n          cur.fn = fn;\n          cur.invoker = fnInvoker(cur);\n        }\n        add(event, cur.invoker, once, capture);\n      }\n    } else if (cur !== old) {\n      if (Array.isArray(old)) {\n        old.length = cur.length;\n        for (var i = 0; i < old.length; i++) { old[i] = cur[i]; }\n        on[name] = old;\n      } else {\n        old.fn = cur;\n        on[name] = old;\n      }\n    }\n  }\n  for (name in oldOn) {\n    if (!on[name]) {\n      once = name.charAt(0) === '~'; // Prefixed last, checked first\n      event = once ? name.slice(1) : name;\n      capture = event.charAt(0) === '!';\n      event = capture ? event.slice(1) : event;\n      remove$$1(event, oldOn[name].invoker, capture);\n    }\n  }\n}\n\nfunction arrInvoker (arr) {\n  return function (ev) {\n    var arguments$1 = arguments;\n\n    var single = arguments.length === 1;\n    for (var i = 0; i < arr.length; i++) {\n      single ? arr[i](ev) : arr[i].apply(null, arguments$1);\n    }\n  }\n}\n\nfunction fnInvoker (o) {\n  return function (ev) {\n    var single = arguments.length === 1;\n    single ? o.fn(ev) : o.fn.apply(null, arguments);\n  }\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// nomralization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constrcuts that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (c == null || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (last && last.text) {\n        last.text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (c.text && last && last.text) {\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (c.tag && c.key == null && nestedIndex != null) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n}\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add$1 (event, fn, once) {\n  if (once) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$2 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add$1, remove$2, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);\n    // optimize hook:event cost by using a boolean flag marked at registration\n    // instead of a hash lookup\n    if (hookRE.test(event)) {\n      vm._hasHookEvent = true;\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._mount = function (\n    el,\n    hydrating\n  ) {\n    var vm = this;\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      if (process.env.NODE_ENV !== 'production') {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#') {\n          warn(\n            'You are using the runtime-only build of Vue where the template ' +\n            'option is not available. Either pre-compile the templates into ' +\n            'render functions, or use the compiler-included build.',\n            vm\n          );\n        } else {\n          warn(\n            'Failed to mount component: template or render function not defined.',\n            vm\n          );\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n    vm._watcher = new Watcher(vm, function () {\n      vm._update(vm._render(), hydrating);\n    }, noop);\n    hydrating = false;\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm\n  };\n\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    if (vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  };\n\n  Vue.prototype._updateFromParent = function (\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n    var vm = this;\n    var hasChildren = !!(vm.$options._renderChildren || renderChildren);\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n    if (vm._vnode) { // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n    // update props\n    if (propsData && vm.$options.props) {\n      observerState.shouldConvert = false;\n      if (process.env.NODE_ENV !== 'production') {\n        observerState.isSettingProps = true;\n      }\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        vm[key] = validateProp(key, vm.$options.props, propsData, vm);\n      }\n      observerState.shouldConvert = true;\n      if (process.env.NODE_ENV !== 'production') {\n        observerState.isSettingProps = false;\n      }\n      vm.$options.propsData = propsData;\n    }\n    // update listeners\n    if (listeners) {\n      var oldListeners = vm.$options._parentListeners;\n      vm.$options._parentListeners = listeners;\n      updateComponentListeners(vm, listeners, oldListeners);\n    }\n    // resolve slots + force update if has children\n    if (hasChildren) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove$1(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n  };\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      handlers[i].call(vm);\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\nvar hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };\nvar hooksToMerge = Object.keys(hooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (!Ctor) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (!Ctor.cid) {\n    if (Ctor.resolved) {\n      Ctor = Ctor.resolved;\n    } else {\n      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n        // it's ok to queue this on every render because\n        // $forceUpdate is buffered by the scheduler.\n        context.$forceUpdate();\n      });\n      if (!Ctor) {\n        // return nothing if this is indeed an async component\n        // wait for the callback to trigger parent update.\n        return\n      }\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // extract props\n  var propsData = extractProps(data, Ctor);\n\n  // functional component\n  if (Ctor.options.functional) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (Ctor.options.abstract) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (propOptions) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData);\n    }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    props: props,\n    data: data,\n    parent: context,\n    children: children,\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (inlineTemplate) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction init (\n  vnode,\n  hydrating,\n  parentElm,\n  refElm\n) {\n  if (!vnode.child || vnode.child._isDestroyed) {\n    var child = vnode.child = createComponentInstanceForVnode(\n      vnode,\n      activeInstance,\n      parentElm,\n      refElm\n    );\n    child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n  } else if (vnode.data.keepAlive) {\n    // kept-alive components, treat as a patch\n    var mountedNode = vnode; // work around flow\n    prepatch(mountedNode, mountedNode);\n  }\n}\n\nfunction prepatch (\n  oldVnode,\n  vnode\n) {\n  var options = vnode.componentOptions;\n  var child = vnode.child = oldVnode.child;\n  child._updateFromParent(\n    options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n  );\n}\n\nfunction insert (vnode) {\n  if (!vnode.child._isMounted) {\n    vnode.child._isMounted = true;\n    callHook(vnode.child, 'mounted');\n  }\n  if (vnode.data.keepAlive) {\n    vnode.child._inactive = false;\n    callHook(vnode.child, 'activated');\n  }\n}\n\nfunction destroy$1 (vnode) {\n  if (!vnode.child._isDestroyed) {\n    if (!vnode.data.keepAlive) {\n      vnode.child.$destroy();\n    } else {\n      vnode.child._inactive = true;\n      callHook(vnode.child, 'deactivated');\n    }\n  }\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  cb\n) {\n  if (factory.requested) {\n    // pool callbacks\n    factory.pendingCallbacks.push(cb);\n  } else {\n    factory.requested = true;\n    var cbs = factory.pendingCallbacks = [cb];\n    var sync = true;\n\n    var resolve = function (res) {\n      if (isObject(res)) {\n        res = baseCtor.extend(res);\n      }\n      // cache resolved\n      factory.resolved = res;\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res);\n        }\n      }\n    };\n\n    var reject = function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n    };\n\n    var res = factory(resolve, reject);\n\n    // handle promise\n    if (res && typeof res.then === 'function' && !factory.resolved) {\n      res.then(resolve, reject);\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.resolved\n  }\n}\n\nfunction extractProps (data, Ctor) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (!propOptions) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  var domProps = data.domProps;\n  if (attrs || props || domProps) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey) ||\n      checkProp(res, domProps, key, altKey);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (hash) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = hooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (data && data.__ob__) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n      typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (vnode) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (vnode.children) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (child.tag && !child.ns) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm.$vnode = null; // the placeholder node in parent tree\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$options._parentVnode;\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = {};\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n  if (vm.$options.el) {\n    vm.$mount(vm.$options.el);\n  }\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    if (_parentVnode && _parentVnode.data.scopedSlots) {\n      vm.$scopedSlots = _parentVnode.data.scopedSlots;\n    }\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      /* istanbul ignore else */\n      if (config.errorHandler) {\n        config.errorHandler.call(null, e, vm);\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn((\"Error when rendering \" + (formatComponentName(vm)) + \":\"));\n        }\n        throw e\n      }\n      // return previous vnode to prevent render error causing blank component\n      vnode = vm._vnode;\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // toString for mustaches\n  Vue.prototype._s = _toString;\n  // convert text to vnode\n  Vue.prototype._v = createTextVNode;\n  // number conversion\n  Vue.prototype._n = toNumber;\n  // empty vnode\n  Vue.prototype._e = createEmptyVNode;\n  // loose equal\n  Vue.prototype._q = looseEqual;\n  // loose indexOf\n  Vue.prototype._i = looseIndexOf;\n\n  // render static tree by index\n  Vue.prototype._m = function renderStatic (\n    index,\n    isInFor\n  ) {\n    var tree = this._staticTrees[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree by doing a shallow clone.\n    if (tree && !isInFor) {\n      return Array.isArray(tree)\n        ? cloneVNodes(tree)\n        : cloneVNode(tree)\n    }\n    // otherwise, render a fresh tree.\n    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n    markStatic(tree, (\"__static__\" + index), false);\n    return tree\n  };\n\n  // mark node as static (v-once)\n  Vue.prototype._o = function markOnce (\n    tree,\n    index,\n    key\n  ) {\n    markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n    return tree\n  };\n\n  function markStatic (tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode (node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n\n  // filter resolution helper\n  Vue.prototype._f = function resolveFilter (id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity\n  };\n\n  // render v-for\n  Vue.prototype._l = function renderList (\n    val,\n    render\n  ) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n    return ret\n  };\n\n  // renderSlot\n  Vue.prototype._t = function (\n    name,\n    fallback,\n    props,\n    bindObject\n  ) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    if (scopedSlotFn) { // scoped slot\n      props = props || {};\n      if (bindObject) {\n        extend(props, bindObject);\n      }\n      return scopedSlotFn(props) || fallback\n    } else {\n      var slotNodes = this.$slots[name];\n      // warn duplicate slot usage\n      if (slotNodes && process.env.NODE_ENV !== 'production') {\n        slotNodes._rendered && warn(\n          \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n          \"- this will likely cause render errors.\",\n          this\n        );\n        slotNodes._rendered = true;\n      }\n      return slotNodes || fallback\n    }\n  };\n\n  // apply v-bind object\n  Vue.prototype._b = function bindProps (\n    data,\n    tag,\n    value,\n    asProp\n  ) {\n    if (value) {\n      if (!isObject(value)) {\n        process.env.NODE_ENV !== 'production' && warn(\n          'v-bind without argument expects an Object or Array value',\n          this\n        );\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        for (var key in value) {\n          if (key === 'class' || key === 'style') {\n            data[key] = value[key];\n          } else {\n            var hash = asProp || config.mustUseProp(tag, key)\n              ? data.domProps || (data.domProps = {})\n              : data.attrs || (data.attrs = {});\n            hash[key] = value[key];\n          }\n        }\n      }\n    }\n    return data\n  };\n\n  // check v-on keyCodes\n  Vue.prototype._k = function checkKeyCodes (\n    eventKeyCode,\n    key,\n    builtInAlias\n  ) {\n    var keyCodes = config.keyCodes[key] || builtInAlias;\n    if (Array.isArray(keyCodes)) {\n      return keyCodes.indexOf(eventKeyCode) === -1\n    } else {\n      return keyCodes !== eventKeyCode\n    }\n  };\n}\n\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  var name, child;\n  for (var i = 0, l = children.length; i < l; i++) {\n    child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n        child.data && (name = child.data.slot)) {\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore single whitespace\n  if (defaultSlot.length && !(\n    defaultSlot.length === 1 &&\n    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)\n  )) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    callHook(vm, 'beforeCreate');\n    initState(vm);\n    callHook(vm, 'created');\n    initRender(vm);\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = Ctor.super.options;\n    var cachedSuperOptions = Ctor.superOptions;\n    var extendOptions = Ctor.extendOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed\n      Ctor.superOptions = superOptions;\n      extendOptions.render = options.render;\n      extendOptions.staticRenderFns = options.staticRenderFns;\n      extendOptions._scopeId = options._scopeId;\n      options = Ctor.options = mergeOptions(superOptions, extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction Vue$2 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$2)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$2);\nstateMixin(Vue$2);\neventsMixin(Vue$2);\nlifecycleMixin(Vue$2);\nrenderMixin(Vue$2);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else {\n    return pattern.test(name)\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    if (vnode && vnode.componentOptions) {\n      var opts = vnode.componentOptions;\n      // check pattern\n      var name = opts.Ctor.options.name || opts.tag;\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? opts.Ctor.cid + (opts.tag ? (\"::\" + (opts.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.child = this.cache[key].child;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  },\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this.cache) {\n      var vnode = this$1.cache[key];\n      callHook(vnode.child, 'deactivated');\n      vnode.child.$destroy();\n    }\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n  Vue.util = util;\n  Vue.set = set$1;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  config._assetTypes.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$2);\n\nObject.defineProperty(Vue$2.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nVue$2.version = '2.1.8';\n\n/*  */\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (childNode.child) {\n    childNode = childNode.child._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: child.class\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (staticClass || dynamicClass) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  var res = '';\n  if (!value) {\n    return res\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        if ((stringified = stringifyClass(value[i]))) {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,' +\n  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\n\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selector = el;\n    el = document.querySelector(el);\n    if (!el) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + selector\n      );\n      return document.createElement('div')\n    }\n  }\n  return el\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.child || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove$1(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction isUndef (s) {\n  return s == null\n}\n\nfunction isDef (s) {\n  return s != null\n}\n\nfunction sameVnode (vnode1, vnode2) {\n  return (\n    vnode1.key === vnode2.key &&\n    vnode1.tag === vnode2.tag &&\n    vnode1.isComment === vnode2.isComment &&\n    !vnode1.data === !vnode2.data\n  )\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks$1.length; ++i) {\n    cbs[hooks$1[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (parent) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (vnode.isComment) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.child) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.child)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isReactivated) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.child) {\n      innerNode = innerNode.child._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (parent) {\n      if (ref) {\n        nodeOps.insertBefore(parent, elm, ref);\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.child) {\n      vnode = vnode.child._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (i.create) { i.create(emptyNode, vnode); }\n      if (i.insert) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (vnode.data.pendingInsert) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.child.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n    if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (rm || isDef(vnode.data)) {\n      var listeners = cbs.remove.length + 1;\n      if (!rm) {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      } else {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.child) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (vnode.isStatic &&\n        oldVnode.isStatic &&\n        vnode.key === oldVnode.key &&\n        (vnode.isCloned || vnode.isOnce)) {\n      vnode.elm = oldVnode.elm;\n      vnode.child = oldVnode.child;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    var hasData = isDef(data);\n    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (hasData && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (hasData) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (initial && vnode.parent) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.child)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (vnode.tag) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (!vnode) {\n      if (oldVnode) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var elm, parent;\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (!oldVnode) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n            oldVnode.removeAttribute('server-rendered');\n            hydrating = true;\n          }\n          if (hydrating) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        elm = oldVnode.elm;\n        parent = nodeOps.parentNode(elm);\n        createElm(vnode, insertedVnodeQueue, parent, nodeOps.nextSibling(elm));\n\n        if (vnode.parent) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (parent !== null) {\n          removeVnodes(parent, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    }, 'dir-postpatch');\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (attrs.__ob__) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (attrs[key] == null) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (!data.staticClass && !data.class &&\n      (!oldData || (!oldData.staticClass && !oldData.class))) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (transitionClass) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar target$1;\n\nfunction add$2 (event, handler, once, capture) {\n  if (once) {\n    var oldHandler = handler;\n    handler = function (ev) {\n      remove$3(event, handler, capture);\n      arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n    };\n  }\n  target$1.addEventListener(event, handler, capture);\n}\n\nfunction remove$3 (event, handler, capture) {\n  target$1.removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (!oldVnode.data.on && !vnode.data.on) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  updateListeners(on, oldOn, add$2, remove$3, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (props.__ob__) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (props[key] == null) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n    // #4521: if a click event triggers update before the change event is\n    // dispatched on a checkbox/radio input, the input's checked state will\n    // be reset and fail to trigger another update.\n    /* istanbul ignore next */\n    if (key === 'checked' && !isDirty(elm, cur)) {\n      continue\n    }\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = cur == null ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  if (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(vnode, checkVal)\n  )) {\n    return true\n  }\n  return false\n}\n\nfunction isDirty (elm, checkVal) {\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (vnode, newVal) {\n  var value = vnode.elm.value;\n  var modifiers = vnode.elm._vModifiers; // injected by v-model runtime\n  if ((modifiers && modifiers.number) || vnode.elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (modifiers && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.child) {\n      childNode = childNode.child._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    el.style[normalize(name)] = val;\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (!data.staticStyle && !data.style &&\n      !oldData.staticStyle && !oldData.style) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldVnode.data.staticStyle;\n  var oldStyleBinding = oldVnode.data.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (newStyle[name] == null) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !cls.trim()) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = ' ' + el.getAttribute('class') + ' ';\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !cls.trim()) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = ' ' + el.getAttribute('class') + ' ';\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\nvar raf = (inBrowser && window.requestAnimationFrame) || setTimeout;\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove$1(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (el._leaveCb) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (el._enterCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear ? appearClass : enterClass;\n  var activeClass = isAppear ? appearActiveClass : enterActiveClass;\n  var toClass = isAppear ? appearToClass : enterToClass;\n  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;\n  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;\n  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;\n  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl =\n    enterHook &&\n    // enterHook may be a bound method which exposes\n    // the length of original fn as _length\n    (enterHook._length || enterHook.length) > 1;\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n          pendingNode.context === vnode.context &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    }, 'transition-insert');\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        whenTransitionEnds(el, type, cb);\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (el._enterCb) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (el._leaveCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl =\n    leave &&\n    // leave hook may be a bound method which exposes\n    // the length of original fn as _length\n    (leave._length || leave.length) > 1;\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          whenTransitionEnds(el, type, cb);\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    leaveClass: (name + \"-leave\"),\n    appearClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    leaveToClass: (name + \"-leave-to\"),\n    appearToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveActiveClass: (name + \"-leave-active\"),\n    appearActiveClass: (name + \"-enter-active\")\n  }\n});\n\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn();\n    }\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (!vnode.data.show) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove (vnode, rm) {\n    /* istanbul ignore else */\n    if (!vnode.data.show) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\nvar modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model = {\n  inserted: function inserted (el, binding, vnode) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!modelableTagRE.test(vnode.tag)) {\n        warn(\n          \"v-model is not supported on element type: <\" + (vnode.tag) + \">. \" +\n          'If you are working with contenteditable, it\\'s recommended to ' +\n          'wrap a library dedicated for that purpose inside a custom component.',\n          vnode.context\n        );\n      }\n    }\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.child && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.child._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1].fn;\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  return /\\d-keep-alive$/.test(rawChild.tag)\n    ? h('keep-alive')\n    : null\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n        mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    var key = child.key = child.key == null || child.isStatic\n      ? (\"__v\" + (child.tag + this._uid) + \"__\")\n      : child.key;\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        }, key);\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave, key);\n        mergeVNodeHook(data, 'enterCancelled', performLeave, key);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        }, key);\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final disired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts\n            ? (opts.Ctor.options.name || opts.tag)\n            : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var f = document.body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      addTransitionClass(el, moveClass);\n      var info = getTransitionInfo(el);\n      removeTransitionClass(el, moveClass);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$2.config.isUnknownElement = isUnknownElement;\nVue$2.config.isReservedTag = isReservedTag;\nVue$2.config.getTagNamespace = getTagNamespace;\nVue$2.config.mustUseProp = mustUseProp;\n\n// install platform runtime directives & components\nextend(Vue$2.options.directives, platformDirectives);\nextend(Vue$2.options.components, platformComponents);\n\n// install platform patch function\nVue$2.prototype.__patch__ = inBrowser ? patch$1 : noop;\n\n// wrap mount\nVue$2.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return this._mount(el, hydrating)\n};\n\nif (process.env.NODE_ENV !== 'production' &&\n    inBrowser && typeof console !== 'undefined') {\n  console[console.info ? 'info' : 'log'](\n    \"You are running Vue in development mode.\\n\" +\n    \"Make sure to turn on production mode when deploying for production.\\n\" +\n    \"See more tips at https://vuejs.org/guide/deployment.html\"\n  );\n}\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$2);\n    } else if (\n      process.env.NODE_ENV !== 'production' &&\n      inBrowser && !isEdge && /Chrome\\/\\d+/.test(window.navigator.userAgent)\n    ) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n}, 0);\n\nmodule.exports = Vue$2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue/dist/vue.runtime.common.js\n// module id = 30\n// module chunks = 1","/**\n * vuex v2.1.1\n * (c) 2016 Evan You\n * @license MIT\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Vuex = factory());\n}(this, (function () { 'use strict';\n\nvar devtoolHook =\n  typeof window !== 'undefined' &&\n  window.__VUE_DEVTOOLS_GLOBAL_HOOK__\n\nfunction devtoolPlugin (store) {\n  if (!devtoolHook) { return }\n\n  store._devtoolHook = devtoolHook\n\n  devtoolHook.emit('vuex:init', store)\n\n  devtoolHook.on('vuex:travel-to-state', function (targetState) {\n    store.replaceState(targetState)\n  })\n\n  store.subscribe(function (mutation, state) {\n    devtoolHook.emit('vuex:mutation', mutation, state)\n  })\n}\n\nfunction applyMixin (Vue) {\n  var version = Number(Vue.version.split('.')[0])\n\n  if (version >= 2) {\n    var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1\n    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit })\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    var _init = Vue.prototype._init\n    Vue.prototype._init = function (options) {\n      if ( options === void 0 ) options = {};\n\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n      _init.call(this, options)\n    }\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit () {\n    var options = this.$options\n    // store injection\n    if (options.store) {\n      this.$store = options.store\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store\n    }\n  }\n}\n\nvar mapState = normalizeNamespace(function (namespace, states) {\n  var res = {}\n  normalizeMap(states).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedState () {\n      var state = this.$store.state\n      var getters = this.$store.getters\n      if (namespace) {\n        var module = this.$store._modulesNamespaceMap[namespace]\n        if (!module) {\n          warnNamespace('mapState', namespace)\n          return\n        }\n        state = module.state\n        getters = module.context.getters\n      }\n      return typeof val === 'function'\n        ? val.call(this, state, getters)\n        : state[val]\n    }\n  })\n  return res\n})\n\nvar mapMutations = normalizeNamespace(function (namespace, mutations) {\n  var res = {}\n  normalizeMap(mutations).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val\n    res[key] = function mappedMutation () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      return this.$store.commit.apply(this.$store, [val].concat(args))\n    }\n  })\n  return res\n})\n\nvar mapGetters = normalizeNamespace(function (namespace, getters) {\n  var res = {}\n  normalizeMap(getters).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val\n    res[key] = function mappedGetter () {\n      if (!(val in this.$store.getters)) {\n        console.error((\"[vuex] unknown getter: \" + val))\n      }\n      return this.$store.getters[val]\n    }\n  })\n  return res\n})\n\nvar mapActions = normalizeNamespace(function (namespace, actions) {\n  var res = {}\n  normalizeMap(actions).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val\n    res[key] = function mappedAction () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      return this.$store.dispatch.apply(this.$store, [val].concat(args))\n    }\n  })\n  return res\n})\n\nfunction normalizeMap (map) {\n  return Array.isArray(map)\n    ? map.map(function (key) { return ({ key: key, val: key }); })\n    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })\n}\n\nfunction normalizeNamespace (fn) {\n  return function (namespace, map) {\n    if (typeof namespace !== 'string') {\n      map = namespace\n      namespace = ''\n    } else if (namespace.charAt(namespace.length - 1) !== '/') {\n      namespace += '/'\n    }\n    return fn(namespace, map)\n  }\n}\n\nfunction warnNamespace (helper, namespace) {\n  console.error((\"[vuex] module namespace not found in \" + helper + \"(): \" + namespace))\n}\n\n/**\n * forEach for object\n */\nfunction forEachValue (obj, fn) {\n  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); })\n}\n\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nfunction isPromise (val) {\n  return val && typeof val.then === 'function'\n}\n\nfunction assert (condition, msg) {\n  if (!condition) { throw new Error((\"[vuex] \" + msg)) }\n}\n\nvar Module = function Module (rawModule, runtime) {\n  this.runtime = runtime\n  this._children = Object.create(null)\n  this._rawModule = rawModule\n};\n\nvar prototypeAccessors$1 = { state: {},namespaced: {} };\n\nprototypeAccessors$1.state.get = function () {\n  return this._rawModule.state || {}\n};\n\nprototypeAccessors$1.namespaced.get = function () {\n  return !!this._rawModule.namespaced\n};\n\nModule.prototype.addChild = function addChild (key, module) {\n  this._children[key] = module\n};\n\nModule.prototype.removeChild = function removeChild (key) {\n  delete this._children[key]\n};\n\nModule.prototype.getChild = function getChild (key) {\n  return this._children[key]\n};\n\nModule.prototype.update = function update (rawModule) {\n  this._rawModule.namespaced = rawModule.namespaced\n  if (rawModule.actions) {\n    this._rawModule.actions = rawModule.actions\n  }\n  if (rawModule.mutations) {\n    this._rawModule.mutations = rawModule.mutations\n  }\n  if (rawModule.getters) {\n    this._rawModule.getters = rawModule.getters\n  }\n};\n\nModule.prototype.forEachChild = function forEachChild (fn) {\n  forEachValue(this._children, fn)\n};\n\nModule.prototype.forEachGetter = function forEachGetter (fn) {\n  if (this._rawModule.getters) {\n    forEachValue(this._rawModule.getters, fn)\n  }\n};\n\nModule.prototype.forEachAction = function forEachAction (fn) {\n  if (this._rawModule.actions) {\n    forEachValue(this._rawModule.actions, fn)\n  }\n};\n\nModule.prototype.forEachMutation = function forEachMutation (fn) {\n  if (this._rawModule.mutations) {\n    forEachValue(this._rawModule.mutations, fn)\n  }\n};\n\nObject.defineProperties( Module.prototype, prototypeAccessors$1 );\n\nvar ModuleCollection = function ModuleCollection (rawRootModule) {\n  var this$1 = this;\n\n  // register root module (Vuex.Store options)\n  this.root = new Module(rawRootModule, false)\n\n  // register all nested modules\n  if (rawRootModule.modules) {\n    forEachValue(rawRootModule.modules, function (rawModule, key) {\n      this$1.register([key], rawModule, false)\n    })\n  }\n};\n\nModuleCollection.prototype.get = function get (path) {\n  return path.reduce(function (module, key) {\n    return module.getChild(key)\n  }, this.root)\n};\n\nModuleCollection.prototype.getNamespace = function getNamespace (path) {\n  var module = this.root\n  return path.reduce(function (namespace, key) {\n    module = module.getChild(key)\n    return namespace + (module.namespaced ? key + '/' : '')\n  }, '')\n};\n\nModuleCollection.prototype.update = function update$1 (rawRootModule) {\n  update(this.root, rawRootModule)\n};\n\nModuleCollection.prototype.register = function register (path, rawModule, runtime) {\n    var this$1 = this;\n    if ( runtime === void 0 ) runtime = true;\n\n  var parent = this.get(path.slice(0, -1))\n  var newModule = new Module(rawModule, runtime)\n  parent.addChild(path[path.length - 1], newModule)\n\n  // register nested modules\n  if (rawModule.modules) {\n    forEachValue(rawModule.modules, function (rawChildModule, key) {\n      this$1.register(path.concat(key), rawChildModule, runtime)\n    })\n  }\n};\n\nModuleCollection.prototype.unregister = function unregister (path) {\n  var parent = this.get(path.slice(0, -1))\n  var key = path[path.length - 1]\n  if (!parent.getChild(key).runtime) { return }\n\n  parent.removeChild(key)\n};\n\nfunction update (targetModule, newModule) {\n  // update target module\n  targetModule.update(newModule)\n\n  // update nested modules\n  if (newModule.modules) {\n    for (var key in newModule.modules) {\n      if (!targetModule.getChild(key)) {\n        console.warn(\n          \"[vuex] trying to add a new module '\" + key + \"' on hot reloading, \" +\n          'manual reload is needed'\n        )\n        return\n      }\n      update(targetModule.getChild(key), newModule.modules[key])\n    }\n  }\n}\n\nvar Vue // bind on install\n\nvar Store = function Store (options) {\n  var this$1 = this;\n  if ( options === void 0 ) options = {};\n\n  assert(Vue, \"must call Vue.use(Vuex) before creating a store instance.\")\n  assert(typeof Promise !== 'undefined', \"vuex requires a Promise polyfill in this browser.\")\n\n  var state = options.state; if ( state === void 0 ) state = {};\n  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];\n  var strict = options.strict; if ( strict === void 0 ) strict = false;\n\n  // store internal state\n  this._committing = false\n  this._actions = Object.create(null)\n  this._mutations = Object.create(null)\n  this._wrappedGetters = Object.create(null)\n  this._modules = new ModuleCollection(options)\n  this._modulesNamespaceMap = Object.create(null)\n  this._subscribers = []\n  this._watcherVM = new Vue()\n\n  // bind commit and dispatch to self\n  var store = this\n  var ref = this;\n  var dispatch = ref.dispatch;\n  var commit = ref.commit;\n    this.dispatch = function boundDispatch (type, payload) {\n    return dispatch.call(store, type, payload)\n  }\n  this.commit = function boundCommit (type, payload, options) {\n    return commit.call(store, type, payload, options)\n    }\n\n    // strict mode\n  this.strict = strict\n\n  // init root module.\n  // this also recursively registers all sub-modules\n  // and collects all module getters inside this._wrappedGetters\n  installModule(this, state, [], this._modules.root)\n\n  // initialize the store vm, which is responsible for the reactivity\n  // (also registers _wrappedGetters as computed properties)\n  resetStoreVM(this, state)\n\n  // apply plugins\n  plugins.concat(devtoolPlugin).forEach(function (plugin) { return plugin(this$1); })\n};\n\nvar prototypeAccessors = { state: {} };\n\nprototypeAccessors.state.get = function () {\n  return this._vm.$data.state\n};\n\nprototypeAccessors.state.set = function (v) {\n  assert(false, \"Use store.replaceState() to explicit replace store state.\")\n};\n\nStore.prototype.commit = function commit (_type, _payload, _options) {\n    var this$1 = this;\n\n  // check object-style commit\n  var ref = unifyObjectStyle(_type, _payload, _options);\n    var type = ref.type;\n    var payload = ref.payload;\n    var options = ref.options;\n\n  var mutation = { type: type, payload: payload }\n  var entry = this._mutations[type]\n  if (!entry) {\n    console.error((\"[vuex] unknown mutation type: \" + type))\n    return\n  }\n  this._withCommit(function () {\n    entry.forEach(function commitIterator (handler) {\n      handler(payload)\n    })\n  })\n  this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); })\n\n  if (options && options.silent) {\n    console.warn(\n      \"[vuex] mutation type: \" + type + \". Silent option has been removed. \" +\n      'Use the filter functionality in the vue-devtools'\n    )\n  }\n};\n\nStore.prototype.dispatch = function dispatch (_type, _payload) {\n  // check object-style dispatch\n  var ref = unifyObjectStyle(_type, _payload);\n    var type = ref.type;\n    var payload = ref.payload;\n\n  var entry = this._actions[type]\n  if (!entry) {\n    console.error((\"[vuex] unknown action type: \" + type))\n    return\n  }\n  return entry.length > 1\n    ? Promise.all(entry.map(function (handler) { return handler(payload); }))\n    : entry[0](payload)\n};\n\nStore.prototype.subscribe = function subscribe (fn) {\n  var subs = this._subscribers\n  if (subs.indexOf(fn) < 0) {\n    subs.push(fn)\n  }\n  return function () {\n    var i = subs.indexOf(fn)\n    if (i > -1) {\n      subs.splice(i, 1)\n    }\n  }\n};\n\nStore.prototype.watch = function watch (getter, cb, options) {\n    var this$1 = this;\n\n  assert(typeof getter === 'function', \"store.watch only accepts a function.\")\n  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)\n};\n\nStore.prototype.replaceState = function replaceState (state) {\n    var this$1 = this;\n\n  this._withCommit(function () {\n    this$1._vm.state = state\n  })\n};\n\nStore.prototype.registerModule = function registerModule (path, rawModule) {\n  if (typeof path === 'string') { path = [path] }\n  assert(Array.isArray(path), \"module path must be a string or an Array.\")\n  this._modules.register(path, rawModule)\n  installModule(this, this.state, path, this._modules.get(path))\n  // reset store to update getters...\n  resetStoreVM(this, this.state)\n};\n\nStore.prototype.unregisterModule = function unregisterModule (path) {\n    var this$1 = this;\n\n  if (typeof path === 'string') { path = [path] }\n  assert(Array.isArray(path), \"module path must be a string or an Array.\")\n    this._modules.unregister(path)\n  this._withCommit(function () {\n    var parentState = getNestedState(this$1.state, path.slice(0, -1))\n    Vue.delete(parentState, path[path.length - 1])\n  })\n  resetStore(this)\n};\n\nStore.prototype.hotUpdate = function hotUpdate (newOptions) {\n  this._modules.update(newOptions)\n  resetStore(this)\n};\n\nStore.prototype._withCommit = function _withCommit (fn) {\n  var committing = this._committing\n  this._committing = true\n  fn()\n  this._committing = committing\n};\n\nObject.defineProperties( Store.prototype, prototypeAccessors );\n\nfunction resetStore (store) {\n  store._actions = Object.create(null)\n  store._mutations = Object.create(null)\n  store._wrappedGetters = Object.create(null)\n  store._modulesNamespaceMap = Object.create(null)\n  var state = store.state\n  // init all modules\n  installModule(store, state, [], store._modules.root, true)\n  // reset vm\n  resetStoreVM(store, state)\n}\n\nfunction resetStoreVM (store, state) {\n  var oldVm = store._vm\n\n  // bind store public getters\n  store.getters = {}\n  var wrappedGetters = store._wrappedGetters\n  var computed = {}\n  forEachValue(wrappedGetters, function (fn, key) {\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = function () { return fn(store); }\n    Object.defineProperty(store.getters, key, {\n      get: function () { return store._vm[key]; },\n      enumerable: true // for local getters\n    })\n  })\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  var silent = Vue.config.silent\n  Vue.config.silent = true\n  store._vm = new Vue({\n    data: { state: state },\n    computed: computed\n  })\n  Vue.config.silent = silent\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store)\n  }\n\n  if (oldVm) {\n    // dispatch changes in all subscribed watchers\n    // to force getter re-evaluation.\n    store._withCommit(function () {\n      oldVm.state = null\n    })\n    Vue.nextTick(function () { return oldVm.$destroy(); })\n  }\n}\n\nfunction installModule (store, rootState, path, module, hot) {\n  var isRoot = !path.length\n  var namespace = store._modules.getNamespace(path)\n\n  // register in namespace map\n  if (namespace) {\n    store._modulesNamespaceMap[namespace] = module\n  }\n\n  // set state\n  if (!isRoot && !hot) {\n    var parentState = getNestedState(rootState, path.slice(0, -1))\n    var moduleName = path[path.length - 1]\n    store._withCommit(function () {\n      Vue.set(parentState, moduleName, module.state)\n    })\n  }\n\n  var local = module.context = makeLocalContext(store, namespace)\n\n  module.forEachMutation(function (mutation, key) {\n    var namespacedType = namespace + key\n    registerMutation(store, namespacedType, mutation, path)\n  })\n\n  module.forEachAction(function (action, key) {\n    var namespacedType = namespace + key\n    registerAction(store, namespacedType, action, local, path)\n  })\n\n  module.forEachGetter(function (getter, key) {\n    var namespacedType = namespace + key\n    registerGetter(store, namespacedType, getter, local, path)\n  })\n\n  module.forEachChild(function (child, key) {\n    installModule(store, rootState, path.concat(key), child, hot)\n  })\n}\n\n/**\n * make localized dispatch, commit and getters\n * if there is no namespace, just use root ones\n */\nfunction makeLocalContext (store, namespace) {\n  var noNamespace = namespace === ''\n\n  var local = {\n    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options)\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type\n        if (!store._actions[type]) {\n          console.error((\"[vuex] unknown local action type: \" + (args.type) + \", global type: \" + type))\n          return\n        }\n      }\n\n      return store.dispatch(type, payload)\n    },\n\n    commit: noNamespace ? store.commit : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options)\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type\n        if (!store._mutations[type]) {\n          console.error((\"[vuex] unknown local mutation type: \" + (args.type) + \", global type: \" + type))\n          return\n        }\n      }\n\n      store.commit(type, payload, options)\n    }\n  }\n\n  // getters object must be gotten lazily\n  // because store.getters will be changed by vm update\n  Object.defineProperty(local, 'getters', {\n    get: noNamespace ? function () { return store.getters; } : function () { return makeLocalGetters(store, namespace); }\n  })\n\n  return local\n}\n\nfunction makeLocalGetters (store, namespace) {\n  var gettersProxy = {}\n\n  var splitPos = namespace.length\n  Object.keys(store.getters).forEach(function (type) {\n    // skip if the target getter is not match this namespace\n    if (type.slice(0, splitPos) !== namespace) { return }\n\n    // extract local getter type\n    var localType = type.slice(splitPos)\n\n    // Add a port to the getters proxy.\n    // Define as getter property because\n    // we do not want to evaluate the getters in this time.\n    Object.defineProperty(gettersProxy, localType, {\n      get: function () { return store.getters[type]; },\n      enumerable: true\n    })\n  })\n\n  return gettersProxy\n}\n\nfunction registerMutation (store, type, handler, path) {\n  var entry = store._mutations[type] || (store._mutations[type] = [])\n  entry.push(function wrappedMutationHandler (payload) {\n    handler(getNestedState(store.state, path), payload)\n  })\n}\n\nfunction registerAction (store, type, handler, local, path) {\n  var entry = store._actions[type] || (store._actions[type] = [])\n  entry.push(function wrappedActionHandler (payload, cb) {\n    var res = handler({\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: getNestedState(store.state, path),\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb)\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(function (err) {\n        store._devtoolHook.emit('vuex:error', err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  })\n}\n\nfunction registerGetter (store, type, rawGetter, local, path) {\n  if (store._wrappedGetters[type]) {\n    console.error((\"[vuex] duplicate getter key: \" + type))\n    return\n  }\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    return rawGetter(\n      getNestedState(store.state, path), // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  }\n}\n\nfunction enableStrictMode (store) {\n  store._vm.$watch('state', function () {\n    assert(store._committing, \"Do not mutate vuex store state outside mutation handlers.\")\n  }, { deep: true, sync: true })\n}\n\nfunction getNestedState (state, path) {\n  return path.length\n    ? path.reduce(function (state, key) { return state[key]; }, state)\n    : state\n}\n\nfunction unifyObjectStyle (type, payload, options) {\n  if (isObject(type) && type.type) {\n    options = payload\n    payload = type\n    type = type.type\n  }\n  return { type: type, payload: payload, options: options }\n}\n\nfunction install (_Vue) {\n  if (Vue) {\n    console.error(\n      '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n    )\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n\n// auto install in dist mode\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n\nvar index = {\n  Store: Store,\n  install: install,\n  version: '2.1.1',\n  mapState: mapState,\n  mapMutations: mapMutations,\n  mapGetters: mapGetters,\n  mapActions: mapActions\n}\n\nreturn index;\n\n})));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vuex/dist/vuex.js\n// module id = 31\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/array/from\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/array/from.js\n// module id = 36\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/object/assign\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/assign.js\n// module id = 37\n// module chunks = 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _from = require(\"../core-js/array/from\");\n\nvar _from2 = _interopRequireDefault(_from);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return (0, _from2.default)(arr);\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/toConsumableArray.js\n// module id = 38\n// module chunks = 1","require('../../modules/es6.string.iterator');\nrequire('../../modules/es6.array.from');\nmodule.exports = require('../../modules/_core').Array.from;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/array/from.js\n// module id = 39\n// module chunks = 1","require('../../modules/es6.object.assign');\nmodule.exports = require('../../modules/_core').Object.assign;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/assign.js\n// module id = 40\n// module chunks = 1","module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_a-function.js\n// module id = 41\n// module chunks = 1","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length')\n  , toIndex   = require('./_to-index');\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_array-includes.js\n// module id = 42\n// module chunks = 1","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof')\n  , TAG = require('./_wks')('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key){\n  try {\n    return it[key];\n  } catch(e){ /* empty */ }\n};\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_classof.js\n// module id = 43\n// module chunks = 1","'use strict';\nvar $defineProperty = require('./_object-dp')\n  , createDesc      = require('./_property-desc');\n\nmodule.exports = function(object, index, value){\n  if(index in object)$defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_create-property.js\n// module id = 44\n// module chunks = 1","module.exports = require('./_global').document && document.documentElement;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_html.js\n// module id = 45\n// module chunks = 1","module.exports = !require('./_descriptors') && !require('./_fails')(function(){\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_ie8-dom-define.js\n// module id = 46\n// module chunks = 1","// check on default Array iterator\nvar Iterators  = require('./_iterators')\n  , ITERATOR   = require('./_wks')('iterator')\n  , ArrayProto = Array.prototype;\n\nmodule.exports = function(it){\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_is-array-iter.js\n// module id = 47\n// module chunks = 1","// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function(iterator, fn, value, entries){\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch(e){\n    var ret = iterator['return'];\n    if(ret !== undefined)anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-call.js\n// module id = 48\n// module chunks = 1","'use strict';\nvar create         = require('./_object-create')\n  , descriptor     = require('./_property-desc')\n  , setToStringTag = require('./_set-to-string-tag')\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-create.js\n// module id = 49\n// module chunks = 1","'use strict';\nvar LIBRARY        = require('./_library')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , hide           = require('./_hide')\n  , has            = require('./_has')\n  , Iterators      = require('./_iterators')\n  , $iterCreate    = require('./_iter-create')\n  , setToStringTag = require('./_set-to-string-tag')\n  , getPrototypeOf = require('./_object-gpo')\n  , ITERATOR       = require('./_wks')('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-define.js\n// module id = 50\n// module chunks = 1","var ITERATOR     = require('./_wks')('iterator')\n  , SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function(){ SAFE_CLOSING = true; };\n  Array.from(riter, function(){ throw 2; });\n} catch(e){ /* empty */ }\n\nmodule.exports = function(exec, skipClosing){\n  if(!skipClosing && !SAFE_CLOSING)return false;\n  var safe = false;\n  try {\n    var arr  = [7]\n      , iter = arr[ITERATOR]();\n    iter.next = function(){ return {done: safe = true}; };\n    arr[ITERATOR] = function(){ return iter; };\n    exec(arr);\n  } catch(e){ /* empty */ }\n  return safe;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-detect.js\n// module id = 51\n// module chunks = 1","module.exports = true;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_library.js\n// module id = 52\n// module chunks = 1","'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys  = require('./_object-keys')\n  , gOPS     = require('./_object-gops')\n  , pIE      = require('./_object-pie')\n  , toObject = require('./_to-object')\n  , IObject  = require('./_iobject')\n  , $assign  = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || require('./_fails')(function(){\n  var A = {}\n    , B = {}\n    , S = Symbol()\n    , K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function(k){ B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n  var T     = toObject(target)\n    , aLen  = arguments.length\n    , index = 1\n    , getSymbols = gOPS.f\n    , isEnum     = pIE.f;\n  while(aLen > index){\n    var S      = IObject(arguments[index++])\n      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n      , length = keys.length\n      , j      = 0\n      , key;\n    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n  } return T;\n} : $assign;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-assign.js\n// module id = 53\n// module chunks = 1","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject    = require('./_an-object')\n  , dPs         = require('./_object-dps')\n  , enumBugKeys = require('./_enum-bug-keys')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , Empty       = function(){ /* empty */ }\n  , PROTOTYPE   = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe')\n    , i      = enumBugKeys.length\n    , lt     = '<'\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties){\n  var result;\n  if(O !== null){\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty;\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-create.js\n// module id = 54\n// module chunks = 1","var dP       = require('./_object-dp')\n  , anObject = require('./_an-object')\n  , getKeys  = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){\n  anObject(O);\n  var keys   = getKeys(Properties)\n    , length = keys.length\n    , i = 0\n    , P;\n  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-dps.js\n// module id = 55\n// module chunks = 1","exports.f = Object.getOwnPropertySymbols;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gops.js\n// module id = 56\n// module chunks = 1","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has         = require('./_has')\n  , toObject    = require('./_to-object')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function(O){\n  O = toObject(O);\n  if(has(O, IE_PROTO))return O[IE_PROTO];\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gpo.js\n// module id = 57\n// module chunks = 1","var has          = require('./_has')\n  , toIObject    = require('./_to-iobject')\n  , arrayIndexOf = require('./_array-includes')(false)\n  , IE_PROTO     = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function(object, names){\n  var O      = toIObject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-keys-internal.js\n// module id = 58\n// module chunks = 1","exports.f = {}.propertyIsEnumerable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-pie.js\n// module id = 59\n// module chunks = 1","module.exports = require('./_hide');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_redefine.js\n// module id = 60\n// module chunks = 1","var toInteger = require('./_to-integer')\n  , defined   = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_string-at.js\n// module id = 61\n// module chunks = 1","var toInteger = require('./_to-integer')\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-index.js\n// module id = 62\n// module chunks = 1","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-primitive.js\n// module id = 63\n// module chunks = 1","var classof   = require('./_classof')\n  , ITERATOR  = require('./_wks')('iterator')\n  , Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/core.get-iterator-method.js\n// module id = 64\n// module chunks = 1","'use strict';\nvar ctx            = require('./_ctx')\n  , $export        = require('./_export')\n  , toObject       = require('./_to-object')\n  , call           = require('./_iter-call')\n  , isArrayIter    = require('./_is-array-iter')\n  , toLength       = require('./_to-length')\n  , createProperty = require('./_create-property')\n  , getIterFn      = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function(iter){ Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\n    var O       = toObject(arrayLike)\n      , C       = typeof this == 'function' ? this : Array\n      , aLen    = arguments.length\n      , mapfn   = aLen > 1 ? arguments[1] : undefined\n      , mapping = mapfn !== undefined\n      , index   = 0\n      , iterFn  = getIterFn(O)\n      , length, result, step, iterator;\n    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){\n      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for(result = new C(length); length > index; index++){\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.array.from.js\n// module id = 65\n// module chunks = 1","// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.assign.js\n// module id = 66\n// module chunks = 1","'use strict';\nvar $at  = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.string.iterator.js\n// module id = 67\n// module chunks = 1","// Fine Uploader 5.11.10 - (c) 2013-present Widen Enterprises, Inc. MIT licensed. http://fineuploader.com\n(function(global) {\n    var qq = function(element) {\n        \"use strict\";\n        return {\n            hide: function() {\n                element.style.display = \"none\";\n                return this;\n            },\n            attach: function(type, fn) {\n                if (element.addEventListener) {\n                    element.addEventListener(type, fn, false);\n                } else if (element.attachEvent) {\n                    element.attachEvent(\"on\" + type, fn);\n                }\n                return function() {\n                    qq(element).detach(type, fn);\n                };\n            },\n            detach: function(type, fn) {\n                if (element.removeEventListener) {\n                    element.removeEventListener(type, fn, false);\n                } else if (element.attachEvent) {\n                    element.detachEvent(\"on\" + type, fn);\n                }\n                return this;\n            },\n            contains: function(descendant) {\n                if (!descendant) {\n                    return false;\n                }\n                if (element === descendant) {\n                    return true;\n                }\n                if (element.contains) {\n                    return element.contains(descendant);\n                } else {\n                    return !!(descendant.compareDocumentPosition(element) & 8);\n                }\n            },\n            insertBefore: function(elementB) {\n                elementB.parentNode.insertBefore(element, elementB);\n                return this;\n            },\n            remove: function() {\n                element.parentNode.removeChild(element);\n                return this;\n            },\n            css: function(styles) {\n                if (element.style == null) {\n                    throw new qq.Error(\"Can't apply style to node as it is not on the HTMLElement prototype chain!\");\n                }\n                if (styles.opacity != null) {\n                    if (typeof element.style.opacity !== \"string\" && typeof element.filters !== \"undefined\") {\n                        styles.filter = \"alpha(opacity=\" + Math.round(100 * styles.opacity) + \")\";\n                    }\n                }\n                qq.extend(element.style, styles);\n                return this;\n            },\n            hasClass: function(name, considerParent) {\n                var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n                return re.test(element.className) || !!(considerParent && re.test(element.parentNode.className));\n            },\n            addClass: function(name) {\n                if (!qq(element).hasClass(name)) {\n                    element.className += \" \" + name;\n                }\n                return this;\n            },\n            removeClass: function(name) {\n                var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n                element.className = element.className.replace(re, \" \").replace(/^\\s+|\\s+$/g, \"\");\n                return this;\n            },\n            getByClass: function(className, first) {\n                var candidates, result = [];\n                if (first && element.querySelector) {\n                    return element.querySelector(\".\" + className);\n                } else if (element.querySelectorAll) {\n                    return element.querySelectorAll(\".\" + className);\n                }\n                candidates = element.getElementsByTagName(\"*\");\n                qq.each(candidates, function(idx, val) {\n                    if (qq(val).hasClass(className)) {\n                        result.push(val);\n                    }\n                });\n                return first ? result[0] : result;\n            },\n            getFirstByClass: function(className) {\n                return qq(element).getByClass(className, true);\n            },\n            children: function() {\n                var children = [], child = element.firstChild;\n                while (child) {\n                    if (child.nodeType === 1) {\n                        children.push(child);\n                    }\n                    child = child.nextSibling;\n                }\n                return children;\n            },\n            setText: function(text) {\n                element.innerText = text;\n                element.textContent = text;\n                return this;\n            },\n            clearText: function() {\n                return qq(element).setText(\"\");\n            },\n            hasAttribute: function(attrName) {\n                var attrVal;\n                if (element.hasAttribute) {\n                    if (!element.hasAttribute(attrName)) {\n                        return false;\n                    }\n                    return /^false$/i.exec(element.getAttribute(attrName)) == null;\n                } else {\n                    attrVal = element[attrName];\n                    if (attrVal === undefined) {\n                        return false;\n                    }\n                    return /^false$/i.exec(attrVal) == null;\n                }\n            }\n        };\n    };\n    (function() {\n        \"use strict\";\n        qq.canvasToBlob = function(canvas, mime, quality) {\n            return qq.dataUriToBlob(canvas.toDataURL(mime, quality));\n        };\n        qq.dataUriToBlob = function(dataUri) {\n            var arrayBuffer, byteString, createBlob = function(data, mime) {\n                var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, blobBuilder = BlobBuilder && new BlobBuilder();\n                if (blobBuilder) {\n                    blobBuilder.append(data);\n                    return blobBuilder.getBlob(mime);\n                } else {\n                    return new Blob([ data ], {\n                        type: mime\n                    });\n                }\n            }, intArray, mimeString;\n            if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n                byteString = atob(dataUri.split(\",\")[1]);\n            } else {\n                byteString = decodeURI(dataUri.split(\",\")[1]);\n            }\n            mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n            arrayBuffer = new ArrayBuffer(byteString.length);\n            intArray = new Uint8Array(arrayBuffer);\n            qq.each(byteString, function(idx, character) {\n                intArray[idx] = character.charCodeAt(0);\n            });\n            return createBlob(arrayBuffer, mimeString);\n        };\n        qq.log = function(message, level) {\n            if (window.console) {\n                if (!level || level === \"info\") {\n                    window.console.log(message);\n                } else {\n                    if (window.console[level]) {\n                        window.console[level](message);\n                    } else {\n                        window.console.log(\"<\" + level + \"> \" + message);\n                    }\n                }\n            }\n        };\n        qq.isObject = function(variable) {\n            return variable && !variable.nodeType && Object.prototype.toString.call(variable) === \"[object Object]\";\n        };\n        qq.isFunction = function(variable) {\n            return typeof variable === \"function\";\n        };\n        qq.isArray = function(value) {\n            return Object.prototype.toString.call(value) === \"[object Array]\" || value && window.ArrayBuffer && value.buffer && value.buffer.constructor === ArrayBuffer;\n        };\n        qq.isItemList = function(maybeItemList) {\n            return Object.prototype.toString.call(maybeItemList) === \"[object DataTransferItemList]\";\n        };\n        qq.isNodeList = function(maybeNodeList) {\n            return Object.prototype.toString.call(maybeNodeList) === \"[object NodeList]\" || maybeNodeList.item && maybeNodeList.namedItem;\n        };\n        qq.isString = function(maybeString) {\n            return Object.prototype.toString.call(maybeString) === \"[object String]\";\n        };\n        qq.trimStr = function(string) {\n            if (String.prototype.trim) {\n                return string.trim();\n            }\n            return string.replace(/^\\s+|\\s+$/g, \"\");\n        };\n        qq.format = function(str) {\n            var args = Array.prototype.slice.call(arguments, 1), newStr = str, nextIdxToReplace = newStr.indexOf(\"{}\");\n            qq.each(args, function(idx, val) {\n                var strBefore = newStr.substring(0, nextIdxToReplace), strAfter = newStr.substring(nextIdxToReplace + 2);\n                newStr = strBefore + val + strAfter;\n                nextIdxToReplace = newStr.indexOf(\"{}\", nextIdxToReplace + val.length);\n                if (nextIdxToReplace < 0) {\n                    return false;\n                }\n            });\n            return newStr;\n        };\n        qq.isFile = function(maybeFile) {\n            return window.File && Object.prototype.toString.call(maybeFile) === \"[object File]\";\n        };\n        qq.isFileList = function(maybeFileList) {\n            return window.FileList && Object.prototype.toString.call(maybeFileList) === \"[object FileList]\";\n        };\n        qq.isFileOrInput = function(maybeFileOrInput) {\n            return qq.isFile(maybeFileOrInput) || qq.isInput(maybeFileOrInput);\n        };\n        qq.isInput = function(maybeInput, notFile) {\n            var evaluateType = function(type) {\n                var normalizedType = type.toLowerCase();\n                if (notFile) {\n                    return normalizedType !== \"file\";\n                }\n                return normalizedType === \"file\";\n            };\n            if (window.HTMLInputElement) {\n                if (Object.prototype.toString.call(maybeInput) === \"[object HTMLInputElement]\") {\n                    if (maybeInput.type && evaluateType(maybeInput.type)) {\n                        return true;\n                    }\n                }\n            }\n            if (maybeInput.tagName) {\n                if (maybeInput.tagName.toLowerCase() === \"input\") {\n                    if (maybeInput.type && evaluateType(maybeInput.type)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        qq.isBlob = function(maybeBlob) {\n            if (window.Blob && Object.prototype.toString.call(maybeBlob) === \"[object Blob]\") {\n                return true;\n            }\n        };\n        qq.isXhrUploadSupported = function() {\n            var input = document.createElement(\"input\");\n            input.type = \"file\";\n            return input.multiple !== undefined && typeof File !== \"undefined\" && typeof FormData !== \"undefined\" && typeof qq.createXhrInstance().upload !== \"undefined\";\n        };\n        qq.createXhrInstance = function() {\n            if (window.XMLHttpRequest) {\n                return new XMLHttpRequest();\n            }\n            try {\n                return new ActiveXObject(\"MSXML2.XMLHTTP.3.0\");\n            } catch (error) {\n                qq.log(\"Neither XHR or ActiveX are supported!\", \"error\");\n                return null;\n            }\n        };\n        qq.isFolderDropSupported = function(dataTransfer) {\n            return dataTransfer.items && dataTransfer.items.length > 0 && dataTransfer.items[0].webkitGetAsEntry;\n        };\n        qq.isFileChunkingSupported = function() {\n            return !qq.androidStock() && qq.isXhrUploadSupported() && (File.prototype.slice !== undefined || File.prototype.webkitSlice !== undefined || File.prototype.mozSlice !== undefined);\n        };\n        qq.sliceBlob = function(fileOrBlob, start, end) {\n            var slicer = fileOrBlob.slice || fileOrBlob.mozSlice || fileOrBlob.webkitSlice;\n            return slicer.call(fileOrBlob, start, end);\n        };\n        qq.arrayBufferToHex = function(buffer) {\n            var bytesAsHex = \"\", bytes = new Uint8Array(buffer);\n            qq.each(bytes, function(idx, byt) {\n                var byteAsHexStr = byt.toString(16);\n                if (byteAsHexStr.length < 2) {\n                    byteAsHexStr = \"0\" + byteAsHexStr;\n                }\n                bytesAsHex += byteAsHexStr;\n            });\n            return bytesAsHex;\n        };\n        qq.readBlobToHex = function(blob, startOffset, length) {\n            var initialBlob = qq.sliceBlob(blob, startOffset, startOffset + length), fileReader = new FileReader(), promise = new qq.Promise();\n            fileReader.onload = function() {\n                promise.success(qq.arrayBufferToHex(fileReader.result));\n            };\n            fileReader.onerror = promise.failure;\n            fileReader.readAsArrayBuffer(initialBlob);\n            return promise;\n        };\n        qq.extend = function(first, second, extendNested) {\n            qq.each(second, function(prop, val) {\n                if (extendNested && qq.isObject(val)) {\n                    if (first[prop] === undefined) {\n                        first[prop] = {};\n                    }\n                    qq.extend(first[prop], val, true);\n                } else {\n                    first[prop] = val;\n                }\n            });\n            return first;\n        };\n        qq.override = function(target, sourceFn) {\n            var super_ = {}, source = sourceFn(super_);\n            qq.each(source, function(srcPropName, srcPropVal) {\n                if (target[srcPropName] !== undefined) {\n                    super_[srcPropName] = target[srcPropName];\n                }\n                target[srcPropName] = srcPropVal;\n            });\n            return target;\n        };\n        qq.indexOf = function(arr, elt, from) {\n            if (arr.indexOf) {\n                return arr.indexOf(elt, from);\n            }\n            from = from || 0;\n            var len = arr.length;\n            if (from < 0) {\n                from += len;\n            }\n            for (;from < len; from += 1) {\n                if (arr.hasOwnProperty(from) && arr[from] === elt) {\n                    return from;\n                }\n            }\n            return -1;\n        };\n        qq.getUniqueId = function() {\n            return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n                var r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 3 | 8;\n                return v.toString(16);\n            });\n        };\n        qq.ie = function() {\n            return navigator.userAgent.indexOf(\"MSIE\") !== -1 || navigator.userAgent.indexOf(\"Trident\") !== -1;\n        };\n        qq.ie7 = function() {\n            return navigator.userAgent.indexOf(\"MSIE 7\") !== -1;\n        };\n        qq.ie8 = function() {\n            return navigator.userAgent.indexOf(\"MSIE 8\") !== -1;\n        };\n        qq.ie10 = function() {\n            return navigator.userAgent.indexOf(\"MSIE 10\") !== -1;\n        };\n        qq.ie11 = function() {\n            return qq.ie() && navigator.userAgent.indexOf(\"rv:11\") !== -1;\n        };\n        qq.edge = function() {\n            return navigator.userAgent.indexOf(\"Edge\") >= 0;\n        };\n        qq.safari = function() {\n            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Apple\") !== -1;\n        };\n        qq.chrome = function() {\n            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Google\") !== -1;\n        };\n        qq.opera = function() {\n            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Opera\") !== -1;\n        };\n        qq.firefox = function() {\n            return !qq.edge() && !qq.ie11() && navigator.userAgent.indexOf(\"Mozilla\") !== -1 && navigator.vendor !== undefined && navigator.vendor === \"\";\n        };\n        qq.windows = function() {\n            return navigator.platform === \"Win32\";\n        };\n        qq.android = function() {\n            return navigator.userAgent.toLowerCase().indexOf(\"android\") !== -1;\n        };\n        qq.androidStock = function() {\n            return qq.android() && navigator.userAgent.toLowerCase().indexOf(\"chrome\") < 0;\n        };\n        qq.ios6 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 6_\") !== -1;\n        };\n        qq.ios7 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 7_\") !== -1;\n        };\n        qq.ios8 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 8_\") !== -1;\n        };\n        qq.ios800 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 8_0 \") !== -1;\n        };\n        qq.ios = function() {\n            return navigator.userAgent.indexOf(\"iPad\") !== -1 || navigator.userAgent.indexOf(\"iPod\") !== -1 || navigator.userAgent.indexOf(\"iPhone\") !== -1;\n        };\n        qq.iosChrome = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\"CriOS\") !== -1;\n        };\n        qq.iosSafari = function() {\n            return qq.ios() && !qq.iosChrome() && navigator.userAgent.indexOf(\"Safari\") !== -1;\n        };\n        qq.iosSafariWebView = function() {\n            return qq.ios() && !qq.iosChrome() && !qq.iosSafari();\n        };\n        qq.preventDefault = function(e) {\n            if (e.preventDefault) {\n                e.preventDefault();\n            } else {\n                e.returnValue = false;\n            }\n        };\n        qq.toElement = function() {\n            var div = document.createElement(\"div\");\n            return function(html) {\n                div.innerHTML = html;\n                var element = div.firstChild;\n                div.removeChild(element);\n                return element;\n            };\n        }();\n        qq.each = function(iterableItem, callback) {\n            var keyOrIndex, retVal;\n            if (iterableItem) {\n                if (window.Storage && iterableItem.constructor === window.Storage) {\n                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                        retVal = callback(iterableItem.key(keyOrIndex), iterableItem.getItem(iterableItem.key(keyOrIndex)));\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                } else if (qq.isArray(iterableItem) || qq.isItemList(iterableItem) || qq.isNodeList(iterableItem)) {\n                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                        retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                } else if (qq.isString(iterableItem)) {\n                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                        retVal = callback(keyOrIndex, iterableItem.charAt(keyOrIndex));\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                } else {\n                    for (keyOrIndex in iterableItem) {\n                        if (Object.prototype.hasOwnProperty.call(iterableItem, keyOrIndex)) {\n                            retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n                            if (retVal === false) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        qq.bind = function(oldFunc, context) {\n            if (qq.isFunction(oldFunc)) {\n                var args = Array.prototype.slice.call(arguments, 2);\n                return function() {\n                    var newArgs = qq.extend([], args);\n                    if (arguments.length) {\n                        newArgs = newArgs.concat(Array.prototype.slice.call(arguments));\n                    }\n                    return oldFunc.apply(context, newArgs);\n                };\n            }\n            throw new Error(\"first parameter must be a function!\");\n        };\n        qq.obj2url = function(obj, temp, prefixDone) {\n            var uristrings = [], prefix = \"&\", add = function(nextObj, i) {\n                var nextTemp = temp ? /\\[\\]$/.test(temp) ? temp : temp + \"[\" + i + \"]\" : i;\n                if (nextTemp !== \"undefined\" && i !== \"undefined\") {\n                    uristrings.push(typeof nextObj === \"object\" ? qq.obj2url(nextObj, nextTemp, true) : Object.prototype.toString.call(nextObj) === \"[object Function]\" ? encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj()) : encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj));\n                }\n            };\n            if (!prefixDone && temp) {\n                prefix = /\\?/.test(temp) ? /\\?$/.test(temp) ? \"\" : \"&\" : \"?\";\n                uristrings.push(temp);\n                uristrings.push(qq.obj2url(obj));\n            } else if (Object.prototype.toString.call(obj) === \"[object Array]\" && typeof obj !== \"undefined\") {\n                qq.each(obj, function(idx, val) {\n                    add(val, idx);\n                });\n            } else if (typeof obj !== \"undefined\" && obj !== null && typeof obj === \"object\") {\n                qq.each(obj, function(prop, val) {\n                    add(val, prop);\n                });\n            } else {\n                uristrings.push(encodeURIComponent(temp) + \"=\" + encodeURIComponent(obj));\n            }\n            if (temp) {\n                return uristrings.join(prefix);\n            } else {\n                return uristrings.join(prefix).replace(/^&/, \"\").replace(/%20/g, \"+\");\n            }\n        };\n        qq.obj2FormData = function(obj, formData, arrayKeyName) {\n            if (!formData) {\n                formData = new FormData();\n            }\n            qq.each(obj, function(key, val) {\n                key = arrayKeyName ? arrayKeyName + \"[\" + key + \"]\" : key;\n                if (qq.isObject(val)) {\n                    qq.obj2FormData(val, formData, key);\n                } else if (qq.isFunction(val)) {\n                    formData.append(key, val());\n                } else {\n                    formData.append(key, val);\n                }\n            });\n            return formData;\n        };\n        qq.obj2Inputs = function(obj, form) {\n            var input;\n            if (!form) {\n                form = document.createElement(\"form\");\n            }\n            qq.obj2FormData(obj, {\n                append: function(key, val) {\n                    input = document.createElement(\"input\");\n                    input.setAttribute(\"name\", key);\n                    input.setAttribute(\"value\", val);\n                    form.appendChild(input);\n                }\n            });\n            return form;\n        };\n        qq.parseJson = function(json) {\n            if (window.JSON && qq.isFunction(JSON.parse)) {\n                return JSON.parse(json);\n            } else {\n                return eval(\"(\" + json + \")\");\n            }\n        };\n        qq.getExtension = function(filename) {\n            var extIdx = filename.lastIndexOf(\".\") + 1;\n            if (extIdx > 0) {\n                return filename.substr(extIdx, filename.length - extIdx);\n            }\n        };\n        qq.getFilename = function(blobOrFileInput) {\n            if (qq.isInput(blobOrFileInput)) {\n                return blobOrFileInput.value.replace(/.*(\\/|\\\\)/, \"\");\n            } else if (qq.isFile(blobOrFileInput)) {\n                if (blobOrFileInput.fileName !== null && blobOrFileInput.fileName !== undefined) {\n                    return blobOrFileInput.fileName;\n                }\n            }\n            return blobOrFileInput.name;\n        };\n        qq.DisposeSupport = function() {\n            var disposers = [];\n            return {\n                dispose: function() {\n                    var disposer;\n                    do {\n                        disposer = disposers.shift();\n                        if (disposer) {\n                            disposer();\n                        }\n                    } while (disposer);\n                },\n                attach: function() {\n                    var args = arguments;\n                    this.addDisposer(qq(args[0]).attach.apply(this, Array.prototype.slice.call(arguments, 1)));\n                },\n                addDisposer: function(disposeFunction) {\n                    disposers.push(disposeFunction);\n                }\n            };\n        };\n    })();\n    (function() {\n        \"use strict\";\n        if (typeof define === \"function\" && define.amd) {\n            define(function() {\n                return qq;\n            });\n        } else if (typeof module !== \"undefined\" && module.exports) {\n            module.exports = qq;\n        } else {\n            global.qq = qq;\n        }\n    })();\n    (function() {\n        \"use strict\";\n        qq.Error = function(message) {\n            this.message = \"[Fine Uploader \" + qq.version + \"] \" + message;\n        };\n        qq.Error.prototype = new Error();\n    })();\n    qq.version = \"5.11.10\";\n    qq.supportedFeatures = function() {\n        \"use strict\";\n        var supportsUploading, supportsUploadingBlobs, supportsFileDrop, supportsAjaxFileUploading, supportsFolderDrop, supportsChunking, supportsResume, supportsUploadViaPaste, supportsUploadCors, supportsDeleteFileXdr, supportsDeleteFileCorsXhr, supportsDeleteFileCors, supportsFolderSelection, supportsImagePreviews, supportsUploadProgress;\n        function testSupportsFileInputElement() {\n            var supported = true, tempInput;\n            try {\n                tempInput = document.createElement(\"input\");\n                tempInput.type = \"file\";\n                qq(tempInput).hide();\n                if (tempInput.disabled) {\n                    supported = false;\n                }\n            } catch (ex) {\n                supported = false;\n            }\n            return supported;\n        }\n        function isChrome21OrHigher() {\n            return (qq.chrome() || qq.opera()) && navigator.userAgent.match(/Chrome\\/[2][1-9]|Chrome\\/[3-9][0-9]/) !== undefined;\n        }\n        function isChrome14OrHigher() {\n            return (qq.chrome() || qq.opera()) && navigator.userAgent.match(/Chrome\\/[1][4-9]|Chrome\\/[2-9][0-9]/) !== undefined;\n        }\n        function isCrossOriginXhrSupported() {\n            if (window.XMLHttpRequest) {\n                var xhr = qq.createXhrInstance();\n                return xhr.withCredentials !== undefined;\n            }\n            return false;\n        }\n        function isXdrSupported() {\n            return window.XDomainRequest !== undefined;\n        }\n        function isCrossOriginAjaxSupported() {\n            if (isCrossOriginXhrSupported()) {\n                return true;\n            }\n            return isXdrSupported();\n        }\n        function isFolderSelectionSupported() {\n            return document.createElement(\"input\").webkitdirectory !== undefined;\n        }\n        function isLocalStorageSupported() {\n            try {\n                return !!window.localStorage && qq.isFunction(window.localStorage.setItem);\n            } catch (error) {\n                return false;\n            }\n        }\n        function isDragAndDropSupported() {\n            var span = document.createElement(\"span\");\n            return (\"draggable\" in span || \"ondragstart\" in span && \"ondrop\" in span) && !qq.android() && !qq.ios();\n        }\n        supportsUploading = testSupportsFileInputElement();\n        supportsAjaxFileUploading = supportsUploading && qq.isXhrUploadSupported();\n        supportsUploadingBlobs = supportsAjaxFileUploading && !qq.androidStock();\n        supportsFileDrop = supportsAjaxFileUploading && isDragAndDropSupported();\n        supportsFolderDrop = supportsFileDrop && isChrome21OrHigher();\n        supportsChunking = supportsAjaxFileUploading && qq.isFileChunkingSupported();\n        supportsResume = supportsAjaxFileUploading && supportsChunking && isLocalStorageSupported();\n        supportsUploadViaPaste = supportsAjaxFileUploading && isChrome14OrHigher();\n        supportsUploadCors = supportsUploading && (window.postMessage !== undefined || supportsAjaxFileUploading);\n        supportsDeleteFileCorsXhr = isCrossOriginXhrSupported();\n        supportsDeleteFileXdr = isXdrSupported();\n        supportsDeleteFileCors = isCrossOriginAjaxSupported();\n        supportsFolderSelection = isFolderSelectionSupported();\n        supportsImagePreviews = supportsAjaxFileUploading && window.FileReader !== undefined;\n        supportsUploadProgress = function() {\n            if (supportsAjaxFileUploading) {\n                return !qq.androidStock() && !qq.iosChrome();\n            }\n            return false;\n        }();\n        return {\n            ajaxUploading: supportsAjaxFileUploading,\n            blobUploading: supportsUploadingBlobs,\n            canDetermineSize: supportsAjaxFileUploading,\n            chunking: supportsChunking,\n            deleteFileCors: supportsDeleteFileCors,\n            deleteFileCorsXdr: supportsDeleteFileXdr,\n            deleteFileCorsXhr: supportsDeleteFileCorsXhr,\n            dialogElement: !!window.HTMLDialogElement,\n            fileDrop: supportsFileDrop,\n            folderDrop: supportsFolderDrop,\n            folderSelection: supportsFolderSelection,\n            imagePreviews: supportsImagePreviews,\n            imageValidation: supportsImagePreviews,\n            itemSizeValidation: supportsAjaxFileUploading,\n            pause: supportsChunking,\n            progressBar: supportsUploadProgress,\n            resume: supportsResume,\n            scaling: supportsImagePreviews && supportsUploadingBlobs,\n            tiffPreviews: qq.safari(),\n            unlimitedScaledImageSize: !qq.ios(),\n            uploading: supportsUploading,\n            uploadCors: supportsUploadCors,\n            uploadCustomHeaders: supportsAjaxFileUploading,\n            uploadNonMultipart: supportsAjaxFileUploading,\n            uploadViaPaste: supportsUploadViaPaste\n        };\n    }();\n    qq.isGenericPromise = function(maybePromise) {\n        \"use strict\";\n        return !!(maybePromise && maybePromise.then && qq.isFunction(maybePromise.then));\n    };\n    qq.Promise = function() {\n        \"use strict\";\n        var successArgs, failureArgs, successCallbacks = [], failureCallbacks = [], doneCallbacks = [], state = 0;\n        qq.extend(this, {\n            then: function(onSuccess, onFailure) {\n                if (state === 0) {\n                    if (onSuccess) {\n                        successCallbacks.push(onSuccess);\n                    }\n                    if (onFailure) {\n                        failureCallbacks.push(onFailure);\n                    }\n                } else if (state === -1) {\n                    onFailure && onFailure.apply(null, failureArgs);\n                } else if (onSuccess) {\n                    onSuccess.apply(null, successArgs);\n                }\n                return this;\n            },\n            done: function(callback) {\n                if (state === 0) {\n                    doneCallbacks.push(callback);\n                } else {\n                    callback.apply(null, failureArgs === undefined ? successArgs : failureArgs);\n                }\n                return this;\n            },\n            success: function() {\n                state = 1;\n                successArgs = arguments;\n                if (successCallbacks.length) {\n                    qq.each(successCallbacks, function(idx, callback) {\n                        callback.apply(null, successArgs);\n                    });\n                }\n                if (doneCallbacks.length) {\n                    qq.each(doneCallbacks, function(idx, callback) {\n                        callback.apply(null, successArgs);\n                    });\n                }\n                return this;\n            },\n            failure: function() {\n                state = -1;\n                failureArgs = arguments;\n                if (failureCallbacks.length) {\n                    qq.each(failureCallbacks, function(idx, callback) {\n                        callback.apply(null, failureArgs);\n                    });\n                }\n                if (doneCallbacks.length) {\n                    qq.each(doneCallbacks, function(idx, callback) {\n                        callback.apply(null, failureArgs);\n                    });\n                }\n                return this;\n            }\n        });\n    };\n    qq.BlobProxy = function(referenceBlob, onCreate) {\n        \"use strict\";\n        qq.extend(this, {\n            referenceBlob: referenceBlob,\n            create: function() {\n                return onCreate(referenceBlob);\n            }\n        });\n    };\n    qq.UploadButton = function(o) {\n        \"use strict\";\n        var self = this, disposeSupport = new qq.DisposeSupport(), options = {\n            acceptFiles: null,\n            element: null,\n            focusClass: \"qq-upload-button-focus\",\n            folders: false,\n            hoverClass: \"qq-upload-button-hover\",\n            ios8BrowserCrashWorkaround: false,\n            multiple: false,\n            name: \"qqfile\",\n            onChange: function(input) {},\n            title: null\n        }, input, buttonId;\n        qq.extend(options, o);\n        buttonId = qq.getUniqueId();\n        function createInput() {\n            var input = document.createElement(\"input\");\n            input.setAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME, buttonId);\n            input.setAttribute(\"title\", options.title);\n            self.setMultiple(options.multiple, input);\n            if (options.folders && qq.supportedFeatures.folderSelection) {\n                input.setAttribute(\"webkitdirectory\", \"\");\n            }\n            if (options.acceptFiles) {\n                input.setAttribute(\"accept\", options.acceptFiles);\n            }\n            input.setAttribute(\"type\", \"file\");\n            input.setAttribute(\"name\", options.name);\n            qq(input).css({\n                position: \"absolute\",\n                right: 0,\n                top: 0,\n                fontFamily: \"Arial\",\n                fontSize: qq.ie() && !qq.ie8() ? \"3500px\" : \"118px\",\n                margin: 0,\n                padding: 0,\n                cursor: \"pointer\",\n                opacity: 0\n            });\n            !qq.ie7() && qq(input).css({\n                height: \"100%\"\n            });\n            options.element.appendChild(input);\n            disposeSupport.attach(input, \"change\", function() {\n                options.onChange(input);\n            });\n            disposeSupport.attach(input, \"mouseover\", function() {\n                qq(options.element).addClass(options.hoverClass);\n            });\n            disposeSupport.attach(input, \"mouseout\", function() {\n                qq(options.element).removeClass(options.hoverClass);\n            });\n            disposeSupport.attach(input, \"focus\", function() {\n                qq(options.element).addClass(options.focusClass);\n            });\n            disposeSupport.attach(input, \"blur\", function() {\n                qq(options.element).removeClass(options.focusClass);\n            });\n            return input;\n        }\n        qq(options.element).css({\n            position: \"relative\",\n            overflow: \"hidden\",\n            direction: \"ltr\"\n        });\n        qq.extend(this, {\n            getInput: function() {\n                return input;\n            },\n            getButtonId: function() {\n                return buttonId;\n            },\n            setMultiple: function(isMultiple, optInput) {\n                var input = optInput || this.getInput();\n                if (options.ios8BrowserCrashWorkaround && qq.ios8() && (qq.iosChrome() || qq.iosSafariWebView())) {\n                    input.setAttribute(\"multiple\", \"\");\n                } else {\n                    if (isMultiple) {\n                        input.setAttribute(\"multiple\", \"\");\n                    } else {\n                        input.removeAttribute(\"multiple\");\n                    }\n                }\n            },\n            setAcceptFiles: function(acceptFiles) {\n                if (acceptFiles !== options.acceptFiles) {\n                    input.setAttribute(\"accept\", acceptFiles);\n                }\n            },\n            reset: function() {\n                if (input.parentNode) {\n                    qq(input).remove();\n                }\n                qq(options.element).removeClass(options.focusClass);\n                input = null;\n                input = createInput();\n            }\n        });\n        input = createInput();\n    };\n    qq.UploadButton.BUTTON_ID_ATTR_NAME = \"qq-button-id\";\n    qq.UploadData = function(uploaderProxy) {\n        \"use strict\";\n        var data = [], byUuid = {}, byStatus = {}, byProxyGroupId = {}, byBatchId = {};\n        function getDataByIds(idOrIds) {\n            if (qq.isArray(idOrIds)) {\n                var entries = [];\n                qq.each(idOrIds, function(idx, id) {\n                    entries.push(data[id]);\n                });\n                return entries;\n            }\n            return data[idOrIds];\n        }\n        function getDataByUuids(uuids) {\n            if (qq.isArray(uuids)) {\n                var entries = [];\n                qq.each(uuids, function(idx, uuid) {\n                    entries.push(data[byUuid[uuid]]);\n                });\n                return entries;\n            }\n            return data[byUuid[uuids]];\n        }\n        function getDataByStatus(status) {\n            var statusResults = [], statuses = [].concat(status);\n            qq.each(statuses, function(index, statusEnum) {\n                var statusResultIndexes = byStatus[statusEnum];\n                if (statusResultIndexes !== undefined) {\n                    qq.each(statusResultIndexes, function(i, dataIndex) {\n                        statusResults.push(data[dataIndex]);\n                    });\n                }\n            });\n            return statusResults;\n        }\n        qq.extend(this, {\n            addFile: function(spec) {\n                var status = spec.status || qq.status.SUBMITTING, id = data.push({\n                    name: spec.name,\n                    originalName: spec.name,\n                    uuid: spec.uuid,\n                    size: spec.size == null ? -1 : spec.size,\n                    status: status\n                }) - 1;\n                if (spec.batchId) {\n                    data[id].batchId = spec.batchId;\n                    if (byBatchId[spec.batchId] === undefined) {\n                        byBatchId[spec.batchId] = [];\n                    }\n                    byBatchId[spec.batchId].push(id);\n                }\n                if (spec.proxyGroupId) {\n                    data[id].proxyGroupId = spec.proxyGroupId;\n                    if (byProxyGroupId[spec.proxyGroupId] === undefined) {\n                        byProxyGroupId[spec.proxyGroupId] = [];\n                    }\n                    byProxyGroupId[spec.proxyGroupId].push(id);\n                }\n                data[id].id = id;\n                byUuid[spec.uuid] = id;\n                if (byStatus[status] === undefined) {\n                    byStatus[status] = [];\n                }\n                byStatus[status].push(id);\n                uploaderProxy.onStatusChange(id, null, status);\n                return id;\n            },\n            retrieve: function(optionalFilter) {\n                if (qq.isObject(optionalFilter) && data.length) {\n                    if (optionalFilter.id !== undefined) {\n                        return getDataByIds(optionalFilter.id);\n                    } else if (optionalFilter.uuid !== undefined) {\n                        return getDataByUuids(optionalFilter.uuid);\n                    } else if (optionalFilter.status) {\n                        return getDataByStatus(optionalFilter.status);\n                    }\n                } else {\n                    return qq.extend([], data, true);\n                }\n            },\n            reset: function() {\n                data = [];\n                byUuid = {};\n                byStatus = {};\n                byBatchId = {};\n            },\n            setStatus: function(id, newStatus) {\n                var oldStatus = data[id].status, byStatusOldStatusIndex = qq.indexOf(byStatus[oldStatus], id);\n                byStatus[oldStatus].splice(byStatusOldStatusIndex, 1);\n                data[id].status = newStatus;\n                if (byStatus[newStatus] === undefined) {\n                    byStatus[newStatus] = [];\n                }\n                byStatus[newStatus].push(id);\n                uploaderProxy.onStatusChange(id, oldStatus, newStatus);\n            },\n            uuidChanged: function(id, newUuid) {\n                var oldUuid = data[id].uuid;\n                data[id].uuid = newUuid;\n                byUuid[newUuid] = id;\n                delete byUuid[oldUuid];\n            },\n            updateName: function(id, newName) {\n                data[id].name = newName;\n            },\n            updateSize: function(id, newSize) {\n                data[id].size = newSize;\n            },\n            setParentId: function(targetId, parentId) {\n                data[targetId].parentId = parentId;\n            },\n            getIdsInProxyGroup: function(id) {\n                var proxyGroupId = data[id].proxyGroupId;\n                if (proxyGroupId) {\n                    return byProxyGroupId[proxyGroupId];\n                }\n                return [];\n            },\n            getIdsInBatch: function(id) {\n                var batchId = data[id].batchId;\n                return byBatchId[batchId];\n            }\n        });\n    };\n    qq.status = {\n        SUBMITTING: \"submitting\",\n        SUBMITTED: \"submitted\",\n        REJECTED: \"rejected\",\n        QUEUED: \"queued\",\n        CANCELED: \"canceled\",\n        PAUSED: \"paused\",\n        UPLOADING: \"uploading\",\n        UPLOAD_RETRYING: \"retrying upload\",\n        UPLOAD_SUCCESSFUL: \"upload successful\",\n        UPLOAD_FAILED: \"upload failed\",\n        DELETE_FAILED: \"delete failed\",\n        DELETING: \"deleting\",\n        DELETED: \"deleted\"\n    };\n    (function() {\n        \"use strict\";\n        qq.basePublicApi = {\n            addBlobs: function(blobDataOrArray, params, endpoint) {\n                this.addFiles(blobDataOrArray, params, endpoint);\n            },\n            addInitialFiles: function(cannedFileList) {\n                var self = this;\n                qq.each(cannedFileList, function(index, cannedFile) {\n                    self._addCannedFile(cannedFile);\n                });\n            },\n            addFiles: function(data, params, endpoint) {\n                this._maybeHandleIos8SafariWorkaround();\n                var batchId = this._storedIds.length === 0 ? qq.getUniqueId() : this._currentBatchId, processBlob = qq.bind(function(blob) {\n                    this._handleNewFile({\n                        blob: blob,\n                        name: this._options.blobs.defaultName\n                    }, batchId, verifiedFiles);\n                }, this), processBlobData = qq.bind(function(blobData) {\n                    this._handleNewFile(blobData, batchId, verifiedFiles);\n                }, this), processCanvas = qq.bind(function(canvas) {\n                    var blob = qq.canvasToBlob(canvas);\n                    this._handleNewFile({\n                        blob: blob,\n                        name: this._options.blobs.defaultName + \".png\"\n                    }, batchId, verifiedFiles);\n                }, this), processCanvasData = qq.bind(function(canvasData) {\n                    var normalizedQuality = canvasData.quality && canvasData.quality / 100, blob = qq.canvasToBlob(canvasData.canvas, canvasData.type, normalizedQuality);\n                    this._handleNewFile({\n                        blob: blob,\n                        name: canvasData.name\n                    }, batchId, verifiedFiles);\n                }, this), processFileOrInput = qq.bind(function(fileOrInput) {\n                    if (qq.isInput(fileOrInput) && qq.supportedFeatures.ajaxUploading) {\n                        var files = Array.prototype.slice.call(fileOrInput.files), self = this;\n                        qq.each(files, function(idx, file) {\n                            self._handleNewFile(file, batchId, verifiedFiles);\n                        });\n                    } else {\n                        this._handleNewFile(fileOrInput, batchId, verifiedFiles);\n                    }\n                }, this), normalizeData = function() {\n                    if (qq.isFileList(data)) {\n                        data = Array.prototype.slice.call(data);\n                    }\n                    data = [].concat(data);\n                }, self = this, verifiedFiles = [];\n                this._currentBatchId = batchId;\n                if (data) {\n                    normalizeData();\n                    qq.each(data, function(idx, fileContainer) {\n                        if (qq.isFileOrInput(fileContainer)) {\n                            processFileOrInput(fileContainer);\n                        } else if (qq.isBlob(fileContainer)) {\n                            processBlob(fileContainer);\n                        } else if (qq.isObject(fileContainer)) {\n                            if (fileContainer.blob && fileContainer.name) {\n                                processBlobData(fileContainer);\n                            } else if (fileContainer.canvas && fileContainer.name) {\n                                processCanvasData(fileContainer);\n                            }\n                        } else if (fileContainer.tagName && fileContainer.tagName.toLowerCase() === \"canvas\") {\n                            processCanvas(fileContainer);\n                        } else {\n                            self.log(fileContainer + \" is not a valid file container!  Ignoring!\", \"warn\");\n                        }\n                    });\n                    this.log(\"Received \" + verifiedFiles.length + \" files.\");\n                    this._prepareItemsForUpload(verifiedFiles, params, endpoint);\n                }\n            },\n            cancel: function(id) {\n                this._handler.cancel(id);\n            },\n            cancelAll: function() {\n                var storedIdsCopy = [], self = this;\n                qq.extend(storedIdsCopy, this._storedIds);\n                qq.each(storedIdsCopy, function(idx, storedFileId) {\n                    self.cancel(storedFileId);\n                });\n                this._handler.cancelAll();\n            },\n            clearStoredFiles: function() {\n                this._storedIds = [];\n            },\n            continueUpload: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n                    return false;\n                }\n                if (uploadData.status === qq.status.PAUSED) {\n                    this.log(qq.format(\"Paused file ID {} ({}) will be continued.  Not paused.\", id, this.getName(id)));\n                    this._uploadFile(id);\n                    return true;\n                } else {\n                    this.log(qq.format(\"Ignoring continue for file ID {} ({}).  Not paused.\", id, this.getName(id)), \"error\");\n                }\n                return false;\n            },\n            deleteFile: function(id) {\n                return this._onSubmitDelete(id);\n            },\n            doesExist: function(fileOrBlobId) {\n                return this._handler.isValid(fileOrBlobId);\n            },\n            drawThumbnail: function(fileId, imgOrCanvas, maxSize, fromServer, customResizeFunction) {\n                var promiseToReturn = new qq.Promise(), fileOrUrl, options;\n                if (this._imageGenerator) {\n                    fileOrUrl = this._thumbnailUrls[fileId];\n                    options = {\n                        customResizeFunction: customResizeFunction,\n                        maxSize: maxSize > 0 ? maxSize : null,\n                        scale: maxSize > 0\n                    };\n                    if (!fromServer && qq.supportedFeatures.imagePreviews) {\n                        fileOrUrl = this.getFile(fileId);\n                    }\n                    if (fileOrUrl == null) {\n                        promiseToReturn.failure({\n                            container: imgOrCanvas,\n                            error: \"File or URL not found.\"\n                        });\n                    } else {\n                        this._imageGenerator.generate(fileOrUrl, imgOrCanvas, options).then(function success(modifiedContainer) {\n                            promiseToReturn.success(modifiedContainer);\n                        }, function failure(container, reason) {\n                            promiseToReturn.failure({\n                                container: container,\n                                error: reason || \"Problem generating thumbnail\"\n                            });\n                        });\n                    }\n                } else {\n                    promiseToReturn.failure({\n                        container: imgOrCanvas,\n                        error: \"Missing image generator module\"\n                    });\n                }\n                return promiseToReturn;\n            },\n            getButton: function(fileId) {\n                return this._getButton(this._buttonIdsForFileIds[fileId]);\n            },\n            getEndpoint: function(fileId) {\n                return this._endpointStore.get(fileId);\n            },\n            getFile: function(fileOrBlobId) {\n                return this._handler.getFile(fileOrBlobId) || null;\n            },\n            getInProgress: function() {\n                return this._uploadData.retrieve({\n                    status: [ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED ]\n                }).length;\n            },\n            getName: function(id) {\n                return this._uploadData.retrieve({\n                    id: id\n                }).name;\n            },\n            getParentId: function(id) {\n                var uploadDataEntry = this.getUploads({\n                    id: id\n                }), parentId = null;\n                if (uploadDataEntry) {\n                    if (uploadDataEntry.parentId !== undefined) {\n                        parentId = uploadDataEntry.parentId;\n                    }\n                }\n                return parentId;\n            },\n            getResumableFilesData: function() {\n                return this._handler.getResumableFilesData();\n            },\n            getSize: function(id) {\n                return this._uploadData.retrieve({\n                    id: id\n                }).size;\n            },\n            getNetUploads: function() {\n                return this._netUploaded;\n            },\n            getRemainingAllowedItems: function() {\n                var allowedItems = this._currentItemLimit;\n                if (allowedItems > 0) {\n                    return allowedItems - this._netUploadedOrQueued;\n                }\n                return null;\n            },\n            getUploads: function(optionalFilter) {\n                return this._uploadData.retrieve(optionalFilter);\n            },\n            getUuid: function(id) {\n                return this._uploadData.retrieve({\n                    id: id\n                }).uuid;\n            },\n            log: function(str, level) {\n                if (this._options.debug && (!level || level === \"info\")) {\n                    qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str);\n                } else if (level && level !== \"info\") {\n                    qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str, level);\n                }\n            },\n            pauseUpload: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n                    return false;\n                }\n                if (qq.indexOf([ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING ], uploadData.status) >= 0) {\n                    if (this._handler.pause(id)) {\n                        this._uploadData.setStatus(id, qq.status.PAUSED);\n                        return true;\n                    } else {\n                        this.log(qq.format(\"Unable to pause file ID {} ({}).\", id, this.getName(id)), \"error\");\n                    }\n                } else {\n                    this.log(qq.format(\"Ignoring pause for file ID {} ({}).  Not in progress.\", id, this.getName(id)), \"error\");\n                }\n                return false;\n            },\n            reset: function() {\n                this.log(\"Resetting uploader...\");\n                this._handler.reset();\n                this._storedIds = [];\n                this._autoRetries = [];\n                this._retryTimeouts = [];\n                this._preventRetries = [];\n                this._thumbnailUrls = [];\n                qq.each(this._buttons, function(idx, button) {\n                    button.reset();\n                });\n                this._paramsStore.reset();\n                this._endpointStore.reset();\n                this._netUploadedOrQueued = 0;\n                this._netUploaded = 0;\n                this._uploadData.reset();\n                this._buttonIdsForFileIds = [];\n                this._pasteHandler && this._pasteHandler.reset();\n                this._options.session.refreshOnReset && this._refreshSessionData();\n                this._succeededSinceLastAllComplete = [];\n                this._failedSinceLastAllComplete = [];\n                this._totalProgress && this._totalProgress.reset();\n            },\n            retry: function(id) {\n                return this._manualRetry(id);\n            },\n            scaleImage: function(id, specs) {\n                var self = this;\n                return qq.Scaler.prototype.scaleImage(id, specs, {\n                    log: qq.bind(self.log, self),\n                    getFile: qq.bind(self.getFile, self),\n                    uploadData: self._uploadData\n                });\n            },\n            setCustomHeaders: function(headers, id) {\n                this._customHeadersStore.set(headers, id);\n            },\n            setDeleteFileCustomHeaders: function(headers, id) {\n                this._deleteFileCustomHeadersStore.set(headers, id);\n            },\n            setDeleteFileEndpoint: function(endpoint, id) {\n                this._deleteFileEndpointStore.set(endpoint, id);\n            },\n            setDeleteFileParams: function(params, id) {\n                this._deleteFileParamsStore.set(params, id);\n            },\n            setEndpoint: function(endpoint, id) {\n                this._endpointStore.set(endpoint, id);\n            },\n            setForm: function(elementOrId) {\n                this._updateFormSupportAndParams(elementOrId);\n            },\n            setItemLimit: function(newItemLimit) {\n                this._currentItemLimit = newItemLimit;\n            },\n            setName: function(id, newName) {\n                this._uploadData.updateName(id, newName);\n            },\n            setParams: function(params, id) {\n                this._paramsStore.set(params, id);\n            },\n            setUuid: function(id, newUuid) {\n                return this._uploadData.uuidChanged(id, newUuid);\n            },\n            uploadStoredFiles: function() {\n                if (this._storedIds.length === 0) {\n                    this._itemError(\"noFilesError\");\n                } else {\n                    this._uploadStoredFiles();\n                }\n            }\n        };\n        qq.basePrivateApi = {\n            _addCannedFile: function(sessionData) {\n                var id = this._uploadData.addFile({\n                    uuid: sessionData.uuid,\n                    name: sessionData.name,\n                    size: sessionData.size,\n                    status: qq.status.UPLOAD_SUCCESSFUL\n                });\n                sessionData.deleteFileEndpoint && this.setDeleteFileEndpoint(sessionData.deleteFileEndpoint, id);\n                sessionData.deleteFileParams && this.setDeleteFileParams(sessionData.deleteFileParams, id);\n                if (sessionData.thumbnailUrl) {\n                    this._thumbnailUrls[id] = sessionData.thumbnailUrl;\n                }\n                this._netUploaded++;\n                this._netUploadedOrQueued++;\n                return id;\n            },\n            _annotateWithButtonId: function(file, associatedInput) {\n                if (qq.isFile(file)) {\n                    file.qqButtonId = this._getButtonId(associatedInput);\n                }\n            },\n            _batchError: function(message) {\n                this._options.callbacks.onError(null, null, message, undefined);\n            },\n            _createDeleteHandler: function() {\n                var self = this;\n                return new qq.DeleteFileAjaxRequester({\n                    method: this._options.deleteFile.method.toUpperCase(),\n                    maxConnections: this._options.maxConnections,\n                    uuidParamName: this._options.request.uuidName,\n                    customHeaders: this._deleteFileCustomHeadersStore,\n                    paramsStore: this._deleteFileParamsStore,\n                    endpointStore: this._deleteFileEndpointStore,\n                    cors: this._options.cors,\n                    log: qq.bind(self.log, self),\n                    onDelete: function(id) {\n                        self._onDelete(id);\n                        self._options.callbacks.onDelete(id);\n                    },\n                    onDeleteComplete: function(id, xhrOrXdr, isError) {\n                        self._onDeleteComplete(id, xhrOrXdr, isError);\n                        self._options.callbacks.onDeleteComplete(id, xhrOrXdr, isError);\n                    }\n                });\n            },\n            _createPasteHandler: function() {\n                var self = this;\n                return new qq.PasteSupport({\n                    targetElement: this._options.paste.targetElement,\n                    callbacks: {\n                        log: qq.bind(self.log, self),\n                        pasteReceived: function(blob) {\n                            self._handleCheckedCallback({\n                                name: \"onPasteReceived\",\n                                callback: qq.bind(self._options.callbacks.onPasteReceived, self, blob),\n                                onSuccess: qq.bind(self._handlePasteSuccess, self, blob),\n                                identifier: \"pasted image\"\n                            });\n                        }\n                    }\n                });\n            },\n            _createStore: function(initialValue, _readOnlyValues_) {\n                var store = {}, catchall = initialValue, perIdReadOnlyValues = {}, readOnlyValues = _readOnlyValues_, copy = function(orig) {\n                    if (qq.isObject(orig)) {\n                        return qq.extend({}, orig);\n                    }\n                    return orig;\n                }, getReadOnlyValues = function() {\n                    if (qq.isFunction(readOnlyValues)) {\n                        return readOnlyValues();\n                    }\n                    return readOnlyValues;\n                }, includeReadOnlyValues = function(id, existing) {\n                    if (readOnlyValues && qq.isObject(existing)) {\n                        qq.extend(existing, getReadOnlyValues());\n                    }\n                    if (perIdReadOnlyValues[id]) {\n                        qq.extend(existing, perIdReadOnlyValues[id]);\n                    }\n                };\n                return {\n                    set: function(val, id) {\n                        if (id == null) {\n                            store = {};\n                            catchall = copy(val);\n                        } else {\n                            store[id] = copy(val);\n                        }\n                    },\n                    get: function(id) {\n                        var values;\n                        if (id != null && store[id]) {\n                            values = store[id];\n                        } else {\n                            values = copy(catchall);\n                        }\n                        includeReadOnlyValues(id, values);\n                        return copy(values);\n                    },\n                    addReadOnly: function(id, values) {\n                        if (qq.isObject(store)) {\n                            if (id === null) {\n                                if (qq.isFunction(values)) {\n                                    readOnlyValues = values;\n                                } else {\n                                    readOnlyValues = readOnlyValues || {};\n                                    qq.extend(readOnlyValues, values);\n                                }\n                            } else {\n                                perIdReadOnlyValues[id] = perIdReadOnlyValues[id] || {};\n                                qq.extend(perIdReadOnlyValues[id], values);\n                            }\n                        }\n                    },\n                    remove: function(fileId) {\n                        return delete store[fileId];\n                    },\n                    reset: function() {\n                        store = {};\n                        perIdReadOnlyValues = {};\n                        catchall = initialValue;\n                    }\n                };\n            },\n            _createUploadDataTracker: function() {\n                var self = this;\n                return new qq.UploadData({\n                    getName: function(id) {\n                        return self.getName(id);\n                    },\n                    getUuid: function(id) {\n                        return self.getUuid(id);\n                    },\n                    getSize: function(id) {\n                        return self.getSize(id);\n                    },\n                    onStatusChange: function(id, oldStatus, newStatus) {\n                        self._onUploadStatusChange(id, oldStatus, newStatus);\n                        self._options.callbacks.onStatusChange(id, oldStatus, newStatus);\n                        self._maybeAllComplete(id, newStatus);\n                        if (self._totalProgress) {\n                            setTimeout(function() {\n                                self._totalProgress.onStatusChange(id, oldStatus, newStatus);\n                            }, 0);\n                        }\n                    }\n                });\n            },\n            _createUploadButton: function(spec) {\n                var self = this, acceptFiles = spec.accept || this._options.validation.acceptFiles, allowedExtensions = spec.allowedExtensions || this._options.validation.allowedExtensions, button;\n                function allowMultiple() {\n                    if (qq.supportedFeatures.ajaxUploading) {\n                        if (self._options.workarounds.iosEmptyVideos && qq.ios() && !qq.ios6() && self._isAllowedExtension(allowedExtensions, \".mov\")) {\n                            return false;\n                        }\n                        if (spec.multiple === undefined) {\n                            return self._options.multiple;\n                        }\n                        return spec.multiple;\n                    }\n                    return false;\n                }\n                button = new qq.UploadButton({\n                    acceptFiles: acceptFiles,\n                    element: spec.element,\n                    focusClass: this._options.classes.buttonFocus,\n                    folders: spec.folders,\n                    hoverClass: this._options.classes.buttonHover,\n                    ios8BrowserCrashWorkaround: this._options.workarounds.ios8BrowserCrash,\n                    multiple: allowMultiple(),\n                    name: this._options.request.inputName,\n                    onChange: function(input) {\n                        self._onInputChange(input);\n                    },\n                    title: spec.title == null ? this._options.text.fileInputTitle : spec.title\n                });\n                this._disposeSupport.addDisposer(function() {\n                    button.dispose();\n                });\n                self._buttons.push(button);\n                return button;\n            },\n            _createUploadHandler: function(additionalOptions, namespace) {\n                var self = this, lastOnProgress = {}, options = {\n                    debug: this._options.debug,\n                    maxConnections: this._options.maxConnections,\n                    cors: this._options.cors,\n                    paramsStore: this._paramsStore,\n                    endpointStore: this._endpointStore,\n                    chunking: this._options.chunking,\n                    resume: this._options.resume,\n                    blobs: this._options.blobs,\n                    log: qq.bind(self.log, self),\n                    preventRetryParam: this._options.retry.preventRetryResponseProperty,\n                    onProgress: function(id, name, loaded, total) {\n                        if (loaded < 0 || total < 0) {\n                            return;\n                        }\n                        if (lastOnProgress[id]) {\n                            if (lastOnProgress[id].loaded !== loaded || lastOnProgress[id].total !== total) {\n                                self._onProgress(id, name, loaded, total);\n                                self._options.callbacks.onProgress(id, name, loaded, total);\n                            }\n                        } else {\n                            self._onProgress(id, name, loaded, total);\n                            self._options.callbacks.onProgress(id, name, loaded, total);\n                        }\n                        lastOnProgress[id] = {\n                            loaded: loaded,\n                            total: total\n                        };\n                    },\n                    onComplete: function(id, name, result, xhr) {\n                        delete lastOnProgress[id];\n                        var status = self.getUploads({\n                            id: id\n                        }).status, retVal;\n                        if (status === qq.status.UPLOAD_SUCCESSFUL || status === qq.status.UPLOAD_FAILED) {\n                            return;\n                        }\n                        retVal = self._onComplete(id, name, result, xhr);\n                        if (retVal instanceof qq.Promise) {\n                            retVal.done(function() {\n                                self._options.callbacks.onComplete(id, name, result, xhr);\n                            });\n                        } else {\n                            self._options.callbacks.onComplete(id, name, result, xhr);\n                        }\n                    },\n                    onCancel: function(id, name, cancelFinalizationEffort) {\n                        var promise = new qq.Promise();\n                        self._handleCheckedCallback({\n                            name: \"onCancel\",\n                            callback: qq.bind(self._options.callbacks.onCancel, self, id, name),\n                            onFailure: promise.failure,\n                            onSuccess: function() {\n                                cancelFinalizationEffort.then(function() {\n                                    self._onCancel(id, name);\n                                });\n                                promise.success();\n                            },\n                            identifier: id\n                        });\n                        return promise;\n                    },\n                    onUploadPrep: qq.bind(this._onUploadPrep, this),\n                    onUpload: function(id, name) {\n                        self._onUpload(id, name);\n                        self._options.callbacks.onUpload(id, name);\n                    },\n                    onUploadChunk: function(id, name, chunkData) {\n                        self._onUploadChunk(id, chunkData);\n                        self._options.callbacks.onUploadChunk(id, name, chunkData);\n                    },\n                    onUploadChunkSuccess: function(id, chunkData, result, xhr) {\n                        self._options.callbacks.onUploadChunkSuccess.apply(self, arguments);\n                    },\n                    onResume: function(id, name, chunkData) {\n                        return self._options.callbacks.onResume(id, name, chunkData);\n                    },\n                    onAutoRetry: function(id, name, responseJSON, xhr) {\n                        return self._onAutoRetry.apply(self, arguments);\n                    },\n                    onUuidChanged: function(id, newUuid) {\n                        self.log(\"Server requested UUID change from '\" + self.getUuid(id) + \"' to '\" + newUuid + \"'\");\n                        self.setUuid(id, newUuid);\n                    },\n                    getName: qq.bind(self.getName, self),\n                    getUuid: qq.bind(self.getUuid, self),\n                    getSize: qq.bind(self.getSize, self),\n                    setSize: qq.bind(self._setSize, self),\n                    getDataByUuid: function(uuid) {\n                        return self.getUploads({\n                            uuid: uuid\n                        });\n                    },\n                    isQueued: function(id) {\n                        var status = self.getUploads({\n                            id: id\n                        }).status;\n                        return status === qq.status.QUEUED || status === qq.status.SUBMITTED || status === qq.status.UPLOAD_RETRYING || status === qq.status.PAUSED;\n                    },\n                    getIdsInProxyGroup: self._uploadData.getIdsInProxyGroup,\n                    getIdsInBatch: self._uploadData.getIdsInBatch\n                };\n                qq.each(this._options.request, function(prop, val) {\n                    options[prop] = val;\n                });\n                options.customHeaders = this._customHeadersStore;\n                if (additionalOptions) {\n                    qq.each(additionalOptions, function(key, val) {\n                        options[key] = val;\n                    });\n                }\n                return new qq.UploadHandlerController(options, namespace);\n            },\n            _fileOrBlobRejected: function(id) {\n                this._netUploadedOrQueued--;\n                this._uploadData.setStatus(id, qq.status.REJECTED);\n            },\n            _formatSize: function(bytes) {\n                var i = -1;\n                do {\n                    bytes = bytes / 1e3;\n                    i++;\n                } while (bytes > 999);\n                return Math.max(bytes, .1).toFixed(1) + this._options.text.sizeSymbols[i];\n            },\n            _generateExtraButtonSpecs: function() {\n                var self = this;\n                this._extraButtonSpecs = {};\n                qq.each(this._options.extraButtons, function(idx, extraButtonOptionEntry) {\n                    var multiple = extraButtonOptionEntry.multiple, validation = qq.extend({}, self._options.validation, true), extraButtonSpec = qq.extend({}, extraButtonOptionEntry);\n                    if (multiple === undefined) {\n                        multiple = self._options.multiple;\n                    }\n                    if (extraButtonSpec.validation) {\n                        qq.extend(validation, extraButtonOptionEntry.validation, true);\n                    }\n                    qq.extend(extraButtonSpec, {\n                        multiple: multiple,\n                        validation: validation\n                    }, true);\n                    self._initExtraButton(extraButtonSpec);\n                });\n            },\n            _getButton: function(buttonId) {\n                var extraButtonsSpec = this._extraButtonSpecs[buttonId];\n                if (extraButtonsSpec) {\n                    return extraButtonsSpec.element;\n                } else if (buttonId === this._defaultButtonId) {\n                    return this._options.button;\n                }\n            },\n            _getButtonId: function(buttonOrFileInputOrFile) {\n                var inputs, fileInput, fileBlobOrInput = buttonOrFileInputOrFile;\n                if (fileBlobOrInput instanceof qq.BlobProxy) {\n                    fileBlobOrInput = fileBlobOrInput.referenceBlob;\n                }\n                if (fileBlobOrInput && !qq.isBlob(fileBlobOrInput)) {\n                    if (qq.isFile(fileBlobOrInput)) {\n                        return fileBlobOrInput.qqButtonId;\n                    } else if (fileBlobOrInput.tagName.toLowerCase() === \"input\" && fileBlobOrInput.type.toLowerCase() === \"file\") {\n                        return fileBlobOrInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n                    }\n                    inputs = fileBlobOrInput.getElementsByTagName(\"input\");\n                    qq.each(inputs, function(idx, input) {\n                        if (input.getAttribute(\"type\") === \"file\") {\n                            fileInput = input;\n                            return false;\n                        }\n                    });\n                    if (fileInput) {\n                        return fileInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n                    }\n                }\n            },\n            _getNotFinished: function() {\n                return this._uploadData.retrieve({\n                    status: [ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED, qq.status.SUBMITTING, qq.status.SUBMITTED, qq.status.PAUSED ]\n                }).length;\n            },\n            _getValidationBase: function(buttonId) {\n                var extraButtonSpec = this._extraButtonSpecs[buttonId];\n                return extraButtonSpec ? extraButtonSpec.validation : this._options.validation;\n            },\n            _getValidationDescriptor: function(fileWrapper) {\n                if (fileWrapper.file instanceof qq.BlobProxy) {\n                    return {\n                        name: qq.getFilename(fileWrapper.file.referenceBlob),\n                        size: fileWrapper.file.referenceBlob.size\n                    };\n                }\n                return {\n                    name: this.getUploads({\n                        id: fileWrapper.id\n                    }).name,\n                    size: this.getUploads({\n                        id: fileWrapper.id\n                    }).size\n                };\n            },\n            _getValidationDescriptors: function(fileWrappers) {\n                var self = this, fileDescriptors = [];\n                qq.each(fileWrappers, function(idx, fileWrapper) {\n                    fileDescriptors.push(self._getValidationDescriptor(fileWrapper));\n                });\n                return fileDescriptors;\n            },\n            _handleCameraAccess: function() {\n                if (this._options.camera.ios && qq.ios()) {\n                    var acceptIosCamera = \"image/*;capture=camera\", button = this._options.camera.button, buttonId = button ? this._getButtonId(button) : this._defaultButtonId, optionRoot = this._options;\n                    if (buttonId && buttonId !== this._defaultButtonId) {\n                        optionRoot = this._extraButtonSpecs[buttonId];\n                    }\n                    optionRoot.multiple = false;\n                    if (optionRoot.validation.acceptFiles === null) {\n                        optionRoot.validation.acceptFiles = acceptIosCamera;\n                    } else {\n                        optionRoot.validation.acceptFiles += \",\" + acceptIosCamera;\n                    }\n                    qq.each(this._buttons, function(idx, button) {\n                        if (button.getButtonId() === buttonId) {\n                            button.setMultiple(optionRoot.multiple);\n                            button.setAcceptFiles(optionRoot.acceptFiles);\n                            return false;\n                        }\n                    });\n                }\n            },\n            _handleCheckedCallback: function(details) {\n                var self = this, callbackRetVal = details.callback();\n                if (qq.isGenericPromise(callbackRetVal)) {\n                    this.log(details.name + \" - waiting for \" + details.name + \" promise to be fulfilled for \" + details.identifier);\n                    return callbackRetVal.then(function(successParam) {\n                        self.log(details.name + \" promise success for \" + details.identifier);\n                        details.onSuccess(successParam);\n                    }, function() {\n                        if (details.onFailure) {\n                            self.log(details.name + \" promise failure for \" + details.identifier);\n                            details.onFailure();\n                        } else {\n                            self.log(details.name + \" promise failure for \" + details.identifier);\n                        }\n                    });\n                }\n                if (callbackRetVal !== false) {\n                    details.onSuccess(callbackRetVal);\n                } else {\n                    if (details.onFailure) {\n                        this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Invoking failure callback.\");\n                        details.onFailure();\n                    } else {\n                        this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Will not proceed.\");\n                    }\n                }\n                return callbackRetVal;\n            },\n            _handleNewFile: function(file, batchId, newFileWrapperList) {\n                var self = this, uuid = qq.getUniqueId(), size = -1, name = qq.getFilename(file), actualFile = file.blob || file, handler = this._customNewFileHandler ? this._customNewFileHandler : qq.bind(self._handleNewFileGeneric, self);\n                if (!qq.isInput(actualFile) && actualFile.size >= 0) {\n                    size = actualFile.size;\n                }\n                handler(actualFile, name, uuid, size, newFileWrapperList, batchId, this._options.request.uuidName, {\n                    uploadData: self._uploadData,\n                    paramsStore: self._paramsStore,\n                    addFileToHandler: function(id, file) {\n                        self._handler.add(id, file);\n                        self._netUploadedOrQueued++;\n                        self._trackButton(id);\n                    }\n                });\n            },\n            _handleNewFileGeneric: function(file, name, uuid, size, fileList, batchId) {\n                var id = this._uploadData.addFile({\n                    uuid: uuid,\n                    name: name,\n                    size: size,\n                    batchId: batchId\n                });\n                this._handler.add(id, file);\n                this._trackButton(id);\n                this._netUploadedOrQueued++;\n                fileList.push({\n                    id: id,\n                    file: file\n                });\n            },\n            _handlePasteSuccess: function(blob, extSuppliedName) {\n                var extension = blob.type.split(\"/\")[1], name = extSuppliedName;\n                if (name == null) {\n                    name = this._options.paste.defaultName;\n                }\n                name += \".\" + extension;\n                this.addFiles({\n                    name: name,\n                    blob: blob\n                });\n            },\n            _initExtraButton: function(spec) {\n                var button = this._createUploadButton({\n                    accept: spec.validation.acceptFiles,\n                    allowedExtensions: spec.validation.allowedExtensions,\n                    element: spec.element,\n                    folders: spec.folders,\n                    multiple: spec.multiple,\n                    title: spec.fileInputTitle\n                });\n                this._extraButtonSpecs[button.getButtonId()] = spec;\n            },\n            _initFormSupportAndParams: function() {\n                this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n                if (this._formSupport && this._formSupport.attachedToForm) {\n                    this._paramsStore = this._createStore(this._options.request.params, this._formSupport.getFormInputsAsObject);\n                    this._options.autoUpload = this._formSupport.newAutoUpload;\n                    if (this._formSupport.newEndpoint) {\n                        this._options.request.endpoint = this._formSupport.newEndpoint;\n                    }\n                } else {\n                    this._paramsStore = this._createStore(this._options.request.params);\n                }\n            },\n            _isDeletePossible: function() {\n                if (!qq.DeleteFileAjaxRequester || !this._options.deleteFile.enabled) {\n                    return false;\n                }\n                if (this._options.cors.expected) {\n                    if (qq.supportedFeatures.deleteFileCorsXhr) {\n                        return true;\n                    }\n                    if (qq.supportedFeatures.deleteFileCorsXdr && this._options.cors.allowXdr) {\n                        return true;\n                    }\n                    return false;\n                }\n                return true;\n            },\n            _isAllowedExtension: function(allowed, fileName) {\n                var valid = false;\n                if (!allowed.length) {\n                    return true;\n                }\n                qq.each(allowed, function(idx, allowedExt) {\n                    if (qq.isString(allowedExt)) {\n                        var extRegex = new RegExp(\"\\\\.\" + allowedExt + \"$\", \"i\");\n                        if (fileName.match(extRegex) != null) {\n                            valid = true;\n                            return false;\n                        }\n                    }\n                });\n                return valid;\n            },\n            _itemError: function(code, maybeNameOrNames, item) {\n                var message = this._options.messages[code], allowedExtensions = [], names = [].concat(maybeNameOrNames), name = names[0], buttonId = this._getButtonId(item), validationBase = this._getValidationBase(buttonId), extensionsForMessage, placeholderMatch;\n                function r(name, replacement) {\n                    message = message.replace(name, replacement);\n                }\n                qq.each(validationBase.allowedExtensions, function(idx, allowedExtension) {\n                    if (qq.isString(allowedExtension)) {\n                        allowedExtensions.push(allowedExtension);\n                    }\n                });\n                extensionsForMessage = allowedExtensions.join(\", \").toLowerCase();\n                r(\"{file}\", this._options.formatFileName(name));\n                r(\"{extensions}\", extensionsForMessage);\n                r(\"{sizeLimit}\", this._formatSize(validationBase.sizeLimit));\n                r(\"{minSizeLimit}\", this._formatSize(validationBase.minSizeLimit));\n                placeholderMatch = message.match(/(\\{\\w+\\})/g);\n                if (placeholderMatch !== null) {\n                    qq.each(placeholderMatch, function(idx, placeholder) {\n                        r(placeholder, names[idx]);\n                    });\n                }\n                this._options.callbacks.onError(null, name, message, undefined);\n                return message;\n            },\n            _manualRetry: function(id, callback) {\n                if (this._onBeforeManualRetry(id)) {\n                    this._netUploadedOrQueued++;\n                    this._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n                    if (callback) {\n                        callback(id);\n                    } else {\n                        this._handler.retry(id);\n                    }\n                    return true;\n                }\n            },\n            _maybeAllComplete: function(id, status) {\n                var self = this, notFinished = this._getNotFinished();\n                if (status === qq.status.UPLOAD_SUCCESSFUL) {\n                    this._succeededSinceLastAllComplete.push(id);\n                } else if (status === qq.status.UPLOAD_FAILED) {\n                    this._failedSinceLastAllComplete.push(id);\n                }\n                if (notFinished === 0 && (this._succeededSinceLastAllComplete.length || this._failedSinceLastAllComplete.length)) {\n                    setTimeout(function() {\n                        self._onAllComplete(self._succeededSinceLastAllComplete, self._failedSinceLastAllComplete);\n                    }, 0);\n                }\n            },\n            _maybeHandleIos8SafariWorkaround: function() {\n                var self = this;\n                if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n                    setTimeout(function() {\n                        window.alert(self._options.messages.unsupportedBrowserIos8Safari);\n                    }, 0);\n                    throw new qq.Error(this._options.messages.unsupportedBrowserIos8Safari);\n                }\n            },\n            _maybeParseAndSendUploadError: function(id, name, response, xhr) {\n                if (!response.success) {\n                    if (xhr && xhr.status !== 200 && !response.error) {\n                        this._options.callbacks.onError(id, name, \"XHR returned response code \" + xhr.status, xhr);\n                    } else {\n                        var errorReason = response.error ? response.error : this._options.text.defaultResponseError;\n                        this._options.callbacks.onError(id, name, errorReason, xhr);\n                    }\n                }\n            },\n            _maybeProcessNextItemAfterOnValidateCallback: function(validItem, items, index, params, endpoint) {\n                var self = this;\n                if (items.length > index) {\n                    if (validItem || !this._options.validation.stopOnFirstInvalidFile) {\n                        setTimeout(function() {\n                            var validationDescriptor = self._getValidationDescriptor(items[index]), buttonId = self._getButtonId(items[index].file), button = self._getButton(buttonId);\n                            self._handleCheckedCallback({\n                                name: \"onValidate\",\n                                callback: qq.bind(self._options.callbacks.onValidate, self, validationDescriptor, button),\n                                onSuccess: qq.bind(self._onValidateCallbackSuccess, self, items, index, params, endpoint),\n                                onFailure: qq.bind(self._onValidateCallbackFailure, self, items, index, params, endpoint),\n                                identifier: \"Item '\" + validationDescriptor.name + \"', size: \" + validationDescriptor.size\n                            });\n                        }, 0);\n                    } else if (!validItem) {\n                        for (;index < items.length; index++) {\n                            self._fileOrBlobRejected(items[index].id);\n                        }\n                    }\n                }\n            },\n            _onAllComplete: function(successful, failed) {\n                this._totalProgress && this._totalProgress.onAllComplete(successful, failed, this._preventRetries);\n                this._options.callbacks.onAllComplete(qq.extend([], successful), qq.extend([], failed));\n                this._succeededSinceLastAllComplete = [];\n                this._failedSinceLastAllComplete = [];\n            },\n            _onAutoRetry: function(id, name, responseJSON, xhr, callback) {\n                var self = this;\n                self._preventRetries[id] = responseJSON[self._options.retry.preventRetryResponseProperty];\n                if (self._shouldAutoRetry(id, name, responseJSON)) {\n                    var retryWaitPeriod = self._options.retry.autoAttemptDelay * 1e3;\n                    self._maybeParseAndSendUploadError.apply(self, arguments);\n                    self._options.callbacks.onAutoRetry(id, name, self._autoRetries[id]);\n                    self._onBeforeAutoRetry(id, name);\n                    self._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n                    self._retryTimeouts[id] = setTimeout(function() {\n                        self.log(\"Starting retry for \" + name + \"...\");\n                        if (callback) {\n                            callback(id);\n                        } else {\n                            self._handler.retry(id);\n                        }\n                    }, retryWaitPeriod);\n                    return true;\n                }\n            },\n            _onBeforeAutoRetry: function(id, name) {\n                this.log(\"Waiting \" + this._options.retry.autoAttemptDelay + \" seconds before retrying \" + name + \"...\");\n            },\n            _onBeforeManualRetry: function(id) {\n                var itemLimit = this._currentItemLimit, fileName;\n                if (this._preventRetries[id]) {\n                    this.log(\"Retries are forbidden for id \" + id, \"warn\");\n                    return false;\n                } else if (this._handler.isValid(id)) {\n                    fileName = this.getName(id);\n                    if (this._options.callbacks.onManualRetry(id, fileName) === false) {\n                        return false;\n                    }\n                    if (itemLimit > 0 && this._netUploadedOrQueued + 1 > itemLimit) {\n                        this._itemError(\"retryFailTooManyItems\");\n                        return false;\n                    }\n                    this.log(\"Retrying upload for '\" + fileName + \"' (id: \" + id + \")...\");\n                    return true;\n                } else {\n                    this.log(\"'\" + id + \"' is not a valid file ID\", \"error\");\n                    return false;\n                }\n            },\n            _onCancel: function(id, name) {\n                this._netUploadedOrQueued--;\n                clearTimeout(this._retryTimeouts[id]);\n                var storedItemIndex = qq.indexOf(this._storedIds, id);\n                if (!this._options.autoUpload && storedItemIndex >= 0) {\n                    this._storedIds.splice(storedItemIndex, 1);\n                }\n                this._uploadData.setStatus(id, qq.status.CANCELED);\n            },\n            _onComplete: function(id, name, result, xhr) {\n                if (!result.success) {\n                    this._netUploadedOrQueued--;\n                    this._uploadData.setStatus(id, qq.status.UPLOAD_FAILED);\n                    if (result[this._options.retry.preventRetryResponseProperty] === true) {\n                        this._preventRetries[id] = true;\n                    }\n                } else {\n                    if (result.thumbnailUrl) {\n                        this._thumbnailUrls[id] = result.thumbnailUrl;\n                    }\n                    this._netUploaded++;\n                    this._uploadData.setStatus(id, qq.status.UPLOAD_SUCCESSFUL);\n                }\n                this._maybeParseAndSendUploadError(id, name, result, xhr);\n                return result.success ? true : false;\n            },\n            _onDelete: function(id) {\n                this._uploadData.setStatus(id, qq.status.DELETING);\n            },\n            _onDeleteComplete: function(id, xhrOrXdr, isError) {\n                var name = this.getName(id);\n                if (isError) {\n                    this._uploadData.setStatus(id, qq.status.DELETE_FAILED);\n                    this.log(\"Delete request for '\" + name + \"' has failed.\", \"error\");\n                    if (xhrOrXdr.withCredentials === undefined) {\n                        this._options.callbacks.onError(id, name, \"Delete request failed\", xhrOrXdr);\n                    } else {\n                        this._options.callbacks.onError(id, name, \"Delete request failed with response code \" + xhrOrXdr.status, xhrOrXdr);\n                    }\n                } else {\n                    this._netUploadedOrQueued--;\n                    this._netUploaded--;\n                    this._handler.expunge(id);\n                    this._uploadData.setStatus(id, qq.status.DELETED);\n                    this.log(\"Delete request for '\" + name + \"' has succeeded.\");\n                }\n            },\n            _onInputChange: function(input) {\n                var fileIndex;\n                if (qq.supportedFeatures.ajaxUploading) {\n                    for (fileIndex = 0; fileIndex < input.files.length; fileIndex++) {\n                        this._annotateWithButtonId(input.files[fileIndex], input);\n                    }\n                    this.addFiles(input.files);\n                } else if (input.value.length > 0) {\n                    this.addFiles(input);\n                }\n                qq.each(this._buttons, function(idx, button) {\n                    button.reset();\n                });\n            },\n            _onProgress: function(id, name, loaded, total) {\n                this._totalProgress && this._totalProgress.onIndividualProgress(id, loaded, total);\n            },\n            _onSubmit: function(id, name) {},\n            _onSubmitCallbackSuccess: function(id, name) {\n                this._onSubmit.apply(this, arguments);\n                this._uploadData.setStatus(id, qq.status.SUBMITTED);\n                this._onSubmitted.apply(this, arguments);\n                if (this._options.autoUpload) {\n                    this._options.callbacks.onSubmitted.apply(this, arguments);\n                    this._uploadFile(id);\n                } else {\n                    this._storeForLater(id);\n                    this._options.callbacks.onSubmitted.apply(this, arguments);\n                }\n            },\n            _onSubmitDelete: function(id, onSuccessCallback, additionalMandatedParams) {\n                var uuid = this.getUuid(id), adjustedOnSuccessCallback;\n                if (onSuccessCallback) {\n                    adjustedOnSuccessCallback = qq.bind(onSuccessCallback, this, id, uuid, additionalMandatedParams);\n                }\n                if (this._isDeletePossible()) {\n                    this._handleCheckedCallback({\n                        name: \"onSubmitDelete\",\n                        callback: qq.bind(this._options.callbacks.onSubmitDelete, this, id),\n                        onSuccess: adjustedOnSuccessCallback || qq.bind(this._deleteHandler.sendDelete, this, id, uuid, additionalMandatedParams),\n                        identifier: id\n                    });\n                    return true;\n                } else {\n                    this.log(\"Delete request ignored for ID \" + id + \", delete feature is disabled or request not possible \" + \"due to CORS on a user agent that does not support pre-flighting.\", \"warn\");\n                    return false;\n                }\n            },\n            _onSubmitted: function(id) {},\n            _onTotalProgress: function(loaded, total) {\n                this._options.callbacks.onTotalProgress(loaded, total);\n            },\n            _onUploadPrep: function(id) {},\n            _onUpload: function(id, name) {\n                this._uploadData.setStatus(id, qq.status.UPLOADING);\n            },\n            _onUploadChunk: function(id, chunkData) {},\n            _onUploadStatusChange: function(id, oldStatus, newStatus) {\n                if (newStatus === qq.status.PAUSED) {\n                    clearTimeout(this._retryTimeouts[id]);\n                }\n            },\n            _onValidateBatchCallbackFailure: function(fileWrappers) {\n                var self = this;\n                qq.each(fileWrappers, function(idx, fileWrapper) {\n                    self._fileOrBlobRejected(fileWrapper.id);\n                });\n            },\n            _onValidateBatchCallbackSuccess: function(validationDescriptors, items, params, endpoint, button) {\n                var errorMessage, itemLimit = this._currentItemLimit, proposedNetFilesUploadedOrQueued = this._netUploadedOrQueued;\n                if (itemLimit === 0 || proposedNetFilesUploadedOrQueued <= itemLimit) {\n                    if (items.length > 0) {\n                        this._handleCheckedCallback({\n                            name: \"onValidate\",\n                            callback: qq.bind(this._options.callbacks.onValidate, this, validationDescriptors[0], button),\n                            onSuccess: qq.bind(this._onValidateCallbackSuccess, this, items, 0, params, endpoint),\n                            onFailure: qq.bind(this._onValidateCallbackFailure, this, items, 0, params, endpoint),\n                            identifier: \"Item '\" + items[0].file.name + \"', size: \" + items[0].file.size\n                        });\n                    } else {\n                        this._itemError(\"noFilesError\");\n                    }\n                } else {\n                    this._onValidateBatchCallbackFailure(items);\n                    errorMessage = this._options.messages.tooManyItemsError.replace(/\\{netItems\\}/g, proposedNetFilesUploadedOrQueued).replace(/\\{itemLimit\\}/g, itemLimit);\n                    this._batchError(errorMessage);\n                }\n            },\n            _onValidateCallbackFailure: function(items, index, params, endpoint) {\n                var nextIndex = index + 1;\n                this._fileOrBlobRejected(items[index].id, items[index].file.name);\n                this._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n            },\n            _onValidateCallbackSuccess: function(items, index, params, endpoint) {\n                var self = this, nextIndex = index + 1, validationDescriptor = this._getValidationDescriptor(items[index]);\n                this._validateFileOrBlobData(items[index], validationDescriptor).then(function() {\n                    self._upload(items[index].id, params, endpoint);\n                    self._maybeProcessNextItemAfterOnValidateCallback(true, items, nextIndex, params, endpoint);\n                }, function() {\n                    self._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n                });\n            },\n            _prepareItemsForUpload: function(items, params, endpoint) {\n                if (items.length === 0) {\n                    this._itemError(\"noFilesError\");\n                    return;\n                }\n                var validationDescriptors = this._getValidationDescriptors(items), buttonId = this._getButtonId(items[0].file), button = this._getButton(buttonId);\n                this._handleCheckedCallback({\n                    name: \"onValidateBatch\",\n                    callback: qq.bind(this._options.callbacks.onValidateBatch, this, validationDescriptors, button),\n                    onSuccess: qq.bind(this._onValidateBatchCallbackSuccess, this, validationDescriptors, items, params, endpoint, button),\n                    onFailure: qq.bind(this._onValidateBatchCallbackFailure, this, items),\n                    identifier: \"batch validation\"\n                });\n            },\n            _preventLeaveInProgress: function() {\n                var self = this;\n                this._disposeSupport.attach(window, \"beforeunload\", function(e) {\n                    if (self.getInProgress()) {\n                        e = e || window.event;\n                        e.returnValue = self._options.messages.onLeave;\n                        return self._options.messages.onLeave;\n                    }\n                });\n            },\n            _refreshSessionData: function() {\n                var self = this, options = this._options.session;\n                if (qq.Session && this._options.session.endpoint != null) {\n                    if (!this._session) {\n                        qq.extend(options, {\n                            cors: this._options.cors\n                        });\n                        options.log = qq.bind(this.log, this);\n                        options.addFileRecord = qq.bind(this._addCannedFile, this);\n                        this._session = new qq.Session(options);\n                    }\n                    setTimeout(function() {\n                        self._session.refresh().then(function(response, xhrOrXdr) {\n                            self._sessionRequestComplete();\n                            self._options.callbacks.onSessionRequestComplete(response, true, xhrOrXdr);\n                        }, function(response, xhrOrXdr) {\n                            self._options.callbacks.onSessionRequestComplete(response, false, xhrOrXdr);\n                        });\n                    }, 0);\n                }\n            },\n            _sessionRequestComplete: function() {},\n            _setSize: function(id, newSize) {\n                this._uploadData.updateSize(id, newSize);\n                this._totalProgress && this._totalProgress.onNewSize(id);\n            },\n            _shouldAutoRetry: function(id, name, responseJSON) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (!this._preventRetries[id] && this._options.retry.enableAuto && uploadData.status !== qq.status.PAUSED) {\n                    if (this._autoRetries[id] === undefined) {\n                        this._autoRetries[id] = 0;\n                    }\n                    if (this._autoRetries[id] < this._options.retry.maxAutoAttempts) {\n                        this._autoRetries[id] += 1;\n                        return true;\n                    }\n                }\n                return false;\n            },\n            _storeForLater: function(id) {\n                this._storedIds.push(id);\n            },\n            _trackButton: function(id) {\n                var buttonId;\n                if (qq.supportedFeatures.ajaxUploading) {\n                    buttonId = this._handler.getFile(id).qqButtonId;\n                } else {\n                    buttonId = this._getButtonId(this._handler.getInput(id));\n                }\n                if (buttonId) {\n                    this._buttonIdsForFileIds[id] = buttonId;\n                }\n            },\n            _updateFormSupportAndParams: function(formElementOrId) {\n                this._options.form.element = formElementOrId;\n                this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n                if (this._formSupport && this._formSupport.attachedToForm) {\n                    this._paramsStore.addReadOnly(null, this._formSupport.getFormInputsAsObject);\n                    this._options.autoUpload = this._formSupport.newAutoUpload;\n                    if (this._formSupport.newEndpoint) {\n                        this.setEndpoint(this._formSupport.newEndpoint);\n                    }\n                }\n            },\n            _upload: function(id, params, endpoint) {\n                var name = this.getName(id);\n                if (params) {\n                    this.setParams(params, id);\n                }\n                if (endpoint) {\n                    this.setEndpoint(endpoint, id);\n                }\n                this._handleCheckedCallback({\n                    name: \"onSubmit\",\n                    callback: qq.bind(this._options.callbacks.onSubmit, this, id, name),\n                    onSuccess: qq.bind(this._onSubmitCallbackSuccess, this, id, name),\n                    onFailure: qq.bind(this._fileOrBlobRejected, this, id, name),\n                    identifier: id\n                });\n            },\n            _uploadFile: function(id) {\n                if (!this._handler.upload(id)) {\n                    this._uploadData.setStatus(id, qq.status.QUEUED);\n                }\n            },\n            _uploadStoredFiles: function() {\n                var idToUpload, stillSubmitting, self = this;\n                while (this._storedIds.length) {\n                    idToUpload = this._storedIds.shift();\n                    this._uploadFile(idToUpload);\n                }\n                stillSubmitting = this.getUploads({\n                    status: qq.status.SUBMITTING\n                }).length;\n                if (stillSubmitting) {\n                    qq.log(\"Still waiting for \" + stillSubmitting + \" files to clear submit queue. Will re-parse stored IDs array shortly.\");\n                    setTimeout(function() {\n                        self._uploadStoredFiles();\n                    }, 1e3);\n                }\n            },\n            _validateFileOrBlobData: function(fileWrapper, validationDescriptor) {\n                var self = this, file = function() {\n                    if (fileWrapper.file instanceof qq.BlobProxy) {\n                        return fileWrapper.file.referenceBlob;\n                    }\n                    return fileWrapper.file;\n                }(), name = validationDescriptor.name, size = validationDescriptor.size, buttonId = this._getButtonId(fileWrapper.file), validationBase = this._getValidationBase(buttonId), validityChecker = new qq.Promise();\n                validityChecker.then(function() {}, function() {\n                    self._fileOrBlobRejected(fileWrapper.id, name);\n                });\n                if (qq.isFileOrInput(file) && !this._isAllowedExtension(validationBase.allowedExtensions, name)) {\n                    this._itemError(\"typeError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (size === 0) {\n                    this._itemError(\"emptyError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (size > 0 && validationBase.sizeLimit && size > validationBase.sizeLimit) {\n                    this._itemError(\"sizeError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (size > 0 && size < validationBase.minSizeLimit) {\n                    this._itemError(\"minSizeError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (qq.ImageValidation && qq.supportedFeatures.imagePreviews && qq.isFile(file)) {\n                    new qq.ImageValidation(file, qq.bind(self.log, self)).validate(validationBase.image).then(validityChecker.success, function(errorCode) {\n                        self._itemError(errorCode + \"ImageError\", name, file);\n                        validityChecker.failure();\n                    });\n                } else {\n                    validityChecker.success();\n                }\n                return validityChecker;\n            },\n            _wrapCallbacks: function() {\n                var self, safeCallback, prop;\n                self = this;\n                safeCallback = function(name, callback, args) {\n                    var errorMsg;\n                    try {\n                        return callback.apply(self, args);\n                    } catch (exception) {\n                        errorMsg = exception.message || exception.toString();\n                        self.log(\"Caught exception in '\" + name + \"' callback - \" + errorMsg, \"error\");\n                    }\n                };\n                for (prop in this._options.callbacks) {\n                    (function() {\n                        var callbackName, callbackFunc;\n                        callbackName = prop;\n                        callbackFunc = self._options.callbacks[callbackName];\n                        self._options.callbacks[callbackName] = function() {\n                            return safeCallback(callbackName, callbackFunc, arguments);\n                        };\n                    })();\n                }\n            }\n        };\n    })();\n    (function() {\n        \"use strict\";\n        qq.FineUploaderBasic = function(o) {\n            var self = this;\n            this._options = {\n                debug: false,\n                button: null,\n                multiple: true,\n                maxConnections: 3,\n                disableCancelForFormUploads: false,\n                autoUpload: true,\n                request: {\n                    customHeaders: {},\n                    endpoint: \"/server/upload\",\n                    filenameParam: \"qqfilename\",\n                    forceMultipart: true,\n                    inputName: \"qqfile\",\n                    method: \"POST\",\n                    params: {},\n                    paramsInBody: true,\n                    totalFileSizeName: \"qqtotalfilesize\",\n                    uuidName: \"qquuid\"\n                },\n                validation: {\n                    allowedExtensions: [],\n                    sizeLimit: 0,\n                    minSizeLimit: 0,\n                    itemLimit: 0,\n                    stopOnFirstInvalidFile: true,\n                    acceptFiles: null,\n                    image: {\n                        maxHeight: 0,\n                        maxWidth: 0,\n                        minHeight: 0,\n                        minWidth: 0\n                    }\n                },\n                callbacks: {\n                    onSubmit: function(id, name) {},\n                    onSubmitted: function(id, name) {},\n                    onComplete: function(id, name, responseJSON, maybeXhr) {},\n                    onAllComplete: function(successful, failed) {},\n                    onCancel: function(id, name) {},\n                    onUpload: function(id, name) {},\n                    onUploadChunk: function(id, name, chunkData) {},\n                    onUploadChunkSuccess: function(id, chunkData, responseJSON, xhr) {},\n                    onResume: function(id, fileName, chunkData) {},\n                    onProgress: function(id, name, loaded, total) {},\n                    onTotalProgress: function(loaded, total) {},\n                    onError: function(id, name, reason, maybeXhrOrXdr) {},\n                    onAutoRetry: function(id, name, attemptNumber) {},\n                    onManualRetry: function(id, name) {},\n                    onValidateBatch: function(fileOrBlobData) {},\n                    onValidate: function(fileOrBlobData) {},\n                    onSubmitDelete: function(id) {},\n                    onDelete: function(id) {},\n                    onDeleteComplete: function(id, xhrOrXdr, isError) {},\n                    onPasteReceived: function(blob) {},\n                    onStatusChange: function(id, oldStatus, newStatus) {},\n                    onSessionRequestComplete: function(response, success, xhrOrXdr) {}\n                },\n                messages: {\n                    typeError: \"{file} has an invalid extension. Valid extension(s): {extensions}.\",\n                    sizeError: \"{file} is too large, maximum file size is {sizeLimit}.\",\n                    minSizeError: \"{file} is too small, minimum file size is {minSizeLimit}.\",\n                    emptyError: \"{file} is empty, please select files again without it.\",\n                    noFilesError: \"No files to upload.\",\n                    tooManyItemsError: \"Too many items ({netItems}) would be uploaded.  Item limit is {itemLimit}.\",\n                    maxHeightImageError: \"Image is too tall.\",\n                    maxWidthImageError: \"Image is too wide.\",\n                    minHeightImageError: \"Image is not tall enough.\",\n                    minWidthImageError: \"Image is not wide enough.\",\n                    retryFailTooManyItems: \"Retry failed - you have reached your file limit.\",\n                    onLeave: \"The files are being uploaded, if you leave now the upload will be canceled.\",\n                    unsupportedBrowserIos8Safari: \"Unrecoverable error - this browser does not permit file uploading of any kind due to serious bugs in iOS8 Safari.  Please use iOS8 Chrome until Apple fixes these issues.\"\n                },\n                retry: {\n                    enableAuto: false,\n                    maxAutoAttempts: 3,\n                    autoAttemptDelay: 5,\n                    preventRetryResponseProperty: \"preventRetry\"\n                },\n                classes: {\n                    buttonHover: \"qq-upload-button-hover\",\n                    buttonFocus: \"qq-upload-button-focus\"\n                },\n                chunking: {\n                    enabled: false,\n                    concurrent: {\n                        enabled: false\n                    },\n                    mandatory: false,\n                    paramNames: {\n                        partIndex: \"qqpartindex\",\n                        partByteOffset: \"qqpartbyteoffset\",\n                        chunkSize: \"qqchunksize\",\n                        totalFileSize: \"qqtotalfilesize\",\n                        totalParts: \"qqtotalparts\"\n                    },\n                    partSize: 2e6,\n                    success: {\n                        endpoint: null\n                    }\n                },\n                resume: {\n                    enabled: false,\n                    recordsExpireIn: 7,\n                    paramNames: {\n                        resuming: \"qqresume\"\n                    }\n                },\n                formatFileName: function(fileOrBlobName) {\n                    return fileOrBlobName;\n                },\n                text: {\n                    defaultResponseError: \"Upload failure reason unknown\",\n                    fileInputTitle: \"file input\",\n                    sizeSymbols: [ \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\" ]\n                },\n                deleteFile: {\n                    enabled: false,\n                    method: \"DELETE\",\n                    endpoint: \"/server/upload\",\n                    customHeaders: {},\n                    params: {}\n                },\n                cors: {\n                    expected: false,\n                    sendCredentials: false,\n                    allowXdr: false\n                },\n                blobs: {\n                    defaultName: \"misc_data\"\n                },\n                paste: {\n                    targetElement: null,\n                    defaultName: \"pasted_image\"\n                },\n                camera: {\n                    ios: false,\n                    button: null\n                },\n                extraButtons: [],\n                session: {\n                    endpoint: null,\n                    params: {},\n                    customHeaders: {},\n                    refreshOnReset: true\n                },\n                form: {\n                    element: \"qq-form\",\n                    autoUpload: false,\n                    interceptSubmit: true\n                },\n                scaling: {\n                    customResizer: null,\n                    sendOriginal: true,\n                    orient: true,\n                    defaultType: null,\n                    defaultQuality: 80,\n                    failureText: \"Failed to scale\",\n                    includeExif: false,\n                    sizes: []\n                },\n                workarounds: {\n                    iosEmptyVideos: true,\n                    ios8SafariUploads: true,\n                    ios8BrowserCrash: false\n                }\n            };\n            qq.extend(this._options, o, true);\n            this._buttons = [];\n            this._extraButtonSpecs = {};\n            this._buttonIdsForFileIds = [];\n            this._wrapCallbacks();\n            this._disposeSupport = new qq.DisposeSupport();\n            this._storedIds = [];\n            this._autoRetries = [];\n            this._retryTimeouts = [];\n            this._preventRetries = [];\n            this._thumbnailUrls = [];\n            this._netUploadedOrQueued = 0;\n            this._netUploaded = 0;\n            this._uploadData = this._createUploadDataTracker();\n            this._initFormSupportAndParams();\n            this._customHeadersStore = this._createStore(this._options.request.customHeaders);\n            this._deleteFileCustomHeadersStore = this._createStore(this._options.deleteFile.customHeaders);\n            this._deleteFileParamsStore = this._createStore(this._options.deleteFile.params);\n            this._endpointStore = this._createStore(this._options.request.endpoint);\n            this._deleteFileEndpointStore = this._createStore(this._options.deleteFile.endpoint);\n            this._handler = this._createUploadHandler();\n            this._deleteHandler = qq.DeleteFileAjaxRequester && this._createDeleteHandler();\n            if (this._options.button) {\n                this._defaultButtonId = this._createUploadButton({\n                    element: this._options.button,\n                    title: this._options.text.fileInputTitle\n                }).getButtonId();\n            }\n            this._generateExtraButtonSpecs();\n            this._handleCameraAccess();\n            if (this._options.paste.targetElement) {\n                if (qq.PasteSupport) {\n                    this._pasteHandler = this._createPasteHandler();\n                } else {\n                    this.log(\"Paste support module not found\", \"error\");\n                }\n            }\n            this._preventLeaveInProgress();\n            this._imageGenerator = qq.ImageGenerator && new qq.ImageGenerator(qq.bind(this.log, this));\n            this._refreshSessionData();\n            this._succeededSinceLastAllComplete = [];\n            this._failedSinceLastAllComplete = [];\n            this._scaler = qq.Scaler && new qq.Scaler(this._options.scaling, qq.bind(this.log, this)) || {};\n            if (this._scaler.enabled) {\n                this._customNewFileHandler = qq.bind(this._scaler.handleNewFile, this._scaler);\n            }\n            if (qq.TotalProgress && qq.supportedFeatures.progressBar) {\n                this._totalProgress = new qq.TotalProgress(qq.bind(this._onTotalProgress, this), function(id) {\n                    var entry = self._uploadData.retrieve({\n                        id: id\n                    });\n                    return entry && entry.size || 0;\n                });\n            }\n            this._currentItemLimit = this._options.validation.itemLimit;\n        };\n        qq.FineUploaderBasic.prototype = qq.basePublicApi;\n        qq.extend(qq.FineUploaderBasic.prototype, qq.basePrivateApi);\n    })();\n    qq.AjaxRequester = function(o) {\n        \"use strict\";\n        var log, shouldParamsBeInQueryString, queue = [], requestData = {}, options = {\n            acceptHeader: null,\n            validMethods: [ \"PATCH\", \"POST\", \"PUT\" ],\n            method: \"POST\",\n            contentType: \"application/x-www-form-urlencoded\",\n            maxConnections: 3,\n            customHeaders: {},\n            endpointStore: {},\n            paramsStore: {},\n            mandatedParams: {},\n            allowXRequestedWithAndCacheControl: true,\n            successfulResponseCodes: {\n                DELETE: [ 200, 202, 204 ],\n                PATCH: [ 200, 201, 202, 203, 204 ],\n                POST: [ 200, 201, 202, 203, 204 ],\n                PUT: [ 200, 201, 202, 203, 204 ],\n                GET: [ 200 ]\n            },\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {},\n            onSend: function(id) {},\n            onComplete: function(id, xhrOrXdr, isError) {},\n            onProgress: null\n        };\n        qq.extend(options, o);\n        log = options.log;\n        if (qq.indexOf(options.validMethods, options.method) < 0) {\n            throw new Error(\"'\" + options.method + \"' is not a supported method for this type of request!\");\n        }\n        function isSimpleMethod() {\n            return qq.indexOf([ \"GET\", \"POST\", \"HEAD\" ], options.method) >= 0;\n        }\n        function containsNonSimpleHeaders(headers) {\n            var containsNonSimple = false;\n            qq.each(containsNonSimple, function(idx, header) {\n                if (qq.indexOf([ \"Accept\", \"Accept-Language\", \"Content-Language\", \"Content-Type\" ], header) < 0) {\n                    containsNonSimple = true;\n                    return false;\n                }\n            });\n            return containsNonSimple;\n        }\n        function isXdr(xhr) {\n            return options.cors.expected && xhr.withCredentials === undefined;\n        }\n        function getCorsAjaxTransport() {\n            var xhrOrXdr;\n            if (window.XMLHttpRequest || window.ActiveXObject) {\n                xhrOrXdr = qq.createXhrInstance();\n                if (xhrOrXdr.withCredentials === undefined) {\n                    xhrOrXdr = new XDomainRequest();\n                    xhrOrXdr.onload = function() {};\n                    xhrOrXdr.onerror = function() {};\n                    xhrOrXdr.ontimeout = function() {};\n                    xhrOrXdr.onprogress = function() {};\n                }\n            }\n            return xhrOrXdr;\n        }\n        function getXhrOrXdr(id, suppliedXhr) {\n            var xhrOrXdr = requestData[id].xhr;\n            if (!xhrOrXdr) {\n                if (suppliedXhr) {\n                    xhrOrXdr = suppliedXhr;\n                } else {\n                    if (options.cors.expected) {\n                        xhrOrXdr = getCorsAjaxTransport();\n                    } else {\n                        xhrOrXdr = qq.createXhrInstance();\n                    }\n                }\n                requestData[id].xhr = xhrOrXdr;\n            }\n            return xhrOrXdr;\n        }\n        function dequeue(id) {\n            var i = qq.indexOf(queue, id), max = options.maxConnections, nextId;\n            delete requestData[id];\n            queue.splice(i, 1);\n            if (queue.length >= max && i < max) {\n                nextId = queue[max - 1];\n                sendRequest(nextId);\n            }\n        }\n        function onComplete(id, xdrError) {\n            var xhr = getXhrOrXdr(id), method = options.method, isError = xdrError === true;\n            dequeue(id);\n            if (isError) {\n                log(method + \" request for \" + id + \" has failed\", \"error\");\n            } else if (!isXdr(xhr) && !isResponseSuccessful(xhr.status)) {\n                isError = true;\n                log(method + \" request for \" + id + \" has failed - response code \" + xhr.status, \"error\");\n            }\n            options.onComplete(id, xhr, isError);\n        }\n        function getParams(id) {\n            var onDemandParams = requestData[id].additionalParams, mandatedParams = options.mandatedParams, params;\n            if (options.paramsStore.get) {\n                params = options.paramsStore.get(id);\n            }\n            if (onDemandParams) {\n                qq.each(onDemandParams, function(name, val) {\n                    params = params || {};\n                    params[name] = val;\n                });\n            }\n            if (mandatedParams) {\n                qq.each(mandatedParams, function(name, val) {\n                    params = params || {};\n                    params[name] = val;\n                });\n            }\n            return params;\n        }\n        function sendRequest(id, optXhr) {\n            var xhr = getXhrOrXdr(id, optXhr), method = options.method, params = getParams(id), payload = requestData[id].payload, url;\n            options.onSend(id);\n            url = createUrl(id, params, requestData[id].additionalQueryParams);\n            if (isXdr(xhr)) {\n                xhr.onload = getXdrLoadHandler(id);\n                xhr.onerror = getXdrErrorHandler(id);\n            } else {\n                xhr.onreadystatechange = getXhrReadyStateChangeHandler(id);\n            }\n            registerForUploadProgress(id);\n            xhr.open(method, url, true);\n            if (options.cors.expected && options.cors.sendCredentials && !isXdr(xhr)) {\n                xhr.withCredentials = true;\n            }\n            setHeaders(id);\n            log(\"Sending \" + method + \" request for \" + id);\n            if (payload) {\n                xhr.send(payload);\n            } else if (shouldParamsBeInQueryString || !params) {\n                xhr.send();\n            } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/x-www-form-urlencoded\") >= 0) {\n                xhr.send(qq.obj2url(params, \"\"));\n            } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/json\") >= 0) {\n                xhr.send(JSON.stringify(params));\n            } else {\n                xhr.send(params);\n            }\n            return xhr;\n        }\n        function createUrl(id, params, additionalQueryParams) {\n            var endpoint = options.endpointStore.get(id), addToPath = requestData[id].addToPath;\n            if (addToPath != undefined) {\n                endpoint += \"/\" + addToPath;\n            }\n            if (shouldParamsBeInQueryString && params) {\n                endpoint = qq.obj2url(params, endpoint);\n            }\n            if (additionalQueryParams) {\n                endpoint = qq.obj2url(additionalQueryParams, endpoint);\n            }\n            return endpoint;\n        }\n        function getXhrReadyStateChangeHandler(id) {\n            return function() {\n                if (getXhrOrXdr(id).readyState === 4) {\n                    onComplete(id);\n                }\n            };\n        }\n        function registerForUploadProgress(id) {\n            var onProgress = options.onProgress;\n            if (onProgress) {\n                getXhrOrXdr(id).upload.onprogress = function(e) {\n                    if (e.lengthComputable) {\n                        onProgress(id, e.loaded, e.total);\n                    }\n                };\n            }\n        }\n        function getXdrLoadHandler(id) {\n            return function() {\n                onComplete(id);\n            };\n        }\n        function getXdrErrorHandler(id) {\n            return function() {\n                onComplete(id, true);\n            };\n        }\n        function setHeaders(id) {\n            var xhr = getXhrOrXdr(id), customHeaders = options.customHeaders, onDemandHeaders = requestData[id].additionalHeaders || {}, method = options.method, allHeaders = {};\n            if (!isXdr(xhr)) {\n                options.acceptHeader && xhr.setRequestHeader(\"Accept\", options.acceptHeader);\n                if (options.allowXRequestedWithAndCacheControl) {\n                    if (!options.cors.expected || (!isSimpleMethod() || containsNonSimpleHeaders(customHeaders))) {\n                        xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n                        xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n                    }\n                }\n                if (options.contentType && (method === \"POST\" || method === \"PUT\")) {\n                    xhr.setRequestHeader(\"Content-Type\", options.contentType);\n                }\n                qq.extend(allHeaders, qq.isFunction(customHeaders) ? customHeaders(id) : customHeaders);\n                qq.extend(allHeaders, onDemandHeaders);\n                qq.each(allHeaders, function(name, val) {\n                    xhr.setRequestHeader(name, val);\n                });\n            }\n        }\n        function isResponseSuccessful(responseCode) {\n            return qq.indexOf(options.successfulResponseCodes[options.method], responseCode) >= 0;\n        }\n        function prepareToSend(id, optXhr, addToPath, additionalParams, additionalQueryParams, additionalHeaders, payload) {\n            requestData[id] = {\n                addToPath: addToPath,\n                additionalParams: additionalParams,\n                additionalQueryParams: additionalQueryParams,\n                additionalHeaders: additionalHeaders,\n                payload: payload\n            };\n            var len = queue.push(id);\n            if (len <= options.maxConnections) {\n                return sendRequest(id, optXhr);\n            }\n        }\n        shouldParamsBeInQueryString = options.method === \"GET\" || options.method === \"DELETE\";\n        qq.extend(this, {\n            initTransport: function(id) {\n                var path, params, headers, payload, cacheBuster, additionalQueryParams;\n                return {\n                    withPath: function(appendToPath) {\n                        path = appendToPath;\n                        return this;\n                    },\n                    withParams: function(additionalParams) {\n                        params = additionalParams;\n                        return this;\n                    },\n                    withQueryParams: function(_additionalQueryParams_) {\n                        additionalQueryParams = _additionalQueryParams_;\n                        return this;\n                    },\n                    withHeaders: function(additionalHeaders) {\n                        headers = additionalHeaders;\n                        return this;\n                    },\n                    withPayload: function(thePayload) {\n                        payload = thePayload;\n                        return this;\n                    },\n                    withCacheBuster: function() {\n                        cacheBuster = true;\n                        return this;\n                    },\n                    send: function(optXhr) {\n                        if (cacheBuster && qq.indexOf([ \"GET\", \"DELETE\" ], options.method) >= 0) {\n                            params.qqtimestamp = new Date().getTime();\n                        }\n                        return prepareToSend(id, optXhr, path, params, additionalQueryParams, headers, payload);\n                    }\n                };\n            },\n            canceled: function(id) {\n                dequeue(id);\n            }\n        });\n    };\n    qq.UploadHandler = function(spec) {\n        \"use strict\";\n        var proxy = spec.proxy, fileState = {}, onCancel = proxy.onCancel, getName = proxy.getName;\n        qq.extend(this, {\n            add: function(id, fileItem) {\n                fileState[id] = fileItem;\n                fileState[id].temp = {};\n            },\n            cancel: function(id) {\n                var self = this, cancelFinalizationEffort = new qq.Promise(), onCancelRetVal = onCancel(id, getName(id), cancelFinalizationEffort);\n                onCancelRetVal.then(function() {\n                    if (self.isValid(id)) {\n                        fileState[id].canceled = true;\n                        self.expunge(id);\n                    }\n                    cancelFinalizationEffort.success();\n                });\n            },\n            expunge: function(id) {\n                delete fileState[id];\n            },\n            getThirdPartyFileId: function(id) {\n                return fileState[id].key;\n            },\n            isValid: function(id) {\n                return fileState[id] !== undefined;\n            },\n            reset: function() {\n                fileState = {};\n            },\n            _getFileState: function(id) {\n                return fileState[id];\n            },\n            _setThirdPartyFileId: function(id, thirdPartyFileId) {\n                fileState[id].key = thirdPartyFileId;\n            },\n            _wasCanceled: function(id) {\n                return !!fileState[id].canceled;\n            }\n        });\n    };\n    qq.UploadHandlerController = function(o, namespace) {\n        \"use strict\";\n        var controller = this, chunkingPossible = false, concurrentChunkingPossible = false, chunking, preventRetryResponse, log, handler, options = {\n            paramsStore: {},\n            maxConnections: 3,\n            chunking: {\n                enabled: false,\n                multiple: {\n                    enabled: false\n                }\n            },\n            log: function(str, level) {},\n            onProgress: function(id, fileName, loaded, total) {},\n            onComplete: function(id, fileName, response, xhr) {},\n            onCancel: function(id, fileName) {},\n            onUploadPrep: function(id) {},\n            onUpload: function(id, fileName) {},\n            onUploadChunk: function(id, fileName, chunkData) {},\n            onUploadChunkSuccess: function(id, chunkData, response, xhr) {},\n            onAutoRetry: function(id, fileName, response, xhr) {},\n            onResume: function(id, fileName, chunkData) {},\n            onUuidChanged: function(id, newUuid) {},\n            getName: function(id) {},\n            setSize: function(id, newSize) {},\n            isQueued: function(id) {},\n            getIdsInProxyGroup: function(id) {},\n            getIdsInBatch: function(id) {}\n        }, chunked = {\n            done: function(id, chunkIdx, response, xhr) {\n                var chunkData = handler._getChunkData(id, chunkIdx);\n                handler._getFileState(id).attemptingResume = false;\n                delete handler._getFileState(id).temp.chunkProgress[chunkIdx];\n                handler._getFileState(id).loaded += chunkData.size;\n                options.onUploadChunkSuccess(id, handler._getChunkDataForCallback(chunkData), response, xhr);\n            },\n            finalize: function(id) {\n                var size = options.getSize(id), name = options.getName(id);\n                log(\"All chunks have been uploaded for \" + id + \" - finalizing....\");\n                handler.finalizeChunks(id).then(function(response, xhr) {\n                    log(\"Finalize successful for \" + id);\n                    var normaizedResponse = upload.normalizeResponse(response, true);\n                    options.onProgress(id, name, size, size);\n                    handler._maybeDeletePersistedChunkData(id);\n                    upload.cleanup(id, normaizedResponse, xhr);\n                }, function(response, xhr) {\n                    var normaizedResponse = upload.normalizeResponse(response, false);\n                    log(\"Problem finalizing chunks for file ID \" + id + \" - \" + normaizedResponse.error, \"error\");\n                    if (normaizedResponse.reset) {\n                        chunked.reset(id);\n                    }\n                    if (!options.onAutoRetry(id, name, normaizedResponse, xhr)) {\n                        upload.cleanup(id, normaizedResponse, xhr);\n                    }\n                });\n            },\n            handleFailure: function(chunkIdx, id, response, xhr) {\n                var name = options.getName(id);\n                log(\"Chunked upload request failed for \" + id + \", chunk \" + chunkIdx);\n                handler.clearCachedChunk(id, chunkIdx);\n                var responseToReport = upload.normalizeResponse(response, false), inProgressIdx;\n                if (responseToReport.reset) {\n                    chunked.reset(id);\n                } else {\n                    inProgressIdx = qq.indexOf(handler._getFileState(id).chunking.inProgress, chunkIdx);\n                    if (inProgressIdx >= 0) {\n                        handler._getFileState(id).chunking.inProgress.splice(inProgressIdx, 1);\n                        handler._getFileState(id).chunking.remaining.unshift(chunkIdx);\n                    }\n                }\n                if (!handler._getFileState(id).temp.ignoreFailure) {\n                    if (concurrentChunkingPossible) {\n                        handler._getFileState(id).temp.ignoreFailure = true;\n                        log(qq.format(\"Going to attempt to abort these chunks: {}. These are currently in-progress: {}.\", JSON.stringify(Object.keys(handler._getXhrs(id))), JSON.stringify(handler._getFileState(id).chunking.inProgress)));\n                        qq.each(handler._getXhrs(id), function(ckid, ckXhr) {\n                            log(qq.format(\"Attempting to abort file {}.{}. XHR readyState {}. \", id, ckid, ckXhr.readyState));\n                            ckXhr.abort();\n                            ckXhr._cancelled = true;\n                        });\n                        handler.moveInProgressToRemaining(id);\n                        connectionManager.free(id, true);\n                    }\n                    if (!options.onAutoRetry(id, name, responseToReport, xhr)) {\n                        upload.cleanup(id, responseToReport, xhr);\n                    }\n                }\n            },\n            hasMoreParts: function(id) {\n                return !!handler._getFileState(id).chunking.remaining.length;\n            },\n            nextPart: function(id) {\n                var nextIdx = handler._getFileState(id).chunking.remaining.shift();\n                if (nextIdx >= handler._getTotalChunks(id)) {\n                    nextIdx = null;\n                }\n                return nextIdx;\n            },\n            reset: function(id) {\n                log(\"Server or callback has ordered chunking effort to be restarted on next attempt for item ID \" + id, \"error\");\n                handler._maybeDeletePersistedChunkData(id);\n                handler.reevaluateChunking(id);\n                handler._getFileState(id).loaded = 0;\n            },\n            sendNext: function(id) {\n                var size = options.getSize(id), name = options.getName(id), chunkIdx = chunked.nextPart(id), chunkData = handler._getChunkData(id, chunkIdx), resuming = handler._getFileState(id).attemptingResume, inProgressChunks = handler._getFileState(id).chunking.inProgress || [];\n                if (handler._getFileState(id).loaded == null) {\n                    handler._getFileState(id).loaded = 0;\n                }\n                if (resuming && options.onResume(id, name, chunkData) === false) {\n                    chunked.reset(id);\n                    chunkIdx = chunked.nextPart(id);\n                    chunkData = handler._getChunkData(id, chunkIdx);\n                    resuming = false;\n                }\n                if (chunkIdx == null && inProgressChunks.length === 0) {\n                    chunked.finalize(id);\n                } else {\n                    log(qq.format(\"Sending chunked upload request for item {}.{}, bytes {}-{} of {}.\", id, chunkIdx, chunkData.start + 1, chunkData.end, size));\n                    options.onUploadChunk(id, name, handler._getChunkDataForCallback(chunkData));\n                    inProgressChunks.push(chunkIdx);\n                    handler._getFileState(id).chunking.inProgress = inProgressChunks;\n                    if (concurrentChunkingPossible) {\n                        connectionManager.open(id, chunkIdx);\n                    }\n                    if (concurrentChunkingPossible && connectionManager.available() && handler._getFileState(id).chunking.remaining.length) {\n                        chunked.sendNext(id);\n                    }\n                    if (chunkData.blob.size === 0) {\n                        log(qq.format(\"Chunk {} for file {} will not be uploaded, zero sized chunk.\", chunkIdx, id), \"error\");\n                        chunked.handleFailure(chunkIdx, id, \"File is no longer available\", null);\n                    } else {\n                        handler.uploadChunk(id, chunkIdx, resuming).then(function success(response, xhr) {\n                            log(\"Chunked upload request succeeded for \" + id + \", chunk \" + chunkIdx);\n                            handler.clearCachedChunk(id, chunkIdx);\n                            var inProgressChunks = handler._getFileState(id).chunking.inProgress || [], responseToReport = upload.normalizeResponse(response, true), inProgressChunkIdx = qq.indexOf(inProgressChunks, chunkIdx);\n                            log(qq.format(\"Chunk {} for file {} uploaded successfully.\", chunkIdx, id));\n                            chunked.done(id, chunkIdx, responseToReport, xhr);\n                            if (inProgressChunkIdx >= 0) {\n                                inProgressChunks.splice(inProgressChunkIdx, 1);\n                            }\n                            handler._maybePersistChunkedState(id);\n                            if (!chunked.hasMoreParts(id) && inProgressChunks.length === 0) {\n                                chunked.finalize(id);\n                            } else if (chunked.hasMoreParts(id)) {\n                                chunked.sendNext(id);\n                            } else {\n                                log(qq.format(\"File ID {} has no more chunks to send and these chunk indexes are still marked as in-progress: {}\", id, JSON.stringify(inProgressChunks)));\n                            }\n                        }, function failure(response, xhr) {\n                            chunked.handleFailure(chunkIdx, id, response, xhr);\n                        }).done(function() {\n                            handler.clearXhr(id, chunkIdx);\n                        });\n                    }\n                }\n            }\n        }, connectionManager = {\n            _open: [],\n            _openChunks: {},\n            _waiting: [],\n            available: function() {\n                var max = options.maxConnections, openChunkEntriesCount = 0, openChunksCount = 0;\n                qq.each(connectionManager._openChunks, function(fileId, openChunkIndexes) {\n                    openChunkEntriesCount++;\n                    openChunksCount += openChunkIndexes.length;\n                });\n                return max - (connectionManager._open.length - openChunkEntriesCount + openChunksCount);\n            },\n            free: function(id, dontAllowNext) {\n                var allowNext = !dontAllowNext, waitingIndex = qq.indexOf(connectionManager._waiting, id), connectionsIndex = qq.indexOf(connectionManager._open, id), nextId;\n                delete connectionManager._openChunks[id];\n                if (upload.getProxyOrBlob(id) instanceof qq.BlobProxy) {\n                    log(\"Generated blob upload has ended for \" + id + \", disposing generated blob.\");\n                    delete handler._getFileState(id).file;\n                }\n                if (waitingIndex >= 0) {\n                    connectionManager._waiting.splice(waitingIndex, 1);\n                } else if (allowNext && connectionsIndex >= 0) {\n                    connectionManager._open.splice(connectionsIndex, 1);\n                    nextId = connectionManager._waiting.shift();\n                    if (nextId >= 0) {\n                        connectionManager._open.push(nextId);\n                        upload.start(nextId);\n                    }\n                }\n            },\n            getWaitingOrConnected: function() {\n                var waitingOrConnected = [];\n                qq.each(connectionManager._openChunks, function(fileId, chunks) {\n                    if (chunks && chunks.length) {\n                        waitingOrConnected.push(parseInt(fileId));\n                    }\n                });\n                qq.each(connectionManager._open, function(idx, fileId) {\n                    if (!connectionManager._openChunks[fileId]) {\n                        waitingOrConnected.push(parseInt(fileId));\n                    }\n                });\n                waitingOrConnected = waitingOrConnected.concat(connectionManager._waiting);\n                return waitingOrConnected;\n            },\n            isUsingConnection: function(id) {\n                return qq.indexOf(connectionManager._open, id) >= 0;\n            },\n            open: function(id, chunkIdx) {\n                if (chunkIdx == null) {\n                    connectionManager._waiting.push(id);\n                }\n                if (connectionManager.available()) {\n                    if (chunkIdx == null) {\n                        connectionManager._waiting.pop();\n                        connectionManager._open.push(id);\n                    } else {\n                        (function() {\n                            var openChunksEntry = connectionManager._openChunks[id] || [];\n                            openChunksEntry.push(chunkIdx);\n                            connectionManager._openChunks[id] = openChunksEntry;\n                        })();\n                    }\n                    return true;\n                }\n                return false;\n            },\n            reset: function() {\n                connectionManager._waiting = [];\n                connectionManager._open = [];\n            }\n        }, simple = {\n            send: function(id, name) {\n                handler._getFileState(id).loaded = 0;\n                log(\"Sending simple upload request for \" + id);\n                handler.uploadFile(id).then(function(response, optXhr) {\n                    log(\"Simple upload request succeeded for \" + id);\n                    var responseToReport = upload.normalizeResponse(response, true), size = options.getSize(id);\n                    options.onProgress(id, name, size, size);\n                    upload.maybeNewUuid(id, responseToReport);\n                    upload.cleanup(id, responseToReport, optXhr);\n                }, function(response, optXhr) {\n                    log(\"Simple upload request failed for \" + id);\n                    var responseToReport = upload.normalizeResponse(response, false);\n                    if (!options.onAutoRetry(id, name, responseToReport, optXhr)) {\n                        upload.cleanup(id, responseToReport, optXhr);\n                    }\n                });\n            }\n        }, upload = {\n            cancel: function(id) {\n                log(\"Cancelling \" + id);\n                options.paramsStore.remove(id);\n                connectionManager.free(id);\n            },\n            cleanup: function(id, response, optXhr) {\n                var name = options.getName(id);\n                options.onComplete(id, name, response, optXhr);\n                if (handler._getFileState(id)) {\n                    handler._clearXhrs && handler._clearXhrs(id);\n                }\n                connectionManager.free(id);\n            },\n            getProxyOrBlob: function(id) {\n                return handler.getProxy && handler.getProxy(id) || handler.getFile && handler.getFile(id);\n            },\n            initHandler: function() {\n                var handlerType = namespace ? qq[namespace] : qq.traditional, handlerModuleSubtype = qq.supportedFeatures.ajaxUploading ? \"Xhr\" : \"Form\";\n                handler = new handlerType[handlerModuleSubtype + \"UploadHandler\"](options, {\n                    getDataByUuid: options.getDataByUuid,\n                    getName: options.getName,\n                    getSize: options.getSize,\n                    getUuid: options.getUuid,\n                    log: log,\n                    onCancel: options.onCancel,\n                    onProgress: options.onProgress,\n                    onUuidChanged: options.onUuidChanged\n                });\n                if (handler._removeExpiredChunkingRecords) {\n                    handler._removeExpiredChunkingRecords();\n                }\n            },\n            isDeferredEligibleForUpload: function(id) {\n                return options.isQueued(id);\n            },\n            maybeDefer: function(id, blob) {\n                if (blob && !handler.getFile(id) && blob instanceof qq.BlobProxy) {\n                    options.onUploadPrep(id);\n                    log(\"Attempting to generate a blob on-demand for \" + id);\n                    blob.create().then(function(generatedBlob) {\n                        log(\"Generated an on-demand blob for \" + id);\n                        handler.updateBlob(id, generatedBlob);\n                        options.setSize(id, generatedBlob.size);\n                        handler.reevaluateChunking(id);\n                        upload.maybeSendDeferredFiles(id);\n                    }, function(errorMessage) {\n                        var errorResponse = {};\n                        if (errorMessage) {\n                            errorResponse.error = errorMessage;\n                        }\n                        log(qq.format(\"Failed to generate blob for ID {}.  Error message: {}.\", id, errorMessage), \"error\");\n                        options.onComplete(id, options.getName(id), qq.extend(errorResponse, preventRetryResponse), null);\n                        upload.maybeSendDeferredFiles(id);\n                        connectionManager.free(id);\n                    });\n                } else {\n                    return upload.maybeSendDeferredFiles(id);\n                }\n                return false;\n            },\n            maybeSendDeferredFiles: function(id) {\n                var idsInGroup = options.getIdsInProxyGroup(id), uploadedThisId = false;\n                if (idsInGroup && idsInGroup.length) {\n                    log(\"Maybe ready to upload proxy group file \" + id);\n                    qq.each(idsInGroup, function(idx, idInGroup) {\n                        if (upload.isDeferredEligibleForUpload(idInGroup) && !!handler.getFile(idInGroup)) {\n                            uploadedThisId = idInGroup === id;\n                            upload.now(idInGroup);\n                        } else if (upload.isDeferredEligibleForUpload(idInGroup)) {\n                            return false;\n                        }\n                    });\n                } else {\n                    uploadedThisId = true;\n                    upload.now(id);\n                }\n                return uploadedThisId;\n            },\n            maybeNewUuid: function(id, response) {\n                if (response.newUuid !== undefined) {\n                    options.onUuidChanged(id, response.newUuid);\n                }\n            },\n            normalizeResponse: function(originalResponse, successful) {\n                var response = originalResponse;\n                if (!qq.isObject(originalResponse)) {\n                    response = {};\n                    if (qq.isString(originalResponse) && !successful) {\n                        response.error = originalResponse;\n                    }\n                }\n                response.success = successful;\n                return response;\n            },\n            now: function(id) {\n                var name = options.getName(id);\n                if (!controller.isValid(id)) {\n                    throw new qq.Error(id + \" is not a valid file ID to upload!\");\n                }\n                options.onUpload(id, name);\n                if (chunkingPossible && handler._shouldChunkThisFile(id)) {\n                    chunked.sendNext(id);\n                } else {\n                    simple.send(id, name);\n                }\n            },\n            start: function(id) {\n                var blobToUpload = upload.getProxyOrBlob(id);\n                if (blobToUpload) {\n                    return upload.maybeDefer(id, blobToUpload);\n                } else {\n                    upload.now(id);\n                    return true;\n                }\n            }\n        };\n        qq.extend(this, {\n            add: function(id, file) {\n                handler.add.apply(this, arguments);\n            },\n            upload: function(id) {\n                if (connectionManager.open(id)) {\n                    return upload.start(id);\n                }\n                return false;\n            },\n            retry: function(id) {\n                if (concurrentChunkingPossible) {\n                    handler._getFileState(id).temp.ignoreFailure = false;\n                }\n                if (connectionManager.isUsingConnection(id)) {\n                    return upload.start(id);\n                } else {\n                    return controller.upload(id);\n                }\n            },\n            cancel: function(id) {\n                var cancelRetVal = handler.cancel(id);\n                if (qq.isGenericPromise(cancelRetVal)) {\n                    cancelRetVal.then(function() {\n                        upload.cancel(id);\n                    });\n                } else if (cancelRetVal !== false) {\n                    upload.cancel(id);\n                }\n            },\n            cancelAll: function() {\n                var waitingOrConnected = connectionManager.getWaitingOrConnected(), i;\n                if (waitingOrConnected.length) {\n                    for (i = waitingOrConnected.length - 1; i >= 0; i--) {\n                        controller.cancel(waitingOrConnected[i]);\n                    }\n                }\n                connectionManager.reset();\n            },\n            getFile: function(id) {\n                if (handler.getProxy && handler.getProxy(id)) {\n                    return handler.getProxy(id).referenceBlob;\n                }\n                return handler.getFile && handler.getFile(id);\n            },\n            isProxied: function(id) {\n                return !!(handler.getProxy && handler.getProxy(id));\n            },\n            getInput: function(id) {\n                if (handler.getInput) {\n                    return handler.getInput(id);\n                }\n            },\n            reset: function() {\n                log(\"Resetting upload handler\");\n                controller.cancelAll();\n                connectionManager.reset();\n                handler.reset();\n            },\n            expunge: function(id) {\n                if (controller.isValid(id)) {\n                    return handler.expunge(id);\n                }\n            },\n            isValid: function(id) {\n                return handler.isValid(id);\n            },\n            getResumableFilesData: function() {\n                if (handler.getResumableFilesData) {\n                    return handler.getResumableFilesData();\n                }\n                return [];\n            },\n            getThirdPartyFileId: function(id) {\n                if (controller.isValid(id)) {\n                    return handler.getThirdPartyFileId(id);\n                }\n            },\n            pause: function(id) {\n                if (controller.isResumable(id) && handler.pause && controller.isValid(id) && handler.pause(id)) {\n                    connectionManager.free(id);\n                    handler.moveInProgressToRemaining(id);\n                    return true;\n                }\n                return false;\n            },\n            isResumable: function(id) {\n                return !!handler.isResumable && handler.isResumable(id);\n            }\n        });\n        qq.extend(options, o);\n        log = options.log;\n        chunkingPossible = options.chunking.enabled && qq.supportedFeatures.chunking;\n        concurrentChunkingPossible = chunkingPossible && options.chunking.concurrent.enabled;\n        preventRetryResponse = function() {\n            var response = {};\n            response[options.preventRetryParam] = true;\n            return response;\n        }();\n        upload.initHandler();\n    };\n    qq.WindowReceiveMessage = function(o) {\n        \"use strict\";\n        var options = {\n            log: function(message, level) {}\n        }, callbackWrapperDetachers = {};\n        qq.extend(options, o);\n        qq.extend(this, {\n            receiveMessage: function(id, callback) {\n                var onMessageCallbackWrapper = function(event) {\n                    callback(event.data);\n                };\n                if (window.postMessage) {\n                    callbackWrapperDetachers[id] = qq(window).attach(\"message\", onMessageCallbackWrapper);\n                } else {\n                    log(\"iframe message passing not supported in this browser!\", \"error\");\n                }\n            },\n            stopReceivingMessages: function(id) {\n                if (window.postMessage) {\n                    var detacher = callbackWrapperDetachers[id];\n                    if (detacher) {\n                        detacher();\n                    }\n                }\n            }\n        });\n    };\n    qq.FormUploadHandler = function(spec) {\n        \"use strict\";\n        var options = spec.options, handler = this, proxy = spec.proxy, formHandlerInstanceId = qq.getUniqueId(), onloadCallbacks = {}, detachLoadEvents = {}, postMessageCallbackTimers = {}, isCors = options.isCors, inputName = options.inputName, getUuid = proxy.getUuid, log = proxy.log, corsMessageReceiver = new qq.WindowReceiveMessage({\n            log: log\n        });\n        function expungeFile(id) {\n            delete detachLoadEvents[id];\n            if (isCors) {\n                clearTimeout(postMessageCallbackTimers[id]);\n                delete postMessageCallbackTimers[id];\n                corsMessageReceiver.stopReceivingMessages(id);\n            }\n            var iframe = document.getElementById(handler._getIframeName(id));\n            if (iframe) {\n                iframe.setAttribute(\"src\", \"javascript:false;\");\n                qq(iframe).remove();\n            }\n        }\n        function getFileIdForIframeName(iframeName) {\n            return iframeName.split(\"_\")[0];\n        }\n        function initIframeForUpload(name) {\n            var iframe = qq.toElement(\"<iframe src='javascript:false;' name='\" + name + \"' />\");\n            iframe.setAttribute(\"id\", name);\n            iframe.style.display = \"none\";\n            document.body.appendChild(iframe);\n            return iframe;\n        }\n        function registerPostMessageCallback(iframe, callback) {\n            var iframeName = iframe.id, fileId = getFileIdForIframeName(iframeName), uuid = getUuid(fileId);\n            onloadCallbacks[uuid] = callback;\n            detachLoadEvents[fileId] = qq(iframe).attach(\"load\", function() {\n                if (handler.getInput(fileId)) {\n                    log(\"Received iframe load event for CORS upload request (iframe name \" + iframeName + \")\");\n                    postMessageCallbackTimers[iframeName] = setTimeout(function() {\n                        var errorMessage = \"No valid message received from loaded iframe for iframe name \" + iframeName;\n                        log(errorMessage, \"error\");\n                        callback({\n                            error: errorMessage\n                        });\n                    }, 1e3);\n                }\n            });\n            corsMessageReceiver.receiveMessage(iframeName, function(message) {\n                log(\"Received the following window message: '\" + message + \"'\");\n                var fileId = getFileIdForIframeName(iframeName), response = handler._parseJsonResponse(message), uuid = response.uuid, onloadCallback;\n                if (uuid && onloadCallbacks[uuid]) {\n                    log(\"Handling response for iframe name \" + iframeName);\n                    clearTimeout(postMessageCallbackTimers[iframeName]);\n                    delete postMessageCallbackTimers[iframeName];\n                    handler._detachLoadEvent(iframeName);\n                    onloadCallback = onloadCallbacks[uuid];\n                    delete onloadCallbacks[uuid];\n                    corsMessageReceiver.stopReceivingMessages(iframeName);\n                    onloadCallback(response);\n                } else if (!uuid) {\n                    log(\"'\" + message + \"' does not contain a UUID - ignoring.\");\n                }\n            });\n        }\n        qq.extend(this, new qq.UploadHandler(spec));\n        qq.override(this, function(super_) {\n            return {\n                add: function(id, fileInput) {\n                    super_.add(id, {\n                        input: fileInput\n                    });\n                    fileInput.setAttribute(\"name\", inputName);\n                    if (fileInput.parentNode) {\n                        qq(fileInput).remove();\n                    }\n                },\n                expunge: function(id) {\n                    expungeFile(id);\n                    super_.expunge(id);\n                },\n                isValid: function(id) {\n                    return super_.isValid(id) && handler._getFileState(id).input !== undefined;\n                }\n            };\n        });\n        qq.extend(this, {\n            getInput: function(id) {\n                return handler._getFileState(id).input;\n            },\n            _attachLoadEvent: function(iframe, callback) {\n                var responseDescriptor;\n                if (isCors) {\n                    registerPostMessageCallback(iframe, callback);\n                } else {\n                    detachLoadEvents[iframe.id] = qq(iframe).attach(\"load\", function() {\n                        log(\"Received response for \" + iframe.id);\n                        if (!iframe.parentNode) {\n                            return;\n                        }\n                        try {\n                            if (iframe.contentDocument && iframe.contentDocument.body && iframe.contentDocument.body.innerHTML == \"false\") {\n                                return;\n                            }\n                        } catch (error) {\n                            log(\"Error when attempting to access iframe during handling of upload response (\" + error.message + \")\", \"error\");\n                            responseDescriptor = {\n                                success: false\n                            };\n                        }\n                        callback(responseDescriptor);\n                    });\n                }\n            },\n            _createIframe: function(id) {\n                var iframeName = handler._getIframeName(id);\n                return initIframeForUpload(iframeName);\n            },\n            _detachLoadEvent: function(id) {\n                if (detachLoadEvents[id] !== undefined) {\n                    detachLoadEvents[id]();\n                    delete detachLoadEvents[id];\n                }\n            },\n            _getIframeName: function(fileId) {\n                return fileId + \"_\" + formHandlerInstanceId;\n            },\n            _initFormForUpload: function(spec) {\n                var method = spec.method, endpoint = spec.endpoint, params = spec.params, paramsInBody = spec.paramsInBody, targetName = spec.targetName, form = qq.toElement(\"<form method='\" + method + \"' enctype='multipart/form-data'></form>\"), url = endpoint;\n                if (paramsInBody) {\n                    qq.obj2Inputs(params, form);\n                } else {\n                    url = qq.obj2url(params, endpoint);\n                }\n                form.setAttribute(\"action\", url);\n                form.setAttribute(\"target\", targetName);\n                form.style.display = \"none\";\n                document.body.appendChild(form);\n                return form;\n            },\n            _parseJsonResponse: function(innerHtmlOrMessage) {\n                var response = {};\n                try {\n                    response = qq.parseJson(innerHtmlOrMessage);\n                } catch (error) {\n                    log(\"Error when attempting to parse iframe upload response (\" + error.message + \")\", \"error\");\n                }\n                return response;\n            }\n        });\n    };\n    qq.XhrUploadHandler = function(spec) {\n        \"use strict\";\n        var handler = this, namespace = spec.options.namespace, proxy = spec.proxy, chunking = spec.options.chunking, resume = spec.options.resume, chunkFiles = chunking && spec.options.chunking.enabled && qq.supportedFeatures.chunking, resumeEnabled = resume && spec.options.resume.enabled && chunkFiles && qq.supportedFeatures.resume, getName = proxy.getName, getSize = proxy.getSize, getUuid = proxy.getUuid, getEndpoint = proxy.getEndpoint, getDataByUuid = proxy.getDataByUuid, onUuidChanged = proxy.onUuidChanged, onProgress = proxy.onProgress, log = proxy.log;\n        function abort(id) {\n            qq.each(handler._getXhrs(id), function(xhrId, xhr) {\n                var ajaxRequester = handler._getAjaxRequester(id, xhrId);\n                xhr.onreadystatechange = null;\n                xhr.upload.onprogress = null;\n                xhr.abort();\n                ajaxRequester && ajaxRequester.canceled && ajaxRequester.canceled(id);\n            });\n        }\n        qq.extend(this, new qq.UploadHandler(spec));\n        qq.override(this, function(super_) {\n            return {\n                add: function(id, blobOrProxy) {\n                    if (qq.isFile(blobOrProxy) || qq.isBlob(blobOrProxy)) {\n                        super_.add(id, {\n                            file: blobOrProxy\n                        });\n                    } else if (blobOrProxy instanceof qq.BlobProxy) {\n                        super_.add(id, {\n                            proxy: blobOrProxy\n                        });\n                    } else {\n                        throw new Error(\"Passed obj is not a File, Blob, or proxy\");\n                    }\n                    handler._initTempState(id);\n                    resumeEnabled && handler._maybePrepareForResume(id);\n                },\n                expunge: function(id) {\n                    abort(id);\n                    handler._maybeDeletePersistedChunkData(id);\n                    handler._clearXhrs(id);\n                    super_.expunge(id);\n                }\n            };\n        });\n        qq.extend(this, {\n            clearCachedChunk: function(id, chunkIdx) {\n                delete handler._getFileState(id).temp.cachedChunks[chunkIdx];\n            },\n            clearXhr: function(id, chunkIdx) {\n                var tempState = handler._getFileState(id).temp;\n                if (tempState.xhrs) {\n                    delete tempState.xhrs[chunkIdx];\n                }\n                if (tempState.ajaxRequesters) {\n                    delete tempState.ajaxRequesters[chunkIdx];\n                }\n            },\n            finalizeChunks: function(id, responseParser) {\n                var lastChunkIdx = handler._getTotalChunks(id) - 1, xhr = handler._getXhr(id, lastChunkIdx);\n                if (responseParser) {\n                    return new qq.Promise().success(responseParser(xhr), xhr);\n                }\n                return new qq.Promise().success({}, xhr);\n            },\n            getFile: function(id) {\n                return handler.isValid(id) && handler._getFileState(id).file;\n            },\n            getProxy: function(id) {\n                return handler.isValid(id) && handler._getFileState(id).proxy;\n            },\n            getResumableFilesData: function() {\n                var resumableFilesData = [];\n                handler._iterateResumeRecords(function(key, uploadData) {\n                    handler.moveInProgressToRemaining(null, uploadData.chunking.inProgress, uploadData.chunking.remaining);\n                    var data = {\n                        name: uploadData.name,\n                        remaining: uploadData.chunking.remaining,\n                        size: uploadData.size,\n                        uuid: uploadData.uuid\n                    };\n                    if (uploadData.key) {\n                        data.key = uploadData.key;\n                    }\n                    resumableFilesData.push(data);\n                });\n                return resumableFilesData;\n            },\n            isResumable: function(id) {\n                return !!chunking && handler.isValid(id) && !handler._getFileState(id).notResumable;\n            },\n            moveInProgressToRemaining: function(id, optInProgress, optRemaining) {\n                var inProgress = optInProgress || handler._getFileState(id).chunking.inProgress, remaining = optRemaining || handler._getFileState(id).chunking.remaining;\n                if (inProgress) {\n                    log(qq.format(\"Moving these chunks from in-progress {}, to remaining.\", JSON.stringify(inProgress)));\n                    inProgress.reverse();\n                    qq.each(inProgress, function(idx, chunkIdx) {\n                        remaining.unshift(chunkIdx);\n                    });\n                    inProgress.length = 0;\n                }\n            },\n            pause: function(id) {\n                if (handler.isValid(id)) {\n                    log(qq.format(\"Aborting XHR upload for {} '{}' due to pause instruction.\", id, getName(id)));\n                    handler._getFileState(id).paused = true;\n                    abort(id);\n                    return true;\n                }\n            },\n            reevaluateChunking: function(id) {\n                if (chunking && handler.isValid(id)) {\n                    var state = handler._getFileState(id), totalChunks, i;\n                    delete state.chunking;\n                    state.chunking = {};\n                    totalChunks = handler._getTotalChunks(id);\n                    if (totalChunks > 1 || chunking.mandatory) {\n                        state.chunking.enabled = true;\n                        state.chunking.parts = totalChunks;\n                        state.chunking.remaining = [];\n                        for (i = 0; i < totalChunks; i++) {\n                            state.chunking.remaining.push(i);\n                        }\n                        handler._initTempState(id);\n                    } else {\n                        state.chunking.enabled = false;\n                    }\n                }\n            },\n            updateBlob: function(id, newBlob) {\n                if (handler.isValid(id)) {\n                    handler._getFileState(id).file = newBlob;\n                }\n            },\n            _clearXhrs: function(id) {\n                var tempState = handler._getFileState(id).temp;\n                qq.each(tempState.ajaxRequesters, function(chunkId) {\n                    delete tempState.ajaxRequesters[chunkId];\n                });\n                qq.each(tempState.xhrs, function(chunkId) {\n                    delete tempState.xhrs[chunkId];\n                });\n            },\n            _createXhr: function(id, optChunkIdx) {\n                return handler._registerXhr(id, optChunkIdx, qq.createXhrInstance());\n            },\n            _getAjaxRequester: function(id, optChunkIdx) {\n                var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n                return handler._getFileState(id).temp.ajaxRequesters[chunkIdx];\n            },\n            _getChunkData: function(id, chunkIndex) {\n                var chunkSize = chunking.partSize, fileSize = getSize(id), fileOrBlob = handler.getFile(id), startBytes = chunkSize * chunkIndex, endBytes = startBytes + chunkSize >= fileSize ? fileSize : startBytes + chunkSize, totalChunks = handler._getTotalChunks(id), cachedChunks = this._getFileState(id).temp.cachedChunks, blob = cachedChunks[chunkIndex] || qq.sliceBlob(fileOrBlob, startBytes, endBytes);\n                cachedChunks[chunkIndex] = blob;\n                return {\n                    part: chunkIndex,\n                    start: startBytes,\n                    end: endBytes,\n                    count: totalChunks,\n                    blob: blob,\n                    size: endBytes - startBytes\n                };\n            },\n            _getChunkDataForCallback: function(chunkData) {\n                return {\n                    partIndex: chunkData.part,\n                    startByte: chunkData.start + 1,\n                    endByte: chunkData.end,\n                    totalParts: chunkData.count\n                };\n            },\n            _getLocalStorageId: function(id) {\n                var formatVersion = \"5.0\", name = getName(id), size = getSize(id), chunkSize = chunking.partSize, endpoint = getEndpoint(id);\n                return qq.format(\"qq{}resume{}-{}-{}-{}-{}\", namespace, formatVersion, name, size, chunkSize, endpoint);\n            },\n            _getMimeType: function(id) {\n                return handler.getFile(id).type;\n            },\n            _getPersistableData: function(id) {\n                return handler._getFileState(id).chunking;\n            },\n            _getTotalChunks: function(id) {\n                if (chunking) {\n                    var fileSize = getSize(id), chunkSize = chunking.partSize;\n                    return Math.ceil(fileSize / chunkSize);\n                }\n            },\n            _getXhr: function(id, optChunkIdx) {\n                var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n                return handler._getFileState(id).temp.xhrs[chunkIdx];\n            },\n            _getXhrs: function(id) {\n                return handler._getFileState(id).temp.xhrs;\n            },\n            _iterateResumeRecords: function(callback) {\n                if (resumeEnabled) {\n                    qq.each(localStorage, function(key, item) {\n                        if (key.indexOf(qq.format(\"qq{}resume\", namespace)) === 0) {\n                            var uploadData = JSON.parse(item);\n                            callback(key, uploadData);\n                        }\n                    });\n                }\n            },\n            _initTempState: function(id) {\n                handler._getFileState(id).temp = {\n                    ajaxRequesters: {},\n                    chunkProgress: {},\n                    xhrs: {},\n                    cachedChunks: {}\n                };\n            },\n            _markNotResumable: function(id) {\n                handler._getFileState(id).notResumable = true;\n            },\n            _maybeDeletePersistedChunkData: function(id) {\n                var localStorageId;\n                if (resumeEnabled && handler.isResumable(id)) {\n                    localStorageId = handler._getLocalStorageId(id);\n                    if (localStorageId && localStorage.getItem(localStorageId)) {\n                        localStorage.removeItem(localStorageId);\n                        return true;\n                    }\n                }\n                return false;\n            },\n            _maybePrepareForResume: function(id) {\n                var state = handler._getFileState(id), localStorageId, persistedData;\n                if (resumeEnabled && state.key === undefined) {\n                    localStorageId = handler._getLocalStorageId(id);\n                    persistedData = localStorage.getItem(localStorageId);\n                    if (persistedData) {\n                        persistedData = JSON.parse(persistedData);\n                        if (getDataByUuid(persistedData.uuid)) {\n                            handler._markNotResumable(id);\n                        } else {\n                            log(qq.format(\"Identified file with ID {} and name of {} as resumable.\", id, getName(id)));\n                            onUuidChanged(id, persistedData.uuid);\n                            state.key = persistedData.key;\n                            state.chunking = persistedData.chunking;\n                            state.loaded = persistedData.loaded;\n                            state.attemptingResume = true;\n                            handler.moveInProgressToRemaining(id);\n                        }\n                    }\n                }\n            },\n            _maybePersistChunkedState: function(id) {\n                var state = handler._getFileState(id), localStorageId, persistedData;\n                if (resumeEnabled && handler.isResumable(id)) {\n                    localStorageId = handler._getLocalStorageId(id);\n                    persistedData = {\n                        name: getName(id),\n                        size: getSize(id),\n                        uuid: getUuid(id),\n                        key: state.key,\n                        chunking: state.chunking,\n                        loaded: state.loaded,\n                        lastUpdated: Date.now()\n                    };\n                    try {\n                        localStorage.setItem(localStorageId, JSON.stringify(persistedData));\n                    } catch (error) {\n                        log(qq.format(\"Unable to save resume data for '{}' due to error: '{}'.\", id, error.toString()), \"warn\");\n                    }\n                }\n            },\n            _registerProgressHandler: function(id, chunkIdx, chunkSize) {\n                var xhr = handler._getXhr(id, chunkIdx), name = getName(id), progressCalculator = {\n                    simple: function(loaded, total) {\n                        var fileSize = getSize(id);\n                        if (loaded === total) {\n                            onProgress(id, name, fileSize, fileSize);\n                        } else {\n                            onProgress(id, name, loaded >= fileSize ? fileSize - 1 : loaded, fileSize);\n                        }\n                    },\n                    chunked: function(loaded, total) {\n                        var chunkProgress = handler._getFileState(id).temp.chunkProgress, totalSuccessfullyLoadedForFile = handler._getFileState(id).loaded, loadedForRequest = loaded, totalForRequest = total, totalFileSize = getSize(id), estActualChunkLoaded = loadedForRequest - (totalForRequest - chunkSize), totalLoadedForFile = totalSuccessfullyLoadedForFile;\n                        chunkProgress[chunkIdx] = estActualChunkLoaded;\n                        qq.each(chunkProgress, function(chunkIdx, chunkLoaded) {\n                            totalLoadedForFile += chunkLoaded;\n                        });\n                        onProgress(id, name, totalLoadedForFile, totalFileSize);\n                    }\n                };\n                xhr.upload.onprogress = function(e) {\n                    if (e.lengthComputable) {\n                        var type = chunkSize == null ? \"simple\" : \"chunked\";\n                        progressCalculator[type](e.loaded, e.total);\n                    }\n                };\n            },\n            _registerXhr: function(id, optChunkIdx, xhr, optAjaxRequester) {\n                var xhrsId = optChunkIdx == null ? -1 : optChunkIdx, tempState = handler._getFileState(id).temp;\n                tempState.xhrs = tempState.xhrs || {};\n                tempState.ajaxRequesters = tempState.ajaxRequesters || {};\n                tempState.xhrs[xhrsId] = xhr;\n                if (optAjaxRequester) {\n                    tempState.ajaxRequesters[xhrsId] = optAjaxRequester;\n                }\n                return xhr;\n            },\n            _removeExpiredChunkingRecords: function() {\n                var expirationDays = resume.recordsExpireIn;\n                handler._iterateResumeRecords(function(key, uploadData) {\n                    var expirationDate = new Date(uploadData.lastUpdated);\n                    expirationDate.setDate(expirationDate.getDate() + expirationDays);\n                    if (expirationDate.getTime() <= Date.now()) {\n                        log(\"Removing expired resume record with key \" + key);\n                        localStorage.removeItem(key);\n                    }\n                });\n            },\n            _shouldChunkThisFile: function(id) {\n                var state = handler._getFileState(id);\n                if (!state.chunking) {\n                    handler.reevaluateChunking(id);\n                }\n                return state.chunking.enabled;\n            }\n        });\n    };\n    qq.DeleteFileAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, options = {\n            method: \"DELETE\",\n            uuidParamName: \"qquuid\",\n            endpointStore: {},\n            maxConnections: 3,\n            customHeaders: function(id) {\n                return {};\n            },\n            paramsStore: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {},\n            onDelete: function(id) {},\n            onDeleteComplete: function(id, xhrOrXdr, isError) {}\n        };\n        qq.extend(options, o);\n        function getMandatedParams() {\n            if (options.method.toUpperCase() === \"POST\") {\n                return {\n                    _method: \"DELETE\"\n                };\n            }\n            return {};\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            validMethods: [ \"POST\", \"DELETE\" ],\n            method: options.method,\n            endpointStore: options.endpointStore,\n            paramsStore: options.paramsStore,\n            mandatedParams: getMandatedParams(),\n            maxConnections: options.maxConnections,\n            customHeaders: function(id) {\n                return options.customHeaders.get(id);\n            },\n            log: options.log,\n            onSend: options.onDelete,\n            onComplete: options.onDeleteComplete,\n            cors: options.cors\n        }));\n        qq.extend(this, {\n            sendDelete: function(id, uuid, additionalMandatedParams) {\n                var additionalOptions = additionalMandatedParams || {};\n                options.log(\"Submitting delete file request for \" + id);\n                if (options.method === \"DELETE\") {\n                    requester.initTransport(id).withPath(uuid).withParams(additionalOptions).send();\n                } else {\n                    additionalOptions[options.uuidParamName] = uuid;\n                    requester.initTransport(id).withParams(additionalOptions).send();\n                }\n            }\n        });\n    };\n    (function() {\n        function detectSubsampling(img) {\n            var iw = img.naturalWidth, ih = img.naturalHeight, canvas = document.createElement(\"canvas\"), ctx;\n            if (iw * ih > 1024 * 1024) {\n                canvas.width = canvas.height = 1;\n                ctx = canvas.getContext(\"2d\");\n                ctx.drawImage(img, -iw + 1, 0);\n                return ctx.getImageData(0, 0, 1, 1).data[3] === 0;\n            } else {\n                return false;\n            }\n        }\n        function detectVerticalSquash(img, iw, ih) {\n            var canvas = document.createElement(\"canvas\"), sy = 0, ey = ih, py = ih, ctx, data, alpha, ratio;\n            canvas.width = 1;\n            canvas.height = ih;\n            ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(img, 0, 0);\n            data = ctx.getImageData(0, 0, 1, ih).data;\n            while (py > sy) {\n                alpha = data[(py - 1) * 4 + 3];\n                if (alpha === 0) {\n                    ey = py;\n                } else {\n                    sy = py;\n                }\n                py = ey + sy >> 1;\n            }\n            ratio = py / ih;\n            return ratio === 0 ? 1 : ratio;\n        }\n        function renderImageToDataURL(img, blob, options, doSquash) {\n            var canvas = document.createElement(\"canvas\"), mime = options.mime || \"image/jpeg\", promise = new qq.Promise();\n            renderImageToCanvas(img, blob, canvas, options, doSquash).then(function() {\n                promise.success(canvas.toDataURL(mime, options.quality || .8));\n            });\n            return promise;\n        }\n        function maybeCalculateDownsampledDimensions(spec) {\n            var maxPixels = 5241e3;\n            if (!qq.ios()) {\n                throw new qq.Error(\"Downsampled dimensions can only be reliably calculated for iOS!\");\n            }\n            if (spec.origHeight * spec.origWidth > maxPixels) {\n                return {\n                    newHeight: Math.round(Math.sqrt(maxPixels * (spec.origHeight / spec.origWidth))),\n                    newWidth: Math.round(Math.sqrt(maxPixels * (spec.origWidth / spec.origHeight)))\n                };\n            }\n        }\n        function renderImageToCanvas(img, blob, canvas, options, doSquash) {\n            var iw = img.naturalWidth, ih = img.naturalHeight, width = options.width, height = options.height, ctx = canvas.getContext(\"2d\"), promise = new qq.Promise(), modifiedDimensions;\n            ctx.save();\n            if (options.resize) {\n                return renderImageToCanvasWithCustomResizer({\n                    blob: blob,\n                    canvas: canvas,\n                    image: img,\n                    imageHeight: ih,\n                    imageWidth: iw,\n                    orientation: options.orientation,\n                    resize: options.resize,\n                    targetHeight: height,\n                    targetWidth: width\n                });\n            }\n            if (!qq.supportedFeatures.unlimitedScaledImageSize) {\n                modifiedDimensions = maybeCalculateDownsampledDimensions({\n                    origWidth: width,\n                    origHeight: height\n                });\n                if (modifiedDimensions) {\n                    qq.log(qq.format(\"Had to reduce dimensions due to device limitations from {}w / {}h to {}w / {}h\", width, height, modifiedDimensions.newWidth, modifiedDimensions.newHeight), \"warn\");\n                    width = modifiedDimensions.newWidth;\n                    height = modifiedDimensions.newHeight;\n                }\n            }\n            transformCoordinate(canvas, width, height, options.orientation);\n            if (qq.ios()) {\n                (function() {\n                    if (detectSubsampling(img)) {\n                        iw /= 2;\n                        ih /= 2;\n                    }\n                    var d = 1024, tmpCanvas = document.createElement(\"canvas\"), vertSquashRatio = doSquash ? detectVerticalSquash(img, iw, ih) : 1, dw = Math.ceil(d * width / iw), dh = Math.ceil(d * height / ih / vertSquashRatio), sy = 0, dy = 0, tmpCtx, sx, dx;\n                    tmpCanvas.width = tmpCanvas.height = d;\n                    tmpCtx = tmpCanvas.getContext(\"2d\");\n                    while (sy < ih) {\n                        sx = 0;\n                        dx = 0;\n                        while (sx < iw) {\n                            tmpCtx.clearRect(0, 0, d, d);\n                            tmpCtx.drawImage(img, -sx, -sy);\n                            ctx.drawImage(tmpCanvas, 0, 0, d, d, dx, dy, dw, dh);\n                            sx += d;\n                            dx += dw;\n                        }\n                        sy += d;\n                        dy += dh;\n                    }\n                    ctx.restore();\n                    tmpCanvas = tmpCtx = null;\n                })();\n            } else {\n                ctx.drawImage(img, 0, 0, width, height);\n            }\n            canvas.qqImageRendered && canvas.qqImageRendered();\n            promise.success();\n            return promise;\n        }\n        function renderImageToCanvasWithCustomResizer(resizeInfo) {\n            var blob = resizeInfo.blob, image = resizeInfo.image, imageHeight = resizeInfo.imageHeight, imageWidth = resizeInfo.imageWidth, orientation = resizeInfo.orientation, promise = new qq.Promise(), resize = resizeInfo.resize, sourceCanvas = document.createElement(\"canvas\"), sourceCanvasContext = sourceCanvas.getContext(\"2d\"), targetCanvas = resizeInfo.canvas, targetHeight = resizeInfo.targetHeight, targetWidth = resizeInfo.targetWidth;\n            transformCoordinate(sourceCanvas, imageWidth, imageHeight, orientation);\n            targetCanvas.height = targetHeight;\n            targetCanvas.width = targetWidth;\n            sourceCanvasContext.drawImage(image, 0, 0);\n            resize({\n                blob: blob,\n                height: targetHeight,\n                image: image,\n                sourceCanvas: sourceCanvas,\n                targetCanvas: targetCanvas,\n                width: targetWidth\n            }).then(function success() {\n                targetCanvas.qqImageRendered && targetCanvas.qqImageRendered();\n                promise.success();\n            }, promise.failure);\n            return promise;\n        }\n        function transformCoordinate(canvas, width, height, orientation) {\n            switch (orientation) {\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n                canvas.width = height;\n                canvas.height = width;\n                break;\n\n              default:\n                canvas.width = width;\n                canvas.height = height;\n            }\n            var ctx = canvas.getContext(\"2d\");\n            switch (orientation) {\n              case 2:\n                ctx.translate(width, 0);\n                ctx.scale(-1, 1);\n                break;\n\n              case 3:\n                ctx.translate(width, height);\n                ctx.rotate(Math.PI);\n                break;\n\n              case 4:\n                ctx.translate(0, height);\n                ctx.scale(1, -1);\n                break;\n\n              case 5:\n                ctx.rotate(.5 * Math.PI);\n                ctx.scale(1, -1);\n                break;\n\n              case 6:\n                ctx.rotate(.5 * Math.PI);\n                ctx.translate(0, -height);\n                break;\n\n              case 7:\n                ctx.rotate(.5 * Math.PI);\n                ctx.translate(width, -height);\n                ctx.scale(-1, 1);\n                break;\n\n              case 8:\n                ctx.rotate(-.5 * Math.PI);\n                ctx.translate(-width, 0);\n                break;\n\n              default:\n                break;\n            }\n        }\n        function MegaPixImage(srcImage, errorCallback) {\n            var self = this;\n            if (window.Blob && srcImage instanceof Blob) {\n                (function() {\n                    var img = new Image(), URL = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n                    if (!URL) {\n                        throw Error(\"No createObjectURL function found to create blob url\");\n                    }\n                    img.src = URL.createObjectURL(srcImage);\n                    self.blob = srcImage;\n                    srcImage = img;\n                })();\n            }\n            if (!srcImage.naturalWidth && !srcImage.naturalHeight) {\n                srcImage.onload = function() {\n                    var listeners = self.imageLoadListeners;\n                    if (listeners) {\n                        self.imageLoadListeners = null;\n                        setTimeout(function() {\n                            for (var i = 0, len = listeners.length; i < len; i++) {\n                                listeners[i]();\n                            }\n                        }, 0);\n                    }\n                };\n                srcImage.onerror = errorCallback;\n                this.imageLoadListeners = [];\n            }\n            this.srcImage = srcImage;\n        }\n        MegaPixImage.prototype.render = function(target, options) {\n            options = options || {};\n            var self = this, imgWidth = this.srcImage.naturalWidth, imgHeight = this.srcImage.naturalHeight, width = options.width, height = options.height, maxWidth = options.maxWidth, maxHeight = options.maxHeight, doSquash = !this.blob || this.blob.type === \"image/jpeg\", tagName = target.tagName.toLowerCase(), opt;\n            if (this.imageLoadListeners) {\n                this.imageLoadListeners.push(function() {\n                    self.render(target, options);\n                });\n                return;\n            }\n            if (width && !height) {\n                height = imgHeight * width / imgWidth << 0;\n            } else if (height && !width) {\n                width = imgWidth * height / imgHeight << 0;\n            } else {\n                width = imgWidth;\n                height = imgHeight;\n            }\n            if (maxWidth && width > maxWidth) {\n                width = maxWidth;\n                height = imgHeight * width / imgWidth << 0;\n            }\n            if (maxHeight && height > maxHeight) {\n                height = maxHeight;\n                width = imgWidth * height / imgHeight << 0;\n            }\n            opt = {\n                width: width,\n                height: height\n            }, qq.each(options, function(optionsKey, optionsValue) {\n                opt[optionsKey] = optionsValue;\n            });\n            if (tagName === \"img\") {\n                (function() {\n                    var oldTargetSrc = target.src;\n                    renderImageToDataURL(self.srcImage, self.blob, opt, doSquash).then(function(dataUri) {\n                        target.src = dataUri;\n                        oldTargetSrc === target.src && target.onload();\n                    });\n                })();\n            } else if (tagName === \"canvas\") {\n                renderImageToCanvas(this.srcImage, this.blob, target, opt, doSquash);\n            }\n            if (typeof this.onrender === \"function\") {\n                this.onrender(target);\n            }\n        };\n        qq.MegaPixImage = MegaPixImage;\n    })();\n    qq.ImageGenerator = function(log) {\n        \"use strict\";\n        function isImg(el) {\n            return el.tagName.toLowerCase() === \"img\";\n        }\n        function isCanvas(el) {\n            return el.tagName.toLowerCase() === \"canvas\";\n        }\n        function isImgCorsSupported() {\n            return new Image().crossOrigin !== undefined;\n        }\n        function isCanvasSupported() {\n            var canvas = document.createElement(\"canvas\");\n            return canvas.getContext && canvas.getContext(\"2d\");\n        }\n        function determineMimeOfFileName(nameWithPath) {\n            var pathSegments = nameWithPath.split(\"/\"), name = pathSegments[pathSegments.length - 1].split(\"?\")[0], extension = qq.getExtension(name);\n            extension = extension && extension.toLowerCase();\n            switch (extension) {\n              case \"jpeg\":\n              case \"jpg\":\n                return \"image/jpeg\";\n\n              case \"png\":\n                return \"image/png\";\n\n              case \"bmp\":\n                return \"image/bmp\";\n\n              case \"gif\":\n                return \"image/gif\";\n\n              case \"tiff\":\n              case \"tif\":\n                return \"image/tiff\";\n            }\n        }\n        function isCrossOrigin(url) {\n            var targetAnchor = document.createElement(\"a\"), targetProtocol, targetHostname, targetPort;\n            targetAnchor.href = url;\n            targetProtocol = targetAnchor.protocol;\n            targetPort = targetAnchor.port;\n            targetHostname = targetAnchor.hostname;\n            if (targetProtocol.toLowerCase() !== window.location.protocol.toLowerCase()) {\n                return true;\n            }\n            if (targetHostname.toLowerCase() !== window.location.hostname.toLowerCase()) {\n                return true;\n            }\n            if (targetPort !== window.location.port && !qq.ie()) {\n                return true;\n            }\n            return false;\n        }\n        function registerImgLoadListeners(img, promise) {\n            img.onload = function() {\n                img.onload = null;\n                img.onerror = null;\n                promise.success(img);\n            };\n            img.onerror = function() {\n                img.onload = null;\n                img.onerror = null;\n                log(\"Problem drawing thumbnail!\", \"error\");\n                promise.failure(img, \"Problem drawing thumbnail!\");\n            };\n        }\n        function registerCanvasDrawImageListener(canvas, promise) {\n            canvas.qqImageRendered = function() {\n                promise.success(canvas);\n            };\n        }\n        function registerThumbnailRenderedListener(imgOrCanvas, promise) {\n            var registered = isImg(imgOrCanvas) || isCanvas(imgOrCanvas);\n            if (isImg(imgOrCanvas)) {\n                registerImgLoadListeners(imgOrCanvas, promise);\n            } else if (isCanvas(imgOrCanvas)) {\n                registerCanvasDrawImageListener(imgOrCanvas, promise);\n            } else {\n                promise.failure(imgOrCanvas);\n                log(qq.format(\"Element container of type {} is not supported!\", imgOrCanvas.tagName), \"error\");\n            }\n            return registered;\n        }\n        function draw(fileOrBlob, container, options) {\n            var drawPreview = new qq.Promise(), identifier = new qq.Identify(fileOrBlob, log), maxSize = options.maxSize, orient = options.orient == null ? true : options.orient, megapixErrorHandler = function() {\n                container.onerror = null;\n                container.onload = null;\n                log(\"Could not render preview, file may be too large!\", \"error\");\n                drawPreview.failure(container, \"Browser cannot render image!\");\n            };\n            identifier.isPreviewable().then(function(mime) {\n                var dummyExif = {\n                    parse: function() {\n                        return new qq.Promise().success();\n                    }\n                }, exif = orient ? new qq.Exif(fileOrBlob, log) : dummyExif, mpImg = new qq.MegaPixImage(fileOrBlob, megapixErrorHandler);\n                if (registerThumbnailRenderedListener(container, drawPreview)) {\n                    exif.parse().then(function(exif) {\n                        var orientation = exif && exif.Orientation;\n                        mpImg.render(container, {\n                            maxWidth: maxSize,\n                            maxHeight: maxSize,\n                            orientation: orientation,\n                            mime: mime,\n                            resize: options.customResizeFunction\n                        });\n                    }, function(failureMsg) {\n                        log(qq.format(\"EXIF data could not be parsed ({}).  Assuming orientation = 1.\", failureMsg));\n                        mpImg.render(container, {\n                            maxWidth: maxSize,\n                            maxHeight: maxSize,\n                            mime: mime,\n                            resize: options.customResizeFunction\n                        });\n                    });\n                }\n            }, function() {\n                log(\"Not previewable\");\n                drawPreview.failure(container, \"Not previewable\");\n            });\n            return drawPreview;\n        }\n        function drawOnCanvasOrImgFromUrl(url, canvasOrImg, draw, maxSize, customResizeFunction) {\n            var tempImg = new Image(), tempImgRender = new qq.Promise();\n            registerThumbnailRenderedListener(tempImg, tempImgRender);\n            if (isCrossOrigin(url)) {\n                tempImg.crossOrigin = \"anonymous\";\n            }\n            tempImg.src = url;\n            tempImgRender.then(function rendered() {\n                registerThumbnailRenderedListener(canvasOrImg, draw);\n                var mpImg = new qq.MegaPixImage(tempImg);\n                mpImg.render(canvasOrImg, {\n                    maxWidth: maxSize,\n                    maxHeight: maxSize,\n                    mime: determineMimeOfFileName(url),\n                    resize: customResizeFunction\n                });\n            }, draw.failure);\n        }\n        function drawOnImgFromUrlWithCssScaling(url, img, draw, maxSize) {\n            registerThumbnailRenderedListener(img, draw);\n            qq(img).css({\n                maxWidth: maxSize + \"px\",\n                maxHeight: maxSize + \"px\"\n            });\n            img.src = url;\n        }\n        function drawFromUrl(url, container, options) {\n            var draw = new qq.Promise(), scale = options.scale, maxSize = scale ? options.maxSize : null;\n            if (scale && isImg(container)) {\n                if (isCanvasSupported()) {\n                    if (isCrossOrigin(url) && !isImgCorsSupported()) {\n                        drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n                    } else {\n                        drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n                    }\n                } else {\n                    drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n                }\n            } else if (isCanvas(container)) {\n                drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n            } else if (registerThumbnailRenderedListener(container, draw)) {\n                container.src = url;\n            }\n            return draw;\n        }\n        qq.extend(this, {\n            generate: function(fileBlobOrUrl, container, options) {\n                if (qq.isString(fileBlobOrUrl)) {\n                    log(\"Attempting to update thumbnail based on server response.\");\n                    return drawFromUrl(fileBlobOrUrl, container, options || {});\n                } else {\n                    log(\"Attempting to draw client-side image preview.\");\n                    return draw(fileBlobOrUrl, container, options || {});\n                }\n            }\n        });\n        this._testing = {};\n        this._testing.isImg = isImg;\n        this._testing.isCanvas = isCanvas;\n        this._testing.isCrossOrigin = isCrossOrigin;\n        this._testing.determineMimeOfFileName = determineMimeOfFileName;\n    };\n    qq.Exif = function(fileOrBlob, log) {\n        \"use strict\";\n        var TAG_IDS = [ 274 ], TAG_INFO = {\n            274: {\n                name: \"Orientation\",\n                bytes: 2\n            }\n        };\n        function parseLittleEndian(hex) {\n            var result = 0, pow = 0;\n            while (hex.length > 0) {\n                result += parseInt(hex.substring(0, 2), 16) * Math.pow(2, pow);\n                hex = hex.substring(2, hex.length);\n                pow += 8;\n            }\n            return result;\n        }\n        function seekToApp1(offset, promise) {\n            var theOffset = offset, thePromise = promise;\n            if (theOffset === undefined) {\n                theOffset = 2;\n                thePromise = new qq.Promise();\n            }\n            qq.readBlobToHex(fileOrBlob, theOffset, 4).then(function(hex) {\n                var match = /^ffe([0-9])/.exec(hex), segmentLength;\n                if (match) {\n                    if (match[1] !== \"1\") {\n                        segmentLength = parseInt(hex.slice(4, 8), 16);\n                        seekToApp1(theOffset + segmentLength + 2, thePromise);\n                    } else {\n                        thePromise.success(theOffset);\n                    }\n                } else {\n                    thePromise.failure(\"No EXIF header to be found!\");\n                }\n            });\n            return thePromise;\n        }\n        function getApp1Offset() {\n            var promise = new qq.Promise();\n            qq.readBlobToHex(fileOrBlob, 0, 6).then(function(hex) {\n                if (hex.indexOf(\"ffd8\") !== 0) {\n                    promise.failure(\"Not a valid JPEG!\");\n                } else {\n                    seekToApp1().then(function(offset) {\n                        promise.success(offset);\n                    }, function(error) {\n                        promise.failure(error);\n                    });\n                }\n            });\n            return promise;\n        }\n        function isLittleEndian(app1Start) {\n            var promise = new qq.Promise();\n            qq.readBlobToHex(fileOrBlob, app1Start + 10, 2).then(function(hex) {\n                promise.success(hex === \"4949\");\n            });\n            return promise;\n        }\n        function getDirEntryCount(app1Start, littleEndian) {\n            var promise = new qq.Promise();\n            qq.readBlobToHex(fileOrBlob, app1Start + 18, 2).then(function(hex) {\n                if (littleEndian) {\n                    return promise.success(parseLittleEndian(hex));\n                } else {\n                    promise.success(parseInt(hex, 16));\n                }\n            });\n            return promise;\n        }\n        function getIfd(app1Start, dirEntries) {\n            var offset = app1Start + 20, bytes = dirEntries * 12;\n            return qq.readBlobToHex(fileOrBlob, offset, bytes);\n        }\n        function getDirEntries(ifdHex) {\n            var entries = [], offset = 0;\n            while (offset + 24 <= ifdHex.length) {\n                entries.push(ifdHex.slice(offset, offset + 24));\n                offset += 24;\n            }\n            return entries;\n        }\n        function getTagValues(littleEndian, dirEntries) {\n            var TAG_VAL_OFFSET = 16, tagsToFind = qq.extend([], TAG_IDS), vals = {};\n            qq.each(dirEntries, function(idx, entry) {\n                var idHex = entry.slice(0, 4), id = littleEndian ? parseLittleEndian(idHex) : parseInt(idHex, 16), tagsToFindIdx = tagsToFind.indexOf(id), tagValHex, tagName, tagValLength;\n                if (tagsToFindIdx >= 0) {\n                    tagName = TAG_INFO[id].name;\n                    tagValLength = TAG_INFO[id].bytes;\n                    tagValHex = entry.slice(TAG_VAL_OFFSET, TAG_VAL_OFFSET + tagValLength * 2);\n                    vals[tagName] = littleEndian ? parseLittleEndian(tagValHex) : parseInt(tagValHex, 16);\n                    tagsToFind.splice(tagsToFindIdx, 1);\n                }\n                if (tagsToFind.length === 0) {\n                    return false;\n                }\n            });\n            return vals;\n        }\n        qq.extend(this, {\n            parse: function() {\n                var parser = new qq.Promise(), onParseFailure = function(message) {\n                    log(qq.format(\"EXIF header parse failed: '{}' \", message));\n                    parser.failure(message);\n                };\n                getApp1Offset().then(function(app1Offset) {\n                    log(qq.format(\"Moving forward with EXIF header parsing for '{}'\", fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name));\n                    isLittleEndian(app1Offset).then(function(littleEndian) {\n                        log(qq.format(\"EXIF Byte order is {} endian\", littleEndian ? \"little\" : \"big\"));\n                        getDirEntryCount(app1Offset, littleEndian).then(function(dirEntryCount) {\n                            log(qq.format(\"Found {} APP1 directory entries\", dirEntryCount));\n                            getIfd(app1Offset, dirEntryCount).then(function(ifdHex) {\n                                var dirEntries = getDirEntries(ifdHex), tagValues = getTagValues(littleEndian, dirEntries);\n                                log(\"Successfully parsed some EXIF tags\");\n                                parser.success(tagValues);\n                            }, onParseFailure);\n                        }, onParseFailure);\n                    }, onParseFailure);\n                }, onParseFailure);\n                return parser;\n            }\n        });\n        this._testing = {};\n        this._testing.parseLittleEndian = parseLittleEndian;\n    };\n    qq.Identify = function(fileOrBlob, log) {\n        \"use strict\";\n        function isIdentifiable(magicBytes, questionableBytes) {\n            var identifiable = false, magicBytesEntries = [].concat(magicBytes);\n            qq.each(magicBytesEntries, function(idx, magicBytesArrayEntry) {\n                if (questionableBytes.indexOf(magicBytesArrayEntry) === 0) {\n                    identifiable = true;\n                    return false;\n                }\n            });\n            return identifiable;\n        }\n        qq.extend(this, {\n            isPreviewable: function() {\n                var self = this, identifier = new qq.Promise(), previewable = false, name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n                log(qq.format(\"Attempting to determine if {} can be rendered in this browser\", name));\n                log(\"First pass: check type attribute of blob object.\");\n                if (this.isPreviewableSync()) {\n                    log(\"Second pass: check for magic bytes in file header.\");\n                    qq.readBlobToHex(fileOrBlob, 0, 4).then(function(hex) {\n                        qq.each(self.PREVIEWABLE_MIME_TYPES, function(mime, bytes) {\n                            if (isIdentifiable(bytes, hex)) {\n                                if (mime !== \"image/tiff\" || qq.supportedFeatures.tiffPreviews) {\n                                    previewable = true;\n                                    identifier.success(mime);\n                                }\n                                return false;\n                            }\n                        });\n                        log(qq.format(\"'{}' is {} able to be rendered in this browser\", name, previewable ? \"\" : \"NOT\"));\n                        if (!previewable) {\n                            identifier.failure();\n                        }\n                    }, function() {\n                        log(\"Error reading file w/ name '\" + name + \"'.  Not able to be rendered in this browser.\");\n                        identifier.failure();\n                    });\n                } else {\n                    identifier.failure();\n                }\n                return identifier;\n            },\n            isPreviewableSync: function() {\n                var fileMime = fileOrBlob.type, isRecognizedImage = qq.indexOf(Object.keys(this.PREVIEWABLE_MIME_TYPES), fileMime) >= 0, previewable = false, name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n                if (isRecognizedImage) {\n                    if (fileMime === \"image/tiff\") {\n                        previewable = qq.supportedFeatures.tiffPreviews;\n                    } else {\n                        previewable = true;\n                    }\n                }\n                !previewable && log(name + \" is not previewable in this browser per the blob's type attr\");\n                return previewable;\n            }\n        });\n    };\n    qq.Identify.prototype.PREVIEWABLE_MIME_TYPES = {\n        \"image/jpeg\": \"ffd8ff\",\n        \"image/gif\": \"474946\",\n        \"image/png\": \"89504e\",\n        \"image/bmp\": \"424d\",\n        \"image/tiff\": [ \"49492a00\", \"4d4d002a\" ]\n    };\n    qq.ImageValidation = function(blob, log) {\n        \"use strict\";\n        function hasNonZeroLimits(limits) {\n            var atLeastOne = false;\n            qq.each(limits, function(limit, value) {\n                if (value > 0) {\n                    atLeastOne = true;\n                    return false;\n                }\n            });\n            return atLeastOne;\n        }\n        function getWidthHeight() {\n            var sizeDetermination = new qq.Promise();\n            new qq.Identify(blob, log).isPreviewable().then(function() {\n                var image = new Image(), url = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n                if (url) {\n                    image.onerror = function() {\n                        log(\"Cannot determine dimensions for image.  May be too large.\", \"error\");\n                        sizeDetermination.failure();\n                    };\n                    image.onload = function() {\n                        sizeDetermination.success({\n                            width: this.width,\n                            height: this.height\n                        });\n                    };\n                    image.src = url.createObjectURL(blob);\n                } else {\n                    log(\"No createObjectURL function available to generate image URL!\", \"error\");\n                    sizeDetermination.failure();\n                }\n            }, sizeDetermination.failure);\n            return sizeDetermination;\n        }\n        function getFailingLimit(limits, dimensions) {\n            var failingLimit;\n            qq.each(limits, function(limitName, limitValue) {\n                if (limitValue > 0) {\n                    var limitMatcher = /(max|min)(Width|Height)/.exec(limitName), dimensionPropName = limitMatcher[2].charAt(0).toLowerCase() + limitMatcher[2].slice(1), actualValue = dimensions[dimensionPropName];\n                    switch (limitMatcher[1]) {\n                      case \"min\":\n                        if (actualValue < limitValue) {\n                            failingLimit = limitName;\n                            return false;\n                        }\n                        break;\n\n                      case \"max\":\n                        if (actualValue > limitValue) {\n                            failingLimit = limitName;\n                            return false;\n                        }\n                        break;\n                    }\n                }\n            });\n            return failingLimit;\n        }\n        this.validate = function(limits) {\n            var validationEffort = new qq.Promise();\n            log(\"Attempting to validate image.\");\n            if (hasNonZeroLimits(limits)) {\n                getWidthHeight().then(function(dimensions) {\n                    var failingLimit = getFailingLimit(limits, dimensions);\n                    if (failingLimit) {\n                        validationEffort.failure(failingLimit);\n                    } else {\n                        validationEffort.success();\n                    }\n                }, validationEffort.success);\n            } else {\n                validationEffort.success();\n            }\n            return validationEffort;\n        };\n    };\n    qq.Session = function(spec) {\n        \"use strict\";\n        var options = {\n            endpoint: null,\n            params: {},\n            customHeaders: {},\n            cors: {},\n            addFileRecord: function(sessionData) {},\n            log: function(message, level) {}\n        };\n        qq.extend(options, spec, true);\n        function isJsonResponseValid(response) {\n            if (qq.isArray(response)) {\n                return true;\n            }\n            options.log(\"Session response is not an array.\", \"error\");\n        }\n        function handleFileItems(fileItems, success, xhrOrXdr, promise) {\n            var someItemsIgnored = false;\n            success = success && isJsonResponseValid(fileItems);\n            if (success) {\n                qq.each(fileItems, function(idx, fileItem) {\n                    if (fileItem.uuid == null) {\n                        someItemsIgnored = true;\n                        options.log(qq.format(\"Session response item {} did not include a valid UUID - ignoring.\", idx), \"error\");\n                    } else if (fileItem.name == null) {\n                        someItemsIgnored = true;\n                        options.log(qq.format(\"Session response item {} did not include a valid name - ignoring.\", idx), \"error\");\n                    } else {\n                        try {\n                            options.addFileRecord(fileItem);\n                            return true;\n                        } catch (err) {\n                            someItemsIgnored = true;\n                            options.log(err.message, \"error\");\n                        }\n                    }\n                    return false;\n                });\n            }\n            promise[success && !someItemsIgnored ? \"success\" : \"failure\"](fileItems, xhrOrXdr);\n        }\n        this.refresh = function() {\n            var refreshEffort = new qq.Promise(), refreshCompleteCallback = function(response, success, xhrOrXdr) {\n                handleFileItems(response, success, xhrOrXdr, refreshEffort);\n            }, requesterOptions = qq.extend({}, options), requester = new qq.SessionAjaxRequester(qq.extend(requesterOptions, {\n                onComplete: refreshCompleteCallback\n            }));\n            requester.queryServer();\n            return refreshEffort;\n        };\n    };\n    qq.SessionAjaxRequester = function(spec) {\n        \"use strict\";\n        var requester, options = {\n            endpoint: null,\n            customHeaders: {},\n            params: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            onComplete: function(response, success, xhrOrXdr) {},\n            log: function(str, level) {}\n        };\n        qq.extend(options, spec);\n        function onComplete(id, xhrOrXdr, isError) {\n            var response = null;\n            if (xhrOrXdr.responseText != null) {\n                try {\n                    response = qq.parseJson(xhrOrXdr.responseText);\n                } catch (err) {\n                    options.log(\"Problem parsing session response: \" + err.message, \"error\");\n                    isError = true;\n                }\n            }\n            options.onComplete(response, !isError, xhrOrXdr);\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            validMethods: [ \"GET\" ],\n            method: \"GET\",\n            endpointStore: {\n                get: function() {\n                    return options.endpoint;\n                }\n            },\n            customHeaders: options.customHeaders,\n            log: options.log,\n            onComplete: onComplete,\n            cors: options.cors\n        }));\n        qq.extend(this, {\n            queryServer: function() {\n                var params = qq.extend({}, options.params);\n                options.log(\"Session query request.\");\n                requester.initTransport(\"sessionRefresh\").withParams(params).withCacheBuster().send();\n            }\n        });\n    };\n    qq.Scaler = function(spec, log) {\n        \"use strict\";\n        var self = this, customResizeFunction = spec.customResizer, includeOriginal = spec.sendOriginal, orient = spec.orient, defaultType = spec.defaultType, defaultQuality = spec.defaultQuality / 100, failedToScaleText = spec.failureText, includeExif = spec.includeExif, sizes = this._getSortedSizes(spec.sizes);\n        qq.extend(this, {\n            enabled: qq.supportedFeatures.scaling && sizes.length > 0,\n            getFileRecords: function(originalFileUuid, originalFileName, originalBlobOrBlobData) {\n                var self = this, records = [], originalBlob = originalBlobOrBlobData.blob ? originalBlobOrBlobData.blob : originalBlobOrBlobData, identifier = new qq.Identify(originalBlob, log);\n                if (identifier.isPreviewableSync()) {\n                    qq.each(sizes, function(idx, sizeRecord) {\n                        var outputType = self._determineOutputType({\n                            defaultType: defaultType,\n                            requestedType: sizeRecord.type,\n                            refType: originalBlob.type\n                        });\n                        records.push({\n                            uuid: qq.getUniqueId(),\n                            name: self._getName(originalFileName, {\n                                name: sizeRecord.name,\n                                type: outputType,\n                                refType: originalBlob.type\n                            }),\n                            blob: new qq.BlobProxy(originalBlob, qq.bind(self._generateScaledImage, self, {\n                                customResizeFunction: customResizeFunction,\n                                maxSize: sizeRecord.maxSize,\n                                orient: orient,\n                                type: outputType,\n                                quality: defaultQuality,\n                                failedText: failedToScaleText,\n                                includeExif: includeExif,\n                                log: log\n                            }))\n                        });\n                    });\n                    records.push({\n                        uuid: originalFileUuid,\n                        name: originalFileName,\n                        size: originalBlob.size,\n                        blob: includeOriginal ? originalBlob : null\n                    });\n                } else {\n                    records.push({\n                        uuid: originalFileUuid,\n                        name: originalFileName,\n                        size: originalBlob.size,\n                        blob: originalBlob\n                    });\n                }\n                return records;\n            },\n            handleNewFile: function(file, name, uuid, size, fileList, batchId, uuidParamName, api) {\n                var self = this, buttonId = file.qqButtonId || file.blob && file.blob.qqButtonId, scaledIds = [], originalId = null, addFileToHandler = api.addFileToHandler, uploadData = api.uploadData, paramsStore = api.paramsStore, proxyGroupId = qq.getUniqueId();\n                qq.each(self.getFileRecords(uuid, name, file), function(idx, record) {\n                    var blobSize = record.size, id;\n                    if (record.blob instanceof qq.BlobProxy) {\n                        blobSize = -1;\n                    }\n                    id = uploadData.addFile({\n                        uuid: record.uuid,\n                        name: record.name,\n                        size: blobSize,\n                        batchId: batchId,\n                        proxyGroupId: proxyGroupId\n                    });\n                    if (record.blob instanceof qq.BlobProxy) {\n                        scaledIds.push(id);\n                    } else {\n                        originalId = id;\n                    }\n                    if (record.blob) {\n                        addFileToHandler(id, record.blob);\n                        fileList.push({\n                            id: id,\n                            file: record.blob\n                        });\n                    } else {\n                        uploadData.setStatus(id, qq.status.REJECTED);\n                    }\n                });\n                if (originalId !== null) {\n                    qq.each(scaledIds, function(idx, scaledId) {\n                        var params = {\n                            qqparentuuid: uploadData.retrieve({\n                                id: originalId\n                            }).uuid,\n                            qqparentsize: uploadData.retrieve({\n                                id: originalId\n                            }).size\n                        };\n                        params[uuidParamName] = uploadData.retrieve({\n                            id: scaledId\n                        }).uuid;\n                        uploadData.setParentId(scaledId, originalId);\n                        paramsStore.addReadOnly(scaledId, params);\n                    });\n                    if (scaledIds.length) {\n                        (function() {\n                            var param = {};\n                            param[uuidParamName] = uploadData.retrieve({\n                                id: originalId\n                            }).uuid;\n                            paramsStore.addReadOnly(originalId, param);\n                        })();\n                    }\n                }\n            }\n        });\n    };\n    qq.extend(qq.Scaler.prototype, {\n        scaleImage: function(id, specs, api) {\n            \"use strict\";\n            if (!qq.supportedFeatures.scaling) {\n                throw new qq.Error(\"Scaling is not supported in this browser!\");\n            }\n            var scalingEffort = new qq.Promise(), log = api.log, file = api.getFile(id), uploadData = api.uploadData.retrieve({\n                id: id\n            }), name = uploadData && uploadData.name, uuid = uploadData && uploadData.uuid, scalingOptions = {\n                customResizer: specs.customResizer,\n                sendOriginal: false,\n                orient: specs.orient,\n                defaultType: specs.type || null,\n                defaultQuality: specs.quality,\n                failedToScaleText: \"Unable to scale\",\n                sizes: [ {\n                    name: \"\",\n                    maxSize: specs.maxSize\n                } ]\n            }, scaler = new qq.Scaler(scalingOptions, log);\n            if (!qq.Scaler || !qq.supportedFeatures.imagePreviews || !file) {\n                scalingEffort.failure();\n                log(\"Could not generate requested scaled image for \" + id + \".  \" + \"Scaling is either not possible in this browser, or the file could not be located.\", \"error\");\n            } else {\n                qq.bind(function() {\n                    var record = scaler.getFileRecords(uuid, name, file)[0];\n                    if (record && record.blob instanceof qq.BlobProxy) {\n                        record.blob.create().then(scalingEffort.success, scalingEffort.failure);\n                    } else {\n                        log(id + \" is not a scalable image!\", \"error\");\n                        scalingEffort.failure();\n                    }\n                }, this)();\n            }\n            return scalingEffort;\n        },\n        _determineOutputType: function(spec) {\n            \"use strict\";\n            var requestedType = spec.requestedType, defaultType = spec.defaultType, referenceType = spec.refType;\n            if (!defaultType && !requestedType) {\n                if (referenceType !== \"image/jpeg\") {\n                    return \"image/png\";\n                }\n                return referenceType;\n            }\n            if (!requestedType) {\n                return defaultType;\n            }\n            if (qq.indexOf(Object.keys(qq.Identify.prototype.PREVIEWABLE_MIME_TYPES), requestedType) >= 0) {\n                if (requestedType === \"image/tiff\") {\n                    return qq.supportedFeatures.tiffPreviews ? requestedType : defaultType;\n                }\n                return requestedType;\n            }\n            return defaultType;\n        },\n        _getName: function(originalName, scaledVersionProperties) {\n            \"use strict\";\n            var startOfExt = originalName.lastIndexOf(\".\"), versionType = scaledVersionProperties.type || \"image/png\", referenceType = scaledVersionProperties.refType, scaledName = \"\", scaledExt = qq.getExtension(originalName), nameAppendage = \"\";\n            if (scaledVersionProperties.name && scaledVersionProperties.name.trim().length) {\n                nameAppendage = \" (\" + scaledVersionProperties.name + \")\";\n            }\n            if (startOfExt >= 0) {\n                scaledName = originalName.substr(0, startOfExt);\n                if (referenceType !== versionType) {\n                    scaledExt = versionType.split(\"/\")[1];\n                }\n                scaledName += nameAppendage + \".\" + scaledExt;\n            } else {\n                scaledName = originalName + nameAppendage;\n            }\n            return scaledName;\n        },\n        _getSortedSizes: function(sizes) {\n            \"use strict\";\n            sizes = qq.extend([], sizes);\n            return sizes.sort(function(a, b) {\n                if (a.maxSize > b.maxSize) {\n                    return 1;\n                }\n                if (a.maxSize < b.maxSize) {\n                    return -1;\n                }\n                return 0;\n            });\n        },\n        _generateScaledImage: function(spec, sourceFile) {\n            \"use strict\";\n            var self = this, customResizeFunction = spec.customResizeFunction, log = spec.log, maxSize = spec.maxSize, orient = spec.orient, type = spec.type, quality = spec.quality, failedText = spec.failedText, includeExif = spec.includeExif && sourceFile.type === \"image/jpeg\" && type === \"image/jpeg\", scalingEffort = new qq.Promise(), imageGenerator = new qq.ImageGenerator(log), canvas = document.createElement(\"canvas\");\n            log(\"Attempting to generate scaled version for \" + sourceFile.name);\n            imageGenerator.generate(sourceFile, canvas, {\n                maxSize: maxSize,\n                orient: orient,\n                customResizeFunction: customResizeFunction\n            }).then(function() {\n                var scaledImageDataUri = canvas.toDataURL(type, quality), signalSuccess = function() {\n                    log(\"Success generating scaled version for \" + sourceFile.name);\n                    var blob = qq.dataUriToBlob(scaledImageDataUri);\n                    scalingEffort.success(blob);\n                };\n                if (includeExif) {\n                    self._insertExifHeader(sourceFile, scaledImageDataUri, log).then(function(scaledImageDataUriWithExif) {\n                        scaledImageDataUri = scaledImageDataUriWithExif;\n                        signalSuccess();\n                    }, function() {\n                        log(\"Problem inserting EXIF header into scaled image.  Using scaled image w/out EXIF data.\", \"error\");\n                        signalSuccess();\n                    });\n                } else {\n                    signalSuccess();\n                }\n            }, function() {\n                log(\"Failed attempt to generate scaled version for \" + sourceFile.name, \"error\");\n                scalingEffort.failure(failedText);\n            });\n            return scalingEffort;\n        },\n        _insertExifHeader: function(originalImage, scaledImageDataUri, log) {\n            \"use strict\";\n            var reader = new FileReader(), insertionEffort = new qq.Promise(), originalImageDataUri = \"\";\n            reader.onload = function() {\n                originalImageDataUri = reader.result;\n                insertionEffort.success(qq.ExifRestorer.restore(originalImageDataUri, scaledImageDataUri));\n            };\n            reader.onerror = function() {\n                log(\"Problem reading \" + originalImage.name + \" during attempt to transfer EXIF data to scaled version.\", \"error\");\n                insertionEffort.failure();\n            };\n            reader.readAsDataURL(originalImage);\n            return insertionEffort;\n        },\n        _dataUriToBlob: function(dataUri) {\n            \"use strict\";\n            var byteString, mimeString, arrayBuffer, intArray;\n            if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n                byteString = atob(dataUri.split(\",\")[1]);\n            } else {\n                byteString = decodeURI(dataUri.split(\",\")[1]);\n            }\n            mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n            arrayBuffer = new ArrayBuffer(byteString.length);\n            intArray = new Uint8Array(arrayBuffer);\n            qq.each(byteString, function(idx, character) {\n                intArray[idx] = character.charCodeAt(0);\n            });\n            return this._createBlob(arrayBuffer, mimeString);\n        },\n        _createBlob: function(data, mime) {\n            \"use strict\";\n            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, blobBuilder = BlobBuilder && new BlobBuilder();\n            if (blobBuilder) {\n                blobBuilder.append(data);\n                return blobBuilder.getBlob(mime);\n            } else {\n                return new Blob([ data ], {\n                    type: mime\n                });\n            }\n        }\n    });\n    qq.ExifRestorer = function() {\n        var ExifRestorer = {};\n        ExifRestorer.KEY_STR = \"ABCDEFGHIJKLMNOP\" + \"QRSTUVWXYZabcdef\" + \"ghijklmnopqrstuv\" + \"wxyz0123456789+/\" + \"=\";\n        ExifRestorer.encode64 = function(input) {\n            var output = \"\", chr1, chr2, chr3 = \"\", enc1, enc2, enc3, enc4 = \"\", i = 0;\n            do {\n                chr1 = input[i++];\n                chr2 = input[i++];\n                chr3 = input[i++];\n                enc1 = chr1 >> 2;\n                enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n                enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n                enc4 = chr3 & 63;\n                if (isNaN(chr2)) {\n                    enc3 = enc4 = 64;\n                } else if (isNaN(chr3)) {\n                    enc4 = 64;\n                }\n                output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);\n                chr1 = chr2 = chr3 = \"\";\n                enc1 = enc2 = enc3 = enc4 = \"\";\n            } while (i < input.length);\n            return output;\n        };\n        ExifRestorer.restore = function(origFileBase64, resizedFileBase64) {\n            var expectedBase64Header = \"data:image/jpeg;base64,\";\n            if (!origFileBase64.match(expectedBase64Header)) {\n                return resizedFileBase64;\n            }\n            var rawImage = this.decode64(origFileBase64.replace(expectedBase64Header, \"\"));\n            var segments = this.slice2Segments(rawImage);\n            var image = this.exifManipulation(resizedFileBase64, segments);\n            return expectedBase64Header + this.encode64(image);\n        };\n        ExifRestorer.exifManipulation = function(resizedFileBase64, segments) {\n            var exifArray = this.getExifArray(segments), newImageArray = this.insertExif(resizedFileBase64, exifArray), aBuffer = new Uint8Array(newImageArray);\n            return aBuffer;\n        };\n        ExifRestorer.getExifArray = function(segments) {\n            var seg;\n            for (var x = 0; x < segments.length; x++) {\n                seg = segments[x];\n                if (seg[0] == 255 & seg[1] == 225) {\n                    return seg;\n                }\n            }\n            return [];\n        };\n        ExifRestorer.insertExif = function(resizedFileBase64, exifArray) {\n            var imageData = resizedFileBase64.replace(\"data:image/jpeg;base64,\", \"\"), buf = this.decode64(imageData), separatePoint = buf.indexOf(255, 3), mae = buf.slice(0, separatePoint), ato = buf.slice(separatePoint), array = mae;\n            array = array.concat(exifArray);\n            array = array.concat(ato);\n            return array;\n        };\n        ExifRestorer.slice2Segments = function(rawImageArray) {\n            var head = 0, segments = [];\n            while (1) {\n                if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 218) {\n                    break;\n                }\n                if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 216) {\n                    head += 2;\n                } else {\n                    var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3], endPoint = head + length + 2, seg = rawImageArray.slice(head, endPoint);\n                    segments.push(seg);\n                    head = endPoint;\n                }\n                if (head > rawImageArray.length) {\n                    break;\n                }\n            }\n            return segments;\n        };\n        ExifRestorer.decode64 = function(input) {\n            var output = \"\", chr1, chr2, chr3 = \"\", enc1, enc2, enc3, enc4 = \"\", i = 0, buf = [];\n            var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n            if (base64test.exec(input)) {\n                throw new Error(\"There were invalid base64 characters in the input text.  \" + \"Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\");\n            }\n            input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n            do {\n                enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n                enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n                enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n                enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n                chr1 = enc1 << 2 | enc2 >> 4;\n                chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n                chr3 = (enc3 & 3) << 6 | enc4;\n                buf.push(chr1);\n                if (enc3 != 64) {\n                    buf.push(chr2);\n                }\n                if (enc4 != 64) {\n                    buf.push(chr3);\n                }\n                chr1 = chr2 = chr3 = \"\";\n                enc1 = enc2 = enc3 = enc4 = \"\";\n            } while (i < input.length);\n            return buf;\n        };\n        return ExifRestorer;\n    }();\n    qq.TotalProgress = function(callback, getSize) {\n        \"use strict\";\n        var perFileProgress = {}, totalLoaded = 0, totalSize = 0, lastLoadedSent = -1, lastTotalSent = -1, callbackProxy = function(loaded, total) {\n            if (loaded !== lastLoadedSent || total !== lastTotalSent) {\n                callback(loaded, total);\n            }\n            lastLoadedSent = loaded;\n            lastTotalSent = total;\n        }, noRetryableFiles = function(failed, retryable) {\n            var none = true;\n            qq.each(failed, function(idx, failedId) {\n                if (qq.indexOf(retryable, failedId) >= 0) {\n                    none = false;\n                    return false;\n                }\n            });\n            return none;\n        }, onCancel = function(id) {\n            updateTotalProgress(id, -1, -1);\n            delete perFileProgress[id];\n        }, onAllComplete = function(successful, failed, retryable) {\n            if (failed.length === 0 || noRetryableFiles(failed, retryable)) {\n                callbackProxy(totalSize, totalSize);\n                this.reset();\n            }\n        }, onNew = function(id) {\n            var size = getSize(id);\n            if (size > 0) {\n                updateTotalProgress(id, 0, size);\n                perFileProgress[id] = {\n                    loaded: 0,\n                    total: size\n                };\n            }\n        }, updateTotalProgress = function(id, newLoaded, newTotal) {\n            var oldLoaded = perFileProgress[id] ? perFileProgress[id].loaded : 0, oldTotal = perFileProgress[id] ? perFileProgress[id].total : 0;\n            if (newLoaded === -1 && newTotal === -1) {\n                totalLoaded -= oldLoaded;\n                totalSize -= oldTotal;\n            } else {\n                if (newLoaded) {\n                    totalLoaded += newLoaded - oldLoaded;\n                }\n                if (newTotal) {\n                    totalSize += newTotal - oldTotal;\n                }\n            }\n            callbackProxy(totalLoaded, totalSize);\n        };\n        qq.extend(this, {\n            onAllComplete: onAllComplete,\n            onStatusChange: function(id, oldStatus, newStatus) {\n                if (newStatus === qq.status.CANCELED || newStatus === qq.status.REJECTED) {\n                    onCancel(id);\n                } else if (newStatus === qq.status.SUBMITTING) {\n                    onNew(id);\n                }\n            },\n            onIndividualProgress: function(id, loaded, total) {\n                updateTotalProgress(id, loaded, total);\n                perFileProgress[id] = {\n                    loaded: loaded,\n                    total: total\n                };\n            },\n            onNewSize: function(id) {\n                onNew(id);\n            },\n            reset: function() {\n                perFileProgress = {};\n                totalLoaded = 0;\n                totalSize = 0;\n            }\n        });\n    };\n    qq.PasteSupport = function(o) {\n        \"use strict\";\n        var options, detachPasteHandler;\n        options = {\n            targetElement: null,\n            callbacks: {\n                log: function(message, level) {},\n                pasteReceived: function(blob) {}\n            }\n        };\n        function isImage(item) {\n            return item.type && item.type.indexOf(\"image/\") === 0;\n        }\n        function registerPasteHandler() {\n            detachPasteHandler = qq(options.targetElement).attach(\"paste\", function(event) {\n                var clipboardData = event.clipboardData;\n                if (clipboardData) {\n                    qq.each(clipboardData.items, function(idx, item) {\n                        if (isImage(item)) {\n                            var blob = item.getAsFile();\n                            options.callbacks.pasteReceived(blob);\n                        }\n                    });\n                }\n            });\n        }\n        function unregisterPasteHandler() {\n            if (detachPasteHandler) {\n                detachPasteHandler();\n            }\n        }\n        qq.extend(options, o);\n        registerPasteHandler();\n        qq.extend(this, {\n            reset: function() {\n                unregisterPasteHandler();\n            }\n        });\n    };\n    qq.FormSupport = function(options, startUpload, log) {\n        \"use strict\";\n        var self = this, interceptSubmit = options.interceptSubmit, formEl = options.element, autoUpload = options.autoUpload;\n        qq.extend(this, {\n            newEndpoint: null,\n            newAutoUpload: autoUpload,\n            attachedToForm: false,\n            getFormInputsAsObject: function() {\n                if (formEl == null) {\n                    return null;\n                }\n                return self._form2Obj(formEl);\n            }\n        });\n        function determineNewEndpoint(formEl) {\n            if (formEl.getAttribute(\"action\")) {\n                self.newEndpoint = formEl.getAttribute(\"action\");\n            }\n        }\n        function validateForm(formEl, nativeSubmit) {\n            if (formEl.checkValidity && !formEl.checkValidity()) {\n                log(\"Form did not pass validation checks - will not upload.\", \"error\");\n                nativeSubmit();\n            } else {\n                return true;\n            }\n        }\n        function maybeUploadOnSubmit(formEl) {\n            var nativeSubmit = formEl.submit;\n            qq(formEl).attach(\"submit\", function(event) {\n                event = event || window.event;\n                if (event.preventDefault) {\n                    event.preventDefault();\n                } else {\n                    event.returnValue = false;\n                }\n                validateForm(formEl, nativeSubmit) && startUpload();\n            });\n            formEl.submit = function() {\n                validateForm(formEl, nativeSubmit) && startUpload();\n            };\n        }\n        function determineFormEl(formEl) {\n            if (formEl) {\n                if (qq.isString(formEl)) {\n                    formEl = document.getElementById(formEl);\n                }\n                if (formEl) {\n                    log(\"Attaching to form element.\");\n                    determineNewEndpoint(formEl);\n                    interceptSubmit && maybeUploadOnSubmit(formEl);\n                }\n            }\n            return formEl;\n        }\n        formEl = determineFormEl(formEl);\n        this.attachedToForm = !!formEl;\n    };\n    qq.extend(qq.FormSupport.prototype, {\n        _form2Obj: function(form) {\n            \"use strict\";\n            var obj = {}, notIrrelevantType = function(type) {\n                var irrelevantTypes = [ \"button\", \"image\", \"reset\", \"submit\" ];\n                return qq.indexOf(irrelevantTypes, type.toLowerCase()) < 0;\n            }, radioOrCheckbox = function(type) {\n                return qq.indexOf([ \"checkbox\", \"radio\" ], type.toLowerCase()) >= 0;\n            }, ignoreValue = function(el) {\n                if (radioOrCheckbox(el.type) && !el.checked) {\n                    return true;\n                }\n                return el.disabled && el.type.toLowerCase() !== \"hidden\";\n            }, selectValue = function(select) {\n                var value = null;\n                qq.each(qq(select).children(), function(idx, child) {\n                    if (child.tagName.toLowerCase() === \"option\" && child.selected) {\n                        value = child.value;\n                        return false;\n                    }\n                });\n                return value;\n            };\n            qq.each(form.elements, function(idx, el) {\n                if ((qq.isInput(el, true) || el.tagName.toLowerCase() === \"textarea\") && notIrrelevantType(el.type) && !ignoreValue(el)) {\n                    obj[el.name] = el.value;\n                } else if (el.tagName.toLowerCase() === \"select\" && !ignoreValue(el)) {\n                    var value = selectValue(el);\n                    if (value !== null) {\n                        obj[el.name] = value;\n                    }\n                }\n            });\n            return obj;\n        }\n    });\n    qq.traditional = qq.traditional || {};\n    qq.traditional.FormUploadHandler = function(options, proxy) {\n        \"use strict\";\n        var handler = this, getName = proxy.getName, getUuid = proxy.getUuid, log = proxy.log;\n        function getIframeContentJson(id, iframe) {\n            var response, doc, innerHtml;\n            try {\n                doc = iframe.contentDocument || iframe.contentWindow.document;\n                innerHtml = doc.body.innerHTML;\n                log(\"converting iframe's innerHTML to JSON\");\n                log(\"innerHTML = \" + innerHtml);\n                if (innerHtml && innerHtml.match(/^<pre/i)) {\n                    innerHtml = doc.body.firstChild.firstChild.nodeValue;\n                }\n                response = handler._parseJsonResponse(innerHtml);\n            } catch (error) {\n                log(\"Error when attempting to parse form upload response (\" + error.message + \")\", \"error\");\n                response = {\n                    success: false\n                };\n            }\n            return response;\n        }\n        function createForm(id, iframe) {\n            var params = options.paramsStore.get(id), method = options.method.toLowerCase() === \"get\" ? \"GET\" : \"POST\", endpoint = options.endpointStore.get(id), name = getName(id);\n            params[options.uuidName] = getUuid(id);\n            params[options.filenameParam] = name;\n            return handler._initFormForUpload({\n                method: method,\n                endpoint: endpoint,\n                params: params,\n                paramsInBody: options.paramsInBody,\n                targetName: iframe.name\n            });\n        }\n        this.uploadFile = function(id) {\n            var input = handler.getInput(id), iframe = handler._createIframe(id), promise = new qq.Promise(), form;\n            form = createForm(id, iframe);\n            form.appendChild(input);\n            handler._attachLoadEvent(iframe, function(responseFromMessage) {\n                log(\"iframe loaded\");\n                var response = responseFromMessage ? responseFromMessage : getIframeContentJson(id, iframe);\n                handler._detachLoadEvent(id);\n                if (!options.cors.expected) {\n                    qq(iframe).remove();\n                }\n                if (response.success) {\n                    promise.success(response);\n                } else {\n                    promise.failure(response);\n                }\n            });\n            log(\"Sending upload request for \" + id);\n            form.submit();\n            qq(form).remove();\n            return promise;\n        };\n        qq.extend(this, new qq.FormUploadHandler({\n            options: {\n                isCors: options.cors.expected,\n                inputName: options.inputName\n            },\n            proxy: {\n                onCancel: options.onCancel,\n                getName: getName,\n                getUuid: getUuid,\n                log: log\n            }\n        }));\n    };\n    qq.traditional = qq.traditional || {};\n    qq.traditional.XhrUploadHandler = function(spec, proxy) {\n        \"use strict\";\n        var handler = this, getName = proxy.getName, getSize = proxy.getSize, getUuid = proxy.getUuid, log = proxy.log, multipart = spec.forceMultipart || spec.paramsInBody, addChunkingSpecificParams = function(id, params, chunkData) {\n            var size = getSize(id), name = getName(id);\n            params[spec.chunking.paramNames.partIndex] = chunkData.part;\n            params[spec.chunking.paramNames.partByteOffset] = chunkData.start;\n            params[spec.chunking.paramNames.chunkSize] = chunkData.size;\n            params[spec.chunking.paramNames.totalParts] = chunkData.count;\n            params[spec.totalFileSizeName] = size;\n            if (multipart) {\n                params[spec.filenameParam] = name;\n            }\n        }, allChunksDoneRequester = new qq.traditional.AllChunksDoneAjaxRequester({\n            cors: spec.cors,\n            endpoint: spec.chunking.success.endpoint,\n            log: log\n        }), createReadyStateChangedHandler = function(id, xhr) {\n            var promise = new qq.Promise();\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4) {\n                    var result = onUploadOrChunkComplete(id, xhr);\n                    if (result.success) {\n                        promise.success(result.response, xhr);\n                    } else {\n                        promise.failure(result.response, xhr);\n                    }\n                }\n            };\n            return promise;\n        }, getChunksCompleteParams = function(id) {\n            var params = spec.paramsStore.get(id), name = getName(id), size = getSize(id);\n            params[spec.uuidName] = getUuid(id);\n            params[spec.filenameParam] = name;\n            params[spec.totalFileSizeName] = size;\n            params[spec.chunking.paramNames.totalParts] = handler._getTotalChunks(id);\n            return params;\n        }, isErrorUploadResponse = function(xhr, response) {\n            return qq.indexOf([ 200, 201, 202, 203, 204 ], xhr.status) < 0 || !response.success || response.reset;\n        }, onUploadOrChunkComplete = function(id, xhr) {\n            var response;\n            log(\"xhr - server response received for \" + id);\n            log(\"responseText = \" + xhr.responseText);\n            response = parseResponse(true, xhr);\n            return {\n                success: !isErrorUploadResponse(xhr, response),\n                response: response\n            };\n        }, parseResponse = function(upload, xhr) {\n            var response = {};\n            try {\n                log(qq.format(\"Received response status {} with body: {}\", xhr.status, xhr.responseText));\n                response = qq.parseJson(xhr.responseText);\n            } catch (error) {\n                upload && log(\"Error when attempting to parse xhr response text (\" + error.message + \")\", \"error\");\n            }\n            return response;\n        }, sendChunksCompleteRequest = function(id) {\n            var promise = new qq.Promise();\n            allChunksDoneRequester.complete(id, handler._createXhr(id), getChunksCompleteParams(id), spec.customHeaders.get(id)).then(function(xhr) {\n                promise.success(parseResponse(false, xhr), xhr);\n            }, function(xhr) {\n                promise.failure(parseResponse(false, xhr), xhr);\n            });\n            return promise;\n        }, setParamsAndGetEntityToSend = function(params, xhr, fileOrBlob, id) {\n            var formData = new FormData(), method = spec.method, endpoint = spec.endpointStore.get(id), name = getName(id), size = getSize(id);\n            params[spec.uuidName] = getUuid(id);\n            params[spec.filenameParam] = name;\n            if (multipart) {\n                params[spec.totalFileSizeName] = size;\n            }\n            if (!spec.paramsInBody) {\n                if (!multipart) {\n                    params[spec.inputName] = name;\n                }\n                endpoint = qq.obj2url(params, endpoint);\n            }\n            xhr.open(method, endpoint, true);\n            if (spec.cors.expected && spec.cors.sendCredentials) {\n                xhr.withCredentials = true;\n            }\n            if (multipart) {\n                if (spec.paramsInBody) {\n                    qq.obj2FormData(params, formData);\n                }\n                formData.append(spec.inputName, fileOrBlob);\n                return formData;\n            }\n            return fileOrBlob;\n        }, setUploadHeaders = function(id, xhr) {\n            var extraHeaders = spec.customHeaders.get(id), fileOrBlob = handler.getFile(id);\n            xhr.setRequestHeader(\"Accept\", \"application/json\");\n            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n            xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n            if (!multipart) {\n                xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\n                xhr.setRequestHeader(\"X-Mime-Type\", fileOrBlob.type);\n            }\n            qq.each(extraHeaders, function(name, val) {\n                xhr.setRequestHeader(name, val);\n            });\n        };\n        qq.extend(this, {\n            uploadChunk: function(id, chunkIdx, resuming) {\n                var chunkData = handler._getChunkData(id, chunkIdx), xhr = handler._createXhr(id, chunkIdx), size = getSize(id), promise, toSend, params;\n                promise = createReadyStateChangedHandler(id, xhr);\n                handler._registerProgressHandler(id, chunkIdx, chunkData.size);\n                params = spec.paramsStore.get(id);\n                addChunkingSpecificParams(id, params, chunkData);\n                if (resuming) {\n                    params[spec.resume.paramNames.resuming] = true;\n                }\n                toSend = setParamsAndGetEntityToSend(params, xhr, chunkData.blob, id);\n                setUploadHeaders(id, xhr);\n                xhr.send(toSend);\n                return promise;\n            },\n            uploadFile: function(id) {\n                var fileOrBlob = handler.getFile(id), promise, xhr, params, toSend;\n                xhr = handler._createXhr(id);\n                handler._registerProgressHandler(id);\n                promise = createReadyStateChangedHandler(id, xhr);\n                params = spec.paramsStore.get(id);\n                toSend = setParamsAndGetEntityToSend(params, xhr, fileOrBlob, id);\n                setUploadHeaders(id, xhr);\n                xhr.send(toSend);\n                return promise;\n            }\n        });\n        qq.extend(this, new qq.XhrUploadHandler({\n            options: qq.extend({\n                namespace: \"traditional\"\n            }, spec),\n            proxy: qq.extend({\n                getEndpoint: spec.endpointStore.get\n            }, proxy)\n        }));\n        qq.override(this, function(super_) {\n            return {\n                finalizeChunks: function(id) {\n                    if (spec.chunking.success.endpoint) {\n                        return sendChunksCompleteRequest(id);\n                    } else {\n                        return super_.finalizeChunks(id, qq.bind(parseResponse, this, true));\n                    }\n                }\n            };\n        });\n    };\n    qq.traditional.AllChunksDoneAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, method = \"POST\", options = {\n            cors: {\n                allowXdr: false,\n                expected: false,\n                sendCredentials: false\n            },\n            endpoint: null,\n            log: function(str, level) {}\n        }, promises = {}, endpointHandler = {\n            get: function(id) {\n                return options.endpoint;\n            }\n        };\n        qq.extend(options, o);\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            validMethods: [ method ],\n            method: method,\n            endpointStore: endpointHandler,\n            allowXRequestedWithAndCacheControl: false,\n            cors: options.cors,\n            log: options.log,\n            onComplete: function(id, xhr, isError) {\n                var promise = promises[id];\n                delete promises[id];\n                if (isError) {\n                    promise.failure(xhr);\n                } else {\n                    promise.success(xhr);\n                }\n            }\n        }));\n        qq.extend(this, {\n            complete: function(id, xhr, params, headers) {\n                var promise = new qq.Promise();\n                options.log(\"Submitting All Chunks Done request for \" + id);\n                promises[id] = promise;\n                requester.initTransport(id).withParams(params).withHeaders(headers).send(xhr);\n                return promise;\n            }\n        });\n    };\n    qq.DragAndDrop = function(o) {\n        \"use strict\";\n        var options, HIDE_ZONES_EVENT_NAME = \"qq-hidezones\", HIDE_BEFORE_ENTER_ATTR = \"qq-hide-dropzone\", uploadDropZones = [], droppedFiles = [], disposeSupport = new qq.DisposeSupport();\n        options = {\n            dropZoneElements: [],\n            allowMultipleItems: true,\n            classes: {\n                dropActive: null\n            },\n            callbacks: new qq.DragAndDrop.callbacks()\n        };\n        qq.extend(options, o, true);\n        function uploadDroppedFiles(files, uploadDropZone) {\n            var filesAsArray = Array.prototype.slice.call(files);\n            options.callbacks.dropLog(\"Grabbed \" + files.length + \" dropped files.\");\n            uploadDropZone.dropDisabled(false);\n            options.callbacks.processingDroppedFilesComplete(filesAsArray, uploadDropZone.getElement());\n        }\n        function traverseFileTree(entry) {\n            var parseEntryPromise = new qq.Promise();\n            if (entry.isFile) {\n                entry.file(function(file) {\n                    var name = entry.name, fullPath = entry.fullPath, indexOfNameInFullPath = fullPath.indexOf(name);\n                    fullPath = fullPath.substr(0, indexOfNameInFullPath);\n                    if (fullPath.charAt(0) === \"/\") {\n                        fullPath = fullPath.substr(1);\n                    }\n                    file.qqPath = fullPath;\n                    droppedFiles.push(file);\n                    parseEntryPromise.success();\n                }, function(fileError) {\n                    options.callbacks.dropLog(\"Problem parsing '\" + entry.fullPath + \"'.  FileError code \" + fileError.code + \".\", \"error\");\n                    parseEntryPromise.failure();\n                });\n            } else if (entry.isDirectory) {\n                getFilesInDirectory(entry).then(function allEntriesRead(entries) {\n                    var entriesLeft = entries.length;\n                    qq.each(entries, function(idx, entry) {\n                        traverseFileTree(entry).done(function() {\n                            entriesLeft -= 1;\n                            if (entriesLeft === 0) {\n                                parseEntryPromise.success();\n                            }\n                        });\n                    });\n                    if (!entries.length) {\n                        parseEntryPromise.success();\n                    }\n                }, function readFailure(fileError) {\n                    options.callbacks.dropLog(\"Problem parsing '\" + entry.fullPath + \"'.  FileError code \" + fileError.code + \".\", \"error\");\n                    parseEntryPromise.failure();\n                });\n            }\n            return parseEntryPromise;\n        }\n        function getFilesInDirectory(entry, reader, accumEntries, existingPromise) {\n            var promise = existingPromise || new qq.Promise(), dirReader = reader || entry.createReader();\n            dirReader.readEntries(function readSuccess(entries) {\n                var newEntries = accumEntries ? accumEntries.concat(entries) : entries;\n                if (entries.length) {\n                    setTimeout(function() {\n                        getFilesInDirectory(entry, dirReader, newEntries, promise);\n                    }, 0);\n                } else {\n                    promise.success(newEntries);\n                }\n            }, promise.failure);\n            return promise;\n        }\n        function handleDataTransfer(dataTransfer, uploadDropZone) {\n            var pendingFolderPromises = [], handleDataTransferPromise = new qq.Promise();\n            options.callbacks.processingDroppedFiles();\n            uploadDropZone.dropDisabled(true);\n            if (dataTransfer.files.length > 1 && !options.allowMultipleItems) {\n                options.callbacks.processingDroppedFilesComplete([]);\n                options.callbacks.dropError(\"tooManyFilesError\", \"\");\n                uploadDropZone.dropDisabled(false);\n                handleDataTransferPromise.failure();\n            } else {\n                droppedFiles = [];\n                if (qq.isFolderDropSupported(dataTransfer)) {\n                    qq.each(dataTransfer.items, function(idx, item) {\n                        var entry = item.webkitGetAsEntry();\n                        if (entry) {\n                            if (entry.isFile) {\n                                droppedFiles.push(item.getAsFile());\n                            } else {\n                                pendingFolderPromises.push(traverseFileTree(entry).done(function() {\n                                    pendingFolderPromises.pop();\n                                    if (pendingFolderPromises.length === 0) {\n                                        handleDataTransferPromise.success();\n                                    }\n                                }));\n                            }\n                        }\n                    });\n                } else {\n                    droppedFiles = dataTransfer.files;\n                }\n                if (pendingFolderPromises.length === 0) {\n                    handleDataTransferPromise.success();\n                }\n            }\n            return handleDataTransferPromise;\n        }\n        function setupDropzone(dropArea) {\n            var dropZone = new qq.UploadDropZone({\n                HIDE_ZONES_EVENT_NAME: HIDE_ZONES_EVENT_NAME,\n                element: dropArea,\n                onEnter: function(e) {\n                    qq(dropArea).addClass(options.classes.dropActive);\n                    e.stopPropagation();\n                },\n                onLeaveNotDescendants: function(e) {\n                    qq(dropArea).removeClass(options.classes.dropActive);\n                },\n                onDrop: function(e) {\n                    handleDataTransfer(e.dataTransfer, dropZone).then(function() {\n                        uploadDroppedFiles(droppedFiles, dropZone);\n                    }, function() {\n                        options.callbacks.dropLog(\"Drop event DataTransfer parsing failed.  No files will be uploaded.\", \"error\");\n                    });\n                }\n            });\n            disposeSupport.addDisposer(function() {\n                dropZone.dispose();\n            });\n            qq(dropArea).hasAttribute(HIDE_BEFORE_ENTER_ATTR) && qq(dropArea).hide();\n            uploadDropZones.push(dropZone);\n            return dropZone;\n        }\n        function isFileDrag(dragEvent) {\n            var fileDrag;\n            qq.each(dragEvent.dataTransfer.types, function(key, val) {\n                if (val === \"Files\") {\n                    fileDrag = true;\n                    return false;\n                }\n            });\n            return fileDrag;\n        }\n        function leavingDocumentOut(e) {\n            if (qq.firefox()) {\n                return !e.relatedTarget;\n            }\n            if (qq.safari()) {\n                return e.x < 0 || e.y < 0;\n            }\n            return e.x === 0 && e.y === 0;\n        }\n        function setupDragDrop() {\n            var dropZones = options.dropZoneElements, maybeHideDropZones = function() {\n                setTimeout(function() {\n                    qq.each(dropZones, function(idx, dropZone) {\n                        qq(dropZone).hasAttribute(HIDE_BEFORE_ENTER_ATTR) && qq(dropZone).hide();\n                        qq(dropZone).removeClass(options.classes.dropActive);\n                    });\n                }, 10);\n            };\n            qq.each(dropZones, function(idx, dropZone) {\n                var uploadDropZone = setupDropzone(dropZone);\n                if (dropZones.length && qq.supportedFeatures.fileDrop) {\n                    disposeSupport.attach(document, \"dragenter\", function(e) {\n                        if (!uploadDropZone.dropDisabled() && isFileDrag(e)) {\n                            qq.each(dropZones, function(idx, dropZone) {\n                                if (dropZone instanceof HTMLElement && qq(dropZone).hasAttribute(HIDE_BEFORE_ENTER_ATTR)) {\n                                    qq(dropZone).css({\n                                        display: \"block\"\n                                    });\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n            disposeSupport.attach(document, \"dragleave\", function(e) {\n                if (leavingDocumentOut(e)) {\n                    maybeHideDropZones();\n                }\n            });\n            disposeSupport.attach(qq(document).children()[0], \"mouseenter\", function(e) {\n                maybeHideDropZones();\n            });\n            disposeSupport.attach(document, \"drop\", function(e) {\n                e.preventDefault();\n                maybeHideDropZones();\n            });\n            disposeSupport.attach(document, HIDE_ZONES_EVENT_NAME, maybeHideDropZones);\n        }\n        setupDragDrop();\n        qq.extend(this, {\n            setupExtraDropzone: function(element) {\n                options.dropZoneElements.push(element);\n                setupDropzone(element);\n            },\n            removeDropzone: function(element) {\n                var i, dzs = options.dropZoneElements;\n                for (i in dzs) {\n                    if (dzs[i] === element) {\n                        return dzs.splice(i, 1);\n                    }\n                }\n            },\n            dispose: function() {\n                disposeSupport.dispose();\n                qq.each(uploadDropZones, function(idx, dropZone) {\n                    dropZone.dispose();\n                });\n            }\n        });\n    };\n    qq.DragAndDrop.callbacks = function() {\n        \"use strict\";\n        return {\n            processingDroppedFiles: function() {},\n            processingDroppedFilesComplete: function(files, targetEl) {},\n            dropError: function(code, errorSpecifics) {\n                qq.log(\"Drag & drop error code '\" + code + \" with these specifics: '\" + errorSpecifics + \"'\", \"error\");\n            },\n            dropLog: function(message, level) {\n                qq.log(message, level);\n            }\n        };\n    };\n    qq.UploadDropZone = function(o) {\n        \"use strict\";\n        var disposeSupport = new qq.DisposeSupport(), options, element, preventDrop, dropOutsideDisabled;\n        options = {\n            element: null,\n            onEnter: function(e) {},\n            onLeave: function(e) {},\n            onLeaveNotDescendants: function(e) {},\n            onDrop: function(e) {}\n        };\n        qq.extend(options, o);\n        element = options.element;\n        function dragoverShouldBeCanceled() {\n            return qq.safari() || qq.firefox() && qq.windows();\n        }\n        function disableDropOutside(e) {\n            if (!dropOutsideDisabled) {\n                if (dragoverShouldBeCanceled) {\n                    disposeSupport.attach(document, \"dragover\", function(e) {\n                        e.preventDefault();\n                    });\n                } else {\n                    disposeSupport.attach(document, \"dragover\", function(e) {\n                        if (e.dataTransfer) {\n                            e.dataTransfer.dropEffect = \"none\";\n                            e.preventDefault();\n                        }\n                    });\n                }\n                dropOutsideDisabled = true;\n            }\n        }\n        function isValidFileDrag(e) {\n            if (!qq.supportedFeatures.fileDrop) {\n                return false;\n            }\n            var effectTest, dt = e.dataTransfer, isSafari = qq.safari();\n            effectTest = qq.ie() && qq.supportedFeatures.fileDrop ? true : dt.effectAllowed !== \"none\";\n            return dt && effectTest && (dt.files || !isSafari && dt.types.contains && dt.types.contains(\"Files\"));\n        }\n        function isOrSetDropDisabled(isDisabled) {\n            if (isDisabled !== undefined) {\n                preventDrop = isDisabled;\n            }\n            return preventDrop;\n        }\n        function triggerHidezonesEvent() {\n            var hideZonesEvent;\n            function triggerUsingOldApi() {\n                hideZonesEvent = document.createEvent(\"Event\");\n                hideZonesEvent.initEvent(options.HIDE_ZONES_EVENT_NAME, true, true);\n            }\n            if (window.CustomEvent) {\n                try {\n                    hideZonesEvent = new CustomEvent(options.HIDE_ZONES_EVENT_NAME);\n                } catch (err) {\n                    triggerUsingOldApi();\n                }\n            } else {\n                triggerUsingOldApi();\n            }\n            document.dispatchEvent(hideZonesEvent);\n        }\n        function attachEvents() {\n            disposeSupport.attach(element, \"dragover\", function(e) {\n                if (!isValidFileDrag(e)) {\n                    return;\n                }\n                var effect = qq.ie() && qq.supportedFeatures.fileDrop ? null : e.dataTransfer.effectAllowed;\n                if (effect === \"move\" || effect === \"linkMove\") {\n                    e.dataTransfer.dropEffect = \"move\";\n                } else {\n                    e.dataTransfer.dropEffect = \"copy\";\n                }\n                e.stopPropagation();\n                e.preventDefault();\n            });\n            disposeSupport.attach(element, \"dragenter\", function(e) {\n                if (!isOrSetDropDisabled()) {\n                    if (!isValidFileDrag(e)) {\n                        return;\n                    }\n                    options.onEnter(e);\n                }\n            });\n            disposeSupport.attach(element, \"dragleave\", function(e) {\n                if (!isValidFileDrag(e)) {\n                    return;\n                }\n                options.onLeave(e);\n                var relatedTarget = document.elementFromPoint(e.clientX, e.clientY);\n                if (qq(this).contains(relatedTarget)) {\n                    return;\n                }\n                options.onLeaveNotDescendants(e);\n            });\n            disposeSupport.attach(element, \"drop\", function(e) {\n                if (!isOrSetDropDisabled()) {\n                    if (!isValidFileDrag(e)) {\n                        return;\n                    }\n                    e.preventDefault();\n                    e.stopPropagation();\n                    options.onDrop(e);\n                    triggerHidezonesEvent();\n                }\n            });\n        }\n        disableDropOutside();\n        attachEvents();\n        qq.extend(this, {\n            dropDisabled: function(isDisabled) {\n                return isOrSetDropDisabled(isDisabled);\n            },\n            dispose: function() {\n                disposeSupport.dispose();\n            },\n            getElement: function() {\n                return element;\n            }\n        });\n    };\n    (function() {\n        \"use strict\";\n        qq.uiPublicApi = {\n            addInitialFiles: function(cannedFileList) {\n                this._parent.prototype.addInitialFiles.apply(this, arguments);\n                this._templating.addCacheToDom();\n            },\n            clearStoredFiles: function() {\n                this._parent.prototype.clearStoredFiles.apply(this, arguments);\n                this._templating.clearFiles();\n            },\n            addExtraDropzone: function(element) {\n                this._dnd && this._dnd.setupExtraDropzone(element);\n            },\n            removeExtraDropzone: function(element) {\n                if (this._dnd) {\n                    return this._dnd.removeDropzone(element);\n                }\n            },\n            getItemByFileId: function(id) {\n                if (!this._templating.isHiddenForever(id)) {\n                    return this._templating.getFileContainer(id);\n                }\n            },\n            reset: function() {\n                this._parent.prototype.reset.apply(this, arguments);\n                this._templating.reset();\n                if (!this._options.button && this._templating.getButton()) {\n                    this._defaultButtonId = this._createUploadButton({\n                        element: this._templating.getButton(),\n                        title: this._options.text.fileInputTitle\n                    }).getButtonId();\n                }\n                if (this._dnd) {\n                    this._dnd.dispose();\n                    this._dnd = this._setupDragAndDrop();\n                }\n                this._totalFilesInBatch = 0;\n                this._filesInBatchAddedToUi = 0;\n                this._setupClickAndEditEventHandlers();\n            },\n            setName: function(id, newName) {\n                var formattedFilename = this._options.formatFileName(newName);\n                this._parent.prototype.setName.apply(this, arguments);\n                this._templating.updateFilename(id, formattedFilename);\n            },\n            pauseUpload: function(id) {\n                var paused = this._parent.prototype.pauseUpload.apply(this, arguments);\n                paused && this._templating.uploadPaused(id);\n                return paused;\n            },\n            continueUpload: function(id) {\n                var continued = this._parent.prototype.continueUpload.apply(this, arguments);\n                continued && this._templating.uploadContinued(id);\n                return continued;\n            },\n            getId: function(fileContainerOrChildEl) {\n                return this._templating.getFileId(fileContainerOrChildEl);\n            },\n            getDropTarget: function(fileId) {\n                var file = this.getFile(fileId);\n                return file.qqDropTarget;\n            }\n        };\n        qq.uiPrivateApi = {\n            _getButton: function(buttonId) {\n                var button = this._parent.prototype._getButton.apply(this, arguments);\n                if (!button) {\n                    if (buttonId === this._defaultButtonId) {\n                        button = this._templating.getButton();\n                    }\n                }\n                return button;\n            },\n            _removeFileItem: function(fileId) {\n                this._templating.removeFile(fileId);\n            },\n            _setupClickAndEditEventHandlers: function() {\n                this._fileButtonsClickHandler = qq.FileButtonsClickHandler && this._bindFileButtonsClickEvent();\n                this._focusinEventSupported = !qq.firefox();\n                if (this._isEditFilenameEnabled()) {\n                    this._filenameClickHandler = this._bindFilenameClickEvent();\n                    this._filenameInputFocusInHandler = this._bindFilenameInputFocusInEvent();\n                    this._filenameInputFocusHandler = this._bindFilenameInputFocusEvent();\n                }\n            },\n            _setupDragAndDrop: function() {\n                var self = this, dropZoneElements = this._options.dragAndDrop.extraDropzones, templating = this._templating, defaultDropZone = templating.getDropZone();\n                defaultDropZone && dropZoneElements.push(defaultDropZone);\n                return new qq.DragAndDrop({\n                    dropZoneElements: dropZoneElements,\n                    allowMultipleItems: this._options.multiple,\n                    classes: {\n                        dropActive: this._options.classes.dropActive\n                    },\n                    callbacks: {\n                        processingDroppedFiles: function() {\n                            templating.showDropProcessing();\n                        },\n                        processingDroppedFilesComplete: function(files, targetEl) {\n                            templating.hideDropProcessing();\n                            qq.each(files, function(idx, file) {\n                                file.qqDropTarget = targetEl;\n                            });\n                            if (files.length) {\n                                self.addFiles(files, null, null);\n                            }\n                        },\n                        dropError: function(code, errorData) {\n                            self._itemError(code, errorData);\n                        },\n                        dropLog: function(message, level) {\n                            self.log(message, level);\n                        }\n                    }\n                });\n            },\n            _bindFileButtonsClickEvent: function() {\n                var self = this;\n                return new qq.FileButtonsClickHandler({\n                    templating: this._templating,\n                    log: function(message, lvl) {\n                        self.log(message, lvl);\n                    },\n                    onDeleteFile: function(fileId) {\n                        self.deleteFile(fileId);\n                    },\n                    onCancel: function(fileId) {\n                        self.cancel(fileId);\n                    },\n                    onRetry: function(fileId) {\n                        self.retry(fileId);\n                    },\n                    onPause: function(fileId) {\n                        self.pauseUpload(fileId);\n                    },\n                    onContinue: function(fileId) {\n                        self.continueUpload(fileId);\n                    },\n                    onGetName: function(fileId) {\n                        return self.getName(fileId);\n                    }\n                });\n            },\n            _isEditFilenameEnabled: function() {\n                return this._templating.isEditFilenamePossible() && !this._options.autoUpload && qq.FilenameClickHandler && qq.FilenameInputFocusHandler && qq.FilenameInputFocusHandler;\n            },\n            _filenameEditHandler: function() {\n                var self = this, templating = this._templating;\n                return {\n                    templating: templating,\n                    log: function(message, lvl) {\n                        self.log(message, lvl);\n                    },\n                    onGetUploadStatus: function(fileId) {\n                        return self.getUploads({\n                            id: fileId\n                        }).status;\n                    },\n                    onGetName: function(fileId) {\n                        return self.getName(fileId);\n                    },\n                    onSetName: function(id, newName) {\n                        self.setName(id, newName);\n                    },\n                    onEditingStatusChange: function(id, isEditing) {\n                        var qqInput = qq(templating.getEditInput(id)), qqFileContainer = qq(templating.getFileContainer(id));\n                        if (isEditing) {\n                            qqInput.addClass(\"qq-editing\");\n                            templating.hideFilename(id);\n                            templating.hideEditIcon(id);\n                        } else {\n                            qqInput.removeClass(\"qq-editing\");\n                            templating.showFilename(id);\n                            templating.showEditIcon(id);\n                        }\n                        qqFileContainer.addClass(\"qq-temp\").removeClass(\"qq-temp\");\n                    }\n                };\n            },\n            _onUploadStatusChange: function(id, oldStatus, newStatus) {\n                this._parent.prototype._onUploadStatusChange.apply(this, arguments);\n                if (this._isEditFilenameEnabled()) {\n                    if (this._templating.getFileContainer(id) && newStatus !== qq.status.SUBMITTED) {\n                        this._templating.markFilenameEditable(id);\n                        this._templating.hideEditIcon(id);\n                    }\n                }\n                if (oldStatus === qq.status.UPLOAD_RETRYING && newStatus === qq.status.UPLOADING) {\n                    this._templating.hideRetry(id);\n                    this._templating.setStatusText(id);\n                    qq(this._templating.getFileContainer(id)).removeClass(this._classes.retrying);\n                } else if (newStatus === qq.status.UPLOAD_FAILED) {\n                    this._templating.hidePause(id);\n                }\n            },\n            _bindFilenameInputFocusInEvent: function() {\n                var spec = qq.extend({}, this._filenameEditHandler());\n                return new qq.FilenameInputFocusInHandler(spec);\n            },\n            _bindFilenameInputFocusEvent: function() {\n                var spec = qq.extend({}, this._filenameEditHandler());\n                return new qq.FilenameInputFocusHandler(spec);\n            },\n            _bindFilenameClickEvent: function() {\n                var spec = qq.extend({}, this._filenameEditHandler());\n                return new qq.FilenameClickHandler(spec);\n            },\n            _storeForLater: function(id) {\n                this._parent.prototype._storeForLater.apply(this, arguments);\n                this._templating.hideSpinner(id);\n            },\n            _onAllComplete: function(successful, failed) {\n                this._parent.prototype._onAllComplete.apply(this, arguments);\n                this._templating.resetTotalProgress();\n            },\n            _onSubmit: function(id, name) {\n                var file = this.getFile(id);\n                if (file && file.qqPath && this._options.dragAndDrop.reportDirectoryPaths) {\n                    this._paramsStore.addReadOnly(id, {\n                        qqpath: file.qqPath\n                    });\n                }\n                this._parent.prototype._onSubmit.apply(this, arguments);\n                this._addToList(id, name);\n            },\n            _onSubmitted: function(id) {\n                if (this._isEditFilenameEnabled()) {\n                    this._templating.markFilenameEditable(id);\n                    this._templating.showEditIcon(id);\n                    if (!this._focusinEventSupported) {\n                        this._filenameInputFocusHandler.addHandler(this._templating.getEditInput(id));\n                    }\n                }\n            },\n            _onProgress: function(id, name, loaded, total) {\n                this._parent.prototype._onProgress.apply(this, arguments);\n                this._templating.updateProgress(id, loaded, total);\n                if (Math.round(loaded / total * 100) === 100) {\n                    this._templating.hideCancel(id);\n                    this._templating.hidePause(id);\n                    this._templating.hideProgress(id);\n                    this._templating.setStatusText(id, this._options.text.waitingForResponse);\n                    this._displayFileSize(id);\n                } else {\n                    this._displayFileSize(id, loaded, total);\n                }\n            },\n            _onTotalProgress: function(loaded, total) {\n                this._parent.prototype._onTotalProgress.apply(this, arguments);\n                this._templating.updateTotalProgress(loaded, total);\n            },\n            _onComplete: function(id, name, result, xhr) {\n                var parentRetVal = this._parent.prototype._onComplete.apply(this, arguments), templating = this._templating, fileContainer = templating.getFileContainer(id), self = this;\n                function completeUpload(result) {\n                    if (!fileContainer) {\n                        return;\n                    }\n                    templating.setStatusText(id);\n                    qq(fileContainer).removeClass(self._classes.retrying);\n                    templating.hideProgress(id);\n                    if (self.getUploads({\n                        id: id\n                    }).status !== qq.status.UPLOAD_FAILED) {\n                        templating.hideCancel(id);\n                    }\n                    templating.hideSpinner(id);\n                    if (result.success) {\n                        self._markFileAsSuccessful(id);\n                    } else {\n                        qq(fileContainer).addClass(self._classes.fail);\n                        templating.showCancel(id);\n                        if (templating.isRetryPossible() && !self._preventRetries[id]) {\n                            qq(fileContainer).addClass(self._classes.retryable);\n                            templating.showRetry(id);\n                        }\n                        self._controlFailureTextDisplay(id, result);\n                    }\n                }\n                if (parentRetVal instanceof qq.Promise) {\n                    parentRetVal.done(function(newResult) {\n                        completeUpload(newResult);\n                    });\n                } else {\n                    completeUpload(result);\n                }\n                return parentRetVal;\n            },\n            _markFileAsSuccessful: function(id) {\n                var templating = this._templating;\n                if (this._isDeletePossible()) {\n                    templating.showDeleteButton(id);\n                }\n                qq(templating.getFileContainer(id)).addClass(this._classes.success);\n                this._maybeUpdateThumbnail(id);\n            },\n            _onUploadPrep: function(id) {\n                this._parent.prototype._onUploadPrep.apply(this, arguments);\n                this._templating.showSpinner(id);\n            },\n            _onUpload: function(id, name) {\n                var parentRetVal = this._parent.prototype._onUpload.apply(this, arguments);\n                this._templating.showSpinner(id);\n                return parentRetVal;\n            },\n            _onUploadChunk: function(id, chunkData) {\n                this._parent.prototype._onUploadChunk.apply(this, arguments);\n                if (chunkData.partIndex > 0 && this._handler.isResumable(id)) {\n                    this._templating.allowPause(id);\n                }\n            },\n            _onCancel: function(id, name) {\n                this._parent.prototype._onCancel.apply(this, arguments);\n                this._removeFileItem(id);\n                if (this._getNotFinished() === 0) {\n                    this._templating.resetTotalProgress();\n                }\n            },\n            _onBeforeAutoRetry: function(id) {\n                var retryNumForDisplay, maxAuto, retryNote;\n                this._parent.prototype._onBeforeAutoRetry.apply(this, arguments);\n                this._showCancelLink(id);\n                if (this._options.retry.showAutoRetryNote) {\n                    retryNumForDisplay = this._autoRetries[id];\n                    maxAuto = this._options.retry.maxAutoAttempts;\n                    retryNote = this._options.retry.autoRetryNote.replace(/\\{retryNum\\}/g, retryNumForDisplay);\n                    retryNote = retryNote.replace(/\\{maxAuto\\}/g, maxAuto);\n                    this._templating.setStatusText(id, retryNote);\n                    qq(this._templating.getFileContainer(id)).addClass(this._classes.retrying);\n                }\n            },\n            _onBeforeManualRetry: function(id) {\n                if (this._parent.prototype._onBeforeManualRetry.apply(this, arguments)) {\n                    this._templating.resetProgress(id);\n                    qq(this._templating.getFileContainer(id)).removeClass(this._classes.fail);\n                    this._templating.setStatusText(id);\n                    this._templating.showSpinner(id);\n                    this._showCancelLink(id);\n                    return true;\n                } else {\n                    qq(this._templating.getFileContainer(id)).addClass(this._classes.retryable);\n                    this._templating.showRetry(id);\n                    return false;\n                }\n            },\n            _onSubmitDelete: function(id) {\n                var onSuccessCallback = qq.bind(this._onSubmitDeleteSuccess, this);\n                this._parent.prototype._onSubmitDelete.call(this, id, onSuccessCallback);\n            },\n            _onSubmitDeleteSuccess: function(id, uuid, additionalMandatedParams) {\n                if (this._options.deleteFile.forceConfirm) {\n                    this._showDeleteConfirm.apply(this, arguments);\n                } else {\n                    this._sendDeleteRequest.apply(this, arguments);\n                }\n            },\n            _onDeleteComplete: function(id, xhr, isError) {\n                this._parent.prototype._onDeleteComplete.apply(this, arguments);\n                this._templating.hideSpinner(id);\n                if (isError) {\n                    this._templating.setStatusText(id, this._options.deleteFile.deletingFailedText);\n                    this._templating.showDeleteButton(id);\n                } else {\n                    this._removeFileItem(id);\n                }\n            },\n            _sendDeleteRequest: function(id, uuid, additionalMandatedParams) {\n                this._templating.hideDeleteButton(id);\n                this._templating.showSpinner(id);\n                this._templating.setStatusText(id, this._options.deleteFile.deletingStatusText);\n                this._deleteHandler.sendDelete.apply(this, arguments);\n            },\n            _showDeleteConfirm: function(id, uuid, mandatedParams) {\n                var fileName = this.getName(id), confirmMessage = this._options.deleteFile.confirmMessage.replace(/\\{filename\\}/g, fileName), uuid = this.getUuid(id), deleteRequestArgs = arguments, self = this, retVal;\n                retVal = this._options.showConfirm(confirmMessage);\n                if (qq.isGenericPromise(retVal)) {\n                    retVal.then(function() {\n                        self._sendDeleteRequest.apply(self, deleteRequestArgs);\n                    });\n                } else if (retVal !== false) {\n                    self._sendDeleteRequest.apply(self, deleteRequestArgs);\n                }\n            },\n            _addToList: function(id, name, canned) {\n                var prependData, prependIndex = 0, dontDisplay = this._handler.isProxied(id) && this._options.scaling.hideScaled, record;\n                if (this._options.display.prependFiles) {\n                    if (this._totalFilesInBatch > 1 && this._filesInBatchAddedToUi > 0) {\n                        prependIndex = this._filesInBatchAddedToUi - 1;\n                    }\n                    prependData = {\n                        index: prependIndex\n                    };\n                }\n                if (!canned) {\n                    if (this._options.disableCancelForFormUploads && !qq.supportedFeatures.ajaxUploading) {\n                        this._templating.disableCancel();\n                    }\n                    if (!this._options.multiple) {\n                        record = this.getUploads({\n                            id: id\n                        });\n                        this._handledProxyGroup = this._handledProxyGroup || record.proxyGroupId;\n                        if (record.proxyGroupId !== this._handledProxyGroup || !record.proxyGroupId) {\n                            this._handler.cancelAll();\n                            this._clearList();\n                            this._handledProxyGroup = null;\n                        }\n                    }\n                }\n                if (canned) {\n                    this._templating.addFileToCache(id, this._options.formatFileName(name), prependData, dontDisplay);\n                    this._templating.updateThumbnail(id, this._thumbnailUrls[id], true, this._options.thumbnails.customResizer);\n                } else {\n                    this._templating.addFile(id, this._options.formatFileName(name), prependData, dontDisplay);\n                    this._templating.generatePreview(id, this.getFile(id), this._options.thumbnails.customResizer);\n                }\n                this._filesInBatchAddedToUi += 1;\n                if (canned || this._options.display.fileSizeOnSubmit && qq.supportedFeatures.ajaxUploading) {\n                    this._displayFileSize(id);\n                }\n            },\n            _clearList: function() {\n                this._templating.clearFiles();\n                this.clearStoredFiles();\n            },\n            _displayFileSize: function(id, loadedSize, totalSize) {\n                var size = this.getSize(id), sizeForDisplay = this._formatSize(size);\n                if (size >= 0) {\n                    if (loadedSize !== undefined && totalSize !== undefined) {\n                        sizeForDisplay = this._formatProgress(loadedSize, totalSize);\n                    }\n                    this._templating.updateSize(id, sizeForDisplay);\n                }\n            },\n            _formatProgress: function(uploadedSize, totalSize) {\n                var message = this._options.text.formatProgress;\n                function r(name, replacement) {\n                    message = message.replace(name, replacement);\n                }\n                r(\"{percent}\", Math.round(uploadedSize / totalSize * 100));\n                r(\"{total_size}\", this._formatSize(totalSize));\n                return message;\n            },\n            _controlFailureTextDisplay: function(id, response) {\n                var mode, responseProperty, failureReason;\n                mode = this._options.failedUploadTextDisplay.mode;\n                responseProperty = this._options.failedUploadTextDisplay.responseProperty;\n                if (mode === \"custom\") {\n                    failureReason = response[responseProperty];\n                    if (!failureReason) {\n                        failureReason = this._options.text.failUpload;\n                    }\n                    this._templating.setStatusText(id, failureReason);\n                    if (this._options.failedUploadTextDisplay.enableTooltip) {\n                        this._showTooltip(id, failureReason);\n                    }\n                } else if (mode === \"default\") {\n                    this._templating.setStatusText(id, this._options.text.failUpload);\n                } else if (mode !== \"none\") {\n                    this.log(\"failedUploadTextDisplay.mode value of '\" + mode + \"' is not valid\", \"warn\");\n                }\n            },\n            _showTooltip: function(id, text) {\n                this._templating.getFileContainer(id).title = text;\n            },\n            _showCancelLink: function(id) {\n                if (!this._options.disableCancelForFormUploads || qq.supportedFeatures.ajaxUploading) {\n                    this._templating.showCancel(id);\n                }\n            },\n            _itemError: function(code, name, item) {\n                var message = this._parent.prototype._itemError.apply(this, arguments);\n                this._options.showMessage(message);\n            },\n            _batchError: function(message) {\n                this._parent.prototype._batchError.apply(this, arguments);\n                this._options.showMessage(message);\n            },\n            _setupPastePrompt: function() {\n                var self = this;\n                this._options.callbacks.onPasteReceived = function() {\n                    var message = self._options.paste.namePromptMessage, defaultVal = self._options.paste.defaultName;\n                    return self._options.showPrompt(message, defaultVal);\n                };\n            },\n            _fileOrBlobRejected: function(id, name) {\n                this._totalFilesInBatch -= 1;\n                this._parent.prototype._fileOrBlobRejected.apply(this, arguments);\n            },\n            _prepareItemsForUpload: function(items, params, endpoint) {\n                this._totalFilesInBatch = items.length;\n                this._filesInBatchAddedToUi = 0;\n                this._parent.prototype._prepareItemsForUpload.apply(this, arguments);\n            },\n            _maybeUpdateThumbnail: function(fileId) {\n                var thumbnailUrl = this._thumbnailUrls[fileId], fileStatus = this.getUploads({\n                    id: fileId\n                }).status;\n                if (fileStatus !== qq.status.DELETED && (thumbnailUrl || this._options.thumbnails.placeholders.waitUntilResponse || !qq.supportedFeatures.imagePreviews)) {\n                    this._templating.updateThumbnail(fileId, thumbnailUrl, this._options.thumbnails.customResizer);\n                }\n            },\n            _addCannedFile: function(sessionData) {\n                var id = this._parent.prototype._addCannedFile.apply(this, arguments);\n                this._addToList(id, this.getName(id), true);\n                this._templating.hideSpinner(id);\n                this._templating.hideCancel(id);\n                this._markFileAsSuccessful(id);\n                return id;\n            },\n            _setSize: function(id, newSize) {\n                this._parent.prototype._setSize.apply(this, arguments);\n                this._templating.updateSize(id, this._formatSize(newSize));\n            },\n            _sessionRequestComplete: function() {\n                this._templating.addCacheToDom();\n                this._parent.prototype._sessionRequestComplete.apply(this, arguments);\n            }\n        };\n    })();\n    qq.FineUploader = function(o, namespace) {\n        \"use strict\";\n        var self = this;\n        this._parent = namespace ? qq[namespace].FineUploaderBasic : qq.FineUploaderBasic;\n        this._parent.apply(this, arguments);\n        qq.extend(this._options, {\n            element: null,\n            button: null,\n            listElement: null,\n            dragAndDrop: {\n                extraDropzones: [],\n                reportDirectoryPaths: false\n            },\n            text: {\n                formatProgress: \"{percent}% of {total_size}\",\n                failUpload: \"Upload failed\",\n                waitingForResponse: \"Processing...\",\n                paused: \"Paused\"\n            },\n            template: \"qq-template\",\n            classes: {\n                retrying: \"qq-upload-retrying\",\n                retryable: \"qq-upload-retryable\",\n                success: \"qq-upload-success\",\n                fail: \"qq-upload-fail\",\n                editable: \"qq-editable\",\n                hide: \"qq-hide\",\n                dropActive: \"qq-upload-drop-area-active\"\n            },\n            failedUploadTextDisplay: {\n                mode: \"default\",\n                responseProperty: \"error\",\n                enableTooltip: true\n            },\n            messages: {\n                tooManyFilesError: \"You may only drop one file\",\n                unsupportedBrowser: \"Unrecoverable error - this browser does not permit file uploading of any kind.\"\n            },\n            retry: {\n                showAutoRetryNote: true,\n                autoRetryNote: \"Retrying {retryNum}/{maxAuto}...\"\n            },\n            deleteFile: {\n                forceConfirm: false,\n                confirmMessage: \"Are you sure you want to delete {filename}?\",\n                deletingStatusText: \"Deleting...\",\n                deletingFailedText: \"Delete failed\"\n            },\n            display: {\n                fileSizeOnSubmit: false,\n                prependFiles: false\n            },\n            paste: {\n                promptForName: false,\n                namePromptMessage: \"Please name this image\"\n            },\n            thumbnails: {\n                customResizer: null,\n                maxCount: 0,\n                placeholders: {\n                    waitUntilResponse: false,\n                    notAvailablePath: null,\n                    waitingPath: null\n                },\n                timeBetweenThumbs: 750\n            },\n            scaling: {\n                hideScaled: false\n            },\n            showMessage: function(message) {\n                if (self._templating.hasDialog(\"alert\")) {\n                    return self._templating.showDialog(\"alert\", message);\n                } else {\n                    setTimeout(function() {\n                        window.alert(message);\n                    }, 0);\n                }\n            },\n            showConfirm: function(message) {\n                if (self._templating.hasDialog(\"confirm\")) {\n                    return self._templating.showDialog(\"confirm\", message);\n                } else {\n                    return window.confirm(message);\n                }\n            },\n            showPrompt: function(message, defaultValue) {\n                if (self._templating.hasDialog(\"prompt\")) {\n                    return self._templating.showDialog(\"prompt\", message, defaultValue);\n                } else {\n                    return window.prompt(message, defaultValue);\n                }\n            }\n        }, true);\n        qq.extend(this._options, o, true);\n        this._templating = new qq.Templating({\n            log: qq.bind(this.log, this),\n            templateIdOrEl: this._options.template,\n            containerEl: this._options.element,\n            fileContainerEl: this._options.listElement,\n            button: this._options.button,\n            imageGenerator: this._imageGenerator,\n            classes: {\n                hide: this._options.classes.hide,\n                editable: this._options.classes.editable\n            },\n            limits: {\n                maxThumbs: this._options.thumbnails.maxCount,\n                timeBetweenThumbs: this._options.thumbnails.timeBetweenThumbs\n            },\n            placeholders: {\n                waitUntilUpdate: this._options.thumbnails.placeholders.waitUntilResponse,\n                thumbnailNotAvailable: this._options.thumbnails.placeholders.notAvailablePath,\n                waitingForThumbnail: this._options.thumbnails.placeholders.waitingPath\n            },\n            text: this._options.text\n        });\n        if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n            this._templating.renderFailure(this._options.messages.unsupportedBrowserIos8Safari);\n        } else if (!qq.supportedFeatures.uploading || this._options.cors.expected && !qq.supportedFeatures.uploadCors) {\n            this._templating.renderFailure(this._options.messages.unsupportedBrowser);\n        } else {\n            this._wrapCallbacks();\n            this._templating.render();\n            this._classes = this._options.classes;\n            if (!this._options.button && this._templating.getButton()) {\n                this._defaultButtonId = this._createUploadButton({\n                    element: this._templating.getButton(),\n                    title: this._options.text.fileInputTitle\n                }).getButtonId();\n            }\n            this._setupClickAndEditEventHandlers();\n            if (qq.DragAndDrop && qq.supportedFeatures.fileDrop) {\n                this._dnd = this._setupDragAndDrop();\n            }\n            if (this._options.paste.targetElement && this._options.paste.promptForName) {\n                if (qq.PasteSupport) {\n                    this._setupPastePrompt();\n                } else {\n                    this.log(\"Paste support module not found.\", \"error\");\n                }\n            }\n            this._totalFilesInBatch = 0;\n            this._filesInBatchAddedToUi = 0;\n        }\n    };\n    qq.extend(qq.FineUploader.prototype, qq.basePublicApi);\n    qq.extend(qq.FineUploader.prototype, qq.basePrivateApi);\n    qq.extend(qq.FineUploader.prototype, qq.uiPublicApi);\n    qq.extend(qq.FineUploader.prototype, qq.uiPrivateApi);\n    qq.Templating = function(spec) {\n        \"use strict\";\n        var FILE_ID_ATTR = \"qq-file-id\", FILE_CLASS_PREFIX = \"qq-file-id-\", THUMBNAIL_MAX_SIZE_ATTR = \"qq-max-size\", THUMBNAIL_SERVER_SCALE_ATTR = \"qq-server-scale\", HIDE_DROPZONE_ATTR = \"qq-hide-dropzone\", DROPZPONE_TEXT_ATTR = \"qq-drop-area-text\", IN_PROGRESS_CLASS = \"qq-in-progress\", HIDDEN_FOREVER_CLASS = \"qq-hidden-forever\", fileBatch = {\n            content: document.createDocumentFragment(),\n            map: {}\n        }, isCancelDisabled = false, generatedThumbnails = 0, thumbnailQueueMonitorRunning = false, thumbGenerationQueue = [], thumbnailMaxSize = -1, options = {\n            log: null,\n            limits: {\n                maxThumbs: 0,\n                timeBetweenThumbs: 750\n            },\n            templateIdOrEl: \"qq-template\",\n            containerEl: null,\n            fileContainerEl: null,\n            button: null,\n            imageGenerator: null,\n            classes: {\n                hide: \"qq-hide\",\n                editable: \"qq-editable\"\n            },\n            placeholders: {\n                waitUntilUpdate: false,\n                thumbnailNotAvailable: null,\n                waitingForThumbnail: null\n            },\n            text: {\n                paused: \"Paused\"\n            }\n        }, selectorClasses = {\n            button: \"qq-upload-button-selector\",\n            alertDialog: \"qq-alert-dialog-selector\",\n            dialogCancelButton: \"qq-cancel-button-selector\",\n            confirmDialog: \"qq-confirm-dialog-selector\",\n            dialogMessage: \"qq-dialog-message-selector\",\n            dialogOkButton: \"qq-ok-button-selector\",\n            promptDialog: \"qq-prompt-dialog-selector\",\n            uploader: \"qq-uploader-selector\",\n            drop: \"qq-upload-drop-area-selector\",\n            list: \"qq-upload-list-selector\",\n            progressBarContainer: \"qq-progress-bar-container-selector\",\n            progressBar: \"qq-progress-bar-selector\",\n            totalProgressBarContainer: \"qq-total-progress-bar-container-selector\",\n            totalProgressBar: \"qq-total-progress-bar-selector\",\n            file: \"qq-upload-file-selector\",\n            spinner: \"qq-upload-spinner-selector\",\n            size: \"qq-upload-size-selector\",\n            cancel: \"qq-upload-cancel-selector\",\n            pause: \"qq-upload-pause-selector\",\n            continueButton: \"qq-upload-continue-selector\",\n            deleteButton: \"qq-upload-delete-selector\",\n            retry: \"qq-upload-retry-selector\",\n            statusText: \"qq-upload-status-text-selector\",\n            editFilenameInput: \"qq-edit-filename-selector\",\n            editNameIcon: \"qq-edit-filename-icon-selector\",\n            dropText: \"qq-upload-drop-area-text-selector\",\n            dropProcessing: \"qq-drop-processing-selector\",\n            dropProcessingSpinner: \"qq-drop-processing-spinner-selector\",\n            thumbnail: \"qq-thumbnail-selector\"\n        }, previewGeneration = {}, cachedThumbnailNotAvailableImg = new qq.Promise(), cachedWaitingForThumbnailImg = new qq.Promise(), log, isEditElementsExist, isRetryElementExist, templateHtml, container, fileList, showThumbnails, serverScale, cacheThumbnailPlaceholders = function() {\n            var notAvailableUrl = options.placeholders.thumbnailNotAvailable, waitingUrl = options.placeholders.waitingForThumbnail, spec = {\n                maxSize: thumbnailMaxSize,\n                scale: serverScale\n            };\n            if (showThumbnails) {\n                if (notAvailableUrl) {\n                    options.imageGenerator.generate(notAvailableUrl, new Image(), spec).then(function(updatedImg) {\n                        cachedThumbnailNotAvailableImg.success(updatedImg);\n                    }, function() {\n                        cachedThumbnailNotAvailableImg.failure();\n                        log(\"Problem loading 'not available' placeholder image at \" + notAvailableUrl, \"error\");\n                    });\n                } else {\n                    cachedThumbnailNotAvailableImg.failure();\n                }\n                if (waitingUrl) {\n                    options.imageGenerator.generate(waitingUrl, new Image(), spec).then(function(updatedImg) {\n                        cachedWaitingForThumbnailImg.success(updatedImg);\n                    }, function() {\n                        cachedWaitingForThumbnailImg.failure();\n                        log(\"Problem loading 'waiting for thumbnail' placeholder image at \" + waitingUrl, \"error\");\n                    });\n                } else {\n                    cachedWaitingForThumbnailImg.failure();\n                }\n            }\n        }, displayWaitingImg = function(thumbnail) {\n            var waitingImgPlacement = new qq.Promise();\n            cachedWaitingForThumbnailImg.then(function(img) {\n                maybeScalePlaceholderViaCss(img, thumbnail);\n                if (!thumbnail.src) {\n                    thumbnail.src = img.src;\n                    thumbnail.onload = function() {\n                        thumbnail.onload = null;\n                        show(thumbnail);\n                        waitingImgPlacement.success();\n                    };\n                } else {\n                    waitingImgPlacement.success();\n                }\n            }, function() {\n                hide(thumbnail);\n                waitingImgPlacement.success();\n            });\n            return waitingImgPlacement;\n        }, generateNewPreview = function(id, blob, spec) {\n            var thumbnail = getThumbnail(id);\n            log(\"Generating new thumbnail for \" + id);\n            blob.qqThumbnailId = id;\n            return options.imageGenerator.generate(blob, thumbnail, spec).then(function() {\n                generatedThumbnails++;\n                show(thumbnail);\n                previewGeneration[id].success();\n            }, function() {\n                previewGeneration[id].failure();\n                if (!options.placeholders.waitUntilUpdate) {\n                    maybeSetDisplayNotAvailableImg(id, thumbnail);\n                }\n            });\n        }, generateNextQueuedPreview = function() {\n            if (thumbGenerationQueue.length) {\n                thumbnailQueueMonitorRunning = true;\n                var queuedThumbRequest = thumbGenerationQueue.shift();\n                if (queuedThumbRequest.update) {\n                    processUpdateQueuedPreviewRequest(queuedThumbRequest);\n                } else {\n                    processNewQueuedPreviewRequest(queuedThumbRequest);\n                }\n            } else {\n                thumbnailQueueMonitorRunning = false;\n            }\n        }, getCancel = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.cancel);\n        }, getContinue = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.continueButton);\n        }, getDialog = function(type) {\n            return getTemplateEl(container, selectorClasses[type + \"Dialog\"]);\n        }, getDelete = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.deleteButton);\n        }, getDropProcessing = function() {\n            return getTemplateEl(container, selectorClasses.dropProcessing);\n        }, getEditIcon = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.editNameIcon);\n        }, getFile = function(id) {\n            return fileBatch.map[id] || qq(fileList).getFirstByClass(FILE_CLASS_PREFIX + id);\n        }, getFilename = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.file);\n        }, getPause = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.pause);\n        }, getProgress = function(id) {\n            if (id == null) {\n                return getTemplateEl(container, selectorClasses.totalProgressBarContainer) || getTemplateEl(container, selectorClasses.totalProgressBar);\n            }\n            return getTemplateEl(getFile(id), selectorClasses.progressBarContainer) || getTemplateEl(getFile(id), selectorClasses.progressBar);\n        }, getRetry = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.retry);\n        }, getSize = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.size);\n        }, getSpinner = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.spinner);\n        }, getTemplateEl = function(context, cssClass) {\n            return context && qq(context).getFirstByClass(cssClass);\n        }, getThumbnail = function(id) {\n            return showThumbnails && getTemplateEl(getFile(id), selectorClasses.thumbnail);\n        }, hide = function(el) {\n            el && qq(el).addClass(options.classes.hide);\n        }, maybeScalePlaceholderViaCss = function(placeholder, thumbnail) {\n            var maxWidth = placeholder.style.maxWidth, maxHeight = placeholder.style.maxHeight;\n            if (maxHeight && maxWidth && !thumbnail.style.maxWidth && !thumbnail.style.maxHeight) {\n                qq(thumbnail).css({\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight\n                });\n            }\n        }, maybeSetDisplayNotAvailableImg = function(id, thumbnail) {\n            var previewing = previewGeneration[id] || new qq.Promise().failure(), notAvailableImgPlacement = new qq.Promise();\n            cachedThumbnailNotAvailableImg.then(function(img) {\n                previewing.then(function() {\n                    notAvailableImgPlacement.success();\n                }, function() {\n                    maybeScalePlaceholderViaCss(img, thumbnail);\n                    thumbnail.onload = function() {\n                        thumbnail.onload = null;\n                        notAvailableImgPlacement.success();\n                    };\n                    thumbnail.src = img.src;\n                    show(thumbnail);\n                });\n            });\n            return notAvailableImgPlacement;\n        }, parseAndGetTemplate = function() {\n            var scriptEl, scriptHtml, fileListNode, tempTemplateEl, fileListHtml, defaultButton, dropArea, thumbnail, dropProcessing, dropTextEl, uploaderEl;\n            log(\"Parsing template\");\n            if (options.templateIdOrEl == null) {\n                throw new Error(\"You MUST specify either a template element or ID!\");\n            }\n            if (qq.isString(options.templateIdOrEl)) {\n                scriptEl = document.getElementById(options.templateIdOrEl);\n                if (scriptEl === null) {\n                    throw new Error(qq.format(\"Cannot find template script at ID '{}'!\", options.templateIdOrEl));\n                }\n                scriptHtml = scriptEl.innerHTML;\n            } else {\n                if (options.templateIdOrEl.innerHTML === undefined) {\n                    throw new Error(\"You have specified an invalid value for the template option!  \" + \"It must be an ID or an Element.\");\n                }\n                scriptHtml = options.templateIdOrEl.innerHTML;\n            }\n            scriptHtml = qq.trimStr(scriptHtml);\n            tempTemplateEl = document.createElement(\"div\");\n            tempTemplateEl.appendChild(qq.toElement(scriptHtml));\n            uploaderEl = qq(tempTemplateEl).getFirstByClass(selectorClasses.uploader);\n            if (options.button) {\n                defaultButton = qq(tempTemplateEl).getFirstByClass(selectorClasses.button);\n                if (defaultButton) {\n                    qq(defaultButton).remove();\n                }\n            }\n            if (!qq.DragAndDrop || !qq.supportedFeatures.fileDrop) {\n                dropProcessing = qq(tempTemplateEl).getFirstByClass(selectorClasses.dropProcessing);\n                if (dropProcessing) {\n                    qq(dropProcessing).remove();\n                }\n            }\n            dropArea = qq(tempTemplateEl).getFirstByClass(selectorClasses.drop);\n            if (dropArea && !qq.DragAndDrop) {\n                log(\"DnD module unavailable.\", \"info\");\n                qq(dropArea).remove();\n            }\n            if (!qq.supportedFeatures.fileDrop) {\n                uploaderEl.removeAttribute(DROPZPONE_TEXT_ATTR);\n                if (dropArea && qq(dropArea).hasAttribute(HIDE_DROPZONE_ATTR)) {\n                    qq(dropArea).css({\n                        display: \"none\"\n                    });\n                }\n            } else if (qq(uploaderEl).hasAttribute(DROPZPONE_TEXT_ATTR) && dropArea) {\n                dropTextEl = qq(dropArea).getFirstByClass(selectorClasses.dropText);\n                dropTextEl && qq(dropTextEl).remove();\n            }\n            thumbnail = qq(tempTemplateEl).getFirstByClass(selectorClasses.thumbnail);\n            if (!showThumbnails) {\n                thumbnail && qq(thumbnail).remove();\n            } else if (thumbnail) {\n                thumbnailMaxSize = parseInt(thumbnail.getAttribute(THUMBNAIL_MAX_SIZE_ATTR));\n                thumbnailMaxSize = thumbnailMaxSize > 0 ? thumbnailMaxSize : null;\n                serverScale = qq(thumbnail).hasAttribute(THUMBNAIL_SERVER_SCALE_ATTR);\n            }\n            showThumbnails = showThumbnails && thumbnail;\n            isEditElementsExist = qq(tempTemplateEl).getByClass(selectorClasses.editFilenameInput).length > 0;\n            isRetryElementExist = qq(tempTemplateEl).getByClass(selectorClasses.retry).length > 0;\n            fileListNode = qq(tempTemplateEl).getFirstByClass(selectorClasses.list);\n            if (fileListNode == null) {\n                throw new Error(\"Could not find the file list container in the template!\");\n            }\n            fileListHtml = fileListNode.innerHTML;\n            fileListNode.innerHTML = \"\";\n            if (tempTemplateEl.getElementsByTagName(\"DIALOG\").length) {\n                document.createElement(\"dialog\");\n            }\n            log(\"Template parsing complete\");\n            return {\n                template: qq.trimStr(tempTemplateEl.innerHTML),\n                fileTemplate: qq.trimStr(fileListHtml)\n            };\n        }, prependFile = function(el, index, fileList) {\n            var parentEl = fileList, beforeEl = parentEl.firstChild;\n            if (index > 0) {\n                beforeEl = qq(parentEl).children()[index].nextSibling;\n            }\n            parentEl.insertBefore(el, beforeEl);\n        }, processNewQueuedPreviewRequest = function(queuedThumbRequest) {\n            var id = queuedThumbRequest.id, optFileOrBlob = queuedThumbRequest.optFileOrBlob, relatedThumbnailId = optFileOrBlob && optFileOrBlob.qqThumbnailId, thumbnail = getThumbnail(id), spec = {\n                customResizeFunction: queuedThumbRequest.customResizeFunction,\n                maxSize: thumbnailMaxSize,\n                orient: true,\n                scale: true\n            };\n            if (qq.supportedFeatures.imagePreviews) {\n                if (thumbnail) {\n                    if (options.limits.maxThumbs && options.limits.maxThumbs <= generatedThumbnails) {\n                        maybeSetDisplayNotAvailableImg(id, thumbnail);\n                        generateNextQueuedPreview();\n                    } else {\n                        displayWaitingImg(thumbnail).done(function() {\n                            previewGeneration[id] = new qq.Promise();\n                            previewGeneration[id].done(function() {\n                                setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n                            });\n                            if (relatedThumbnailId != null) {\n                                useCachedPreview(id, relatedThumbnailId);\n                            } else {\n                                generateNewPreview(id, optFileOrBlob, spec);\n                            }\n                        });\n                    }\n                } else {\n                    generateNextQueuedPreview();\n                }\n            } else if (thumbnail) {\n                displayWaitingImg(thumbnail);\n                generateNextQueuedPreview();\n            }\n        }, processUpdateQueuedPreviewRequest = function(queuedThumbRequest) {\n            var id = queuedThumbRequest.id, thumbnailUrl = queuedThumbRequest.thumbnailUrl, showWaitingImg = queuedThumbRequest.showWaitingImg, thumbnail = getThumbnail(id), spec = {\n                customResizeFunction: queuedThumbRequest.customResizeFunction,\n                scale: serverScale,\n                maxSize: thumbnailMaxSize\n            };\n            if (thumbnail) {\n                if (thumbnailUrl) {\n                    if (options.limits.maxThumbs && options.limits.maxThumbs <= generatedThumbnails) {\n                        maybeSetDisplayNotAvailableImg(id, thumbnail);\n                        generateNextQueuedPreview();\n                    } else {\n                        if (showWaitingImg) {\n                            displayWaitingImg(thumbnail);\n                        }\n                        return options.imageGenerator.generate(thumbnailUrl, thumbnail, spec).then(function() {\n                            show(thumbnail);\n                            generatedThumbnails++;\n                            setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n                        }, function() {\n                            maybeSetDisplayNotAvailableImg(id, thumbnail);\n                            setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n                        });\n                    }\n                } else {\n                    maybeSetDisplayNotAvailableImg(id, thumbnail);\n                    generateNextQueuedPreview();\n                }\n            }\n        }, setProgressBarWidth = function(id, percent) {\n            var bar = getProgress(id), progressBarSelector = id == null ? selectorClasses.totalProgressBar : selectorClasses.progressBar;\n            if (bar && !qq(bar).hasClass(progressBarSelector)) {\n                bar = qq(bar).getFirstByClass(progressBarSelector);\n            }\n            if (bar) {\n                qq(bar).css({\n                    width: percent + \"%\"\n                });\n                bar.setAttribute(\"aria-valuenow\", percent);\n            }\n        }, show = function(el) {\n            el && qq(el).removeClass(options.classes.hide);\n        }, useCachedPreview = function(targetThumbnailId, cachedThumbnailId) {\n            var targetThumbnail = getThumbnail(targetThumbnailId), cachedThumbnail = getThumbnail(cachedThumbnailId);\n            log(qq.format(\"ID {} is the same file as ID {}.  Will use generated thumbnail from ID {} instead.\", targetThumbnailId, cachedThumbnailId, cachedThumbnailId));\n            previewGeneration[cachedThumbnailId].then(function() {\n                generatedThumbnails++;\n                previewGeneration[targetThumbnailId].success();\n                log(qq.format(\"Now using previously generated thumbnail created for ID {} on ID {}.\", cachedThumbnailId, targetThumbnailId));\n                targetThumbnail.src = cachedThumbnail.src;\n                show(targetThumbnail);\n            }, function() {\n                previewGeneration[targetThumbnailId].failure();\n                if (!options.placeholders.waitUntilUpdate) {\n                    maybeSetDisplayNotAvailableImg(targetThumbnailId, targetThumbnail);\n                }\n            });\n        };\n        qq.extend(options, spec);\n        log = options.log;\n        if (!qq.supportedFeatures.imagePreviews) {\n            options.limits.timeBetweenThumbs = 0;\n            options.limits.maxThumbs = 0;\n        }\n        container = options.containerEl;\n        showThumbnails = options.imageGenerator !== undefined;\n        templateHtml = parseAndGetTemplate();\n        cacheThumbnailPlaceholders();\n        qq.extend(this, {\n            render: function() {\n                log(\"Rendering template in DOM.\");\n                generatedThumbnails = 0;\n                container.innerHTML = templateHtml.template;\n                hide(getDropProcessing());\n                this.hideTotalProgress();\n                fileList = options.fileContainerEl || getTemplateEl(container, selectorClasses.list);\n                log(\"Template rendering complete\");\n            },\n            renderFailure: function(message) {\n                var cantRenderEl = qq.toElement(message);\n                container.innerHTML = \"\";\n                container.appendChild(cantRenderEl);\n            },\n            reset: function() {\n                this.render();\n            },\n            clearFiles: function() {\n                fileList.innerHTML = \"\";\n            },\n            disableCancel: function() {\n                isCancelDisabled = true;\n            },\n            addFile: function(id, name, prependInfo, hideForever, batch) {\n                var fileEl = qq.toElement(templateHtml.fileTemplate), fileNameEl = getTemplateEl(fileEl, selectorClasses.file), uploaderEl = getTemplateEl(container, selectorClasses.uploader), fileContainer = batch ? fileBatch.content : fileList, thumb;\n                if (batch) {\n                    fileBatch.map[id] = fileEl;\n                }\n                qq(fileEl).addClass(FILE_CLASS_PREFIX + id);\n                uploaderEl.removeAttribute(DROPZPONE_TEXT_ATTR);\n                if (fileNameEl) {\n                    qq(fileNameEl).setText(name);\n                    fileNameEl.setAttribute(\"title\", name);\n                }\n                fileEl.setAttribute(FILE_ID_ATTR, id);\n                if (prependInfo) {\n                    prependFile(fileEl, prependInfo.index, fileContainer);\n                } else {\n                    fileContainer.appendChild(fileEl);\n                }\n                if (hideForever) {\n                    fileEl.style.display = \"none\";\n                    qq(fileEl).addClass(HIDDEN_FOREVER_CLASS);\n                } else {\n                    hide(getProgress(id));\n                    hide(getSize(id));\n                    hide(getDelete(id));\n                    hide(getRetry(id));\n                    hide(getPause(id));\n                    hide(getContinue(id));\n                    if (isCancelDisabled) {\n                        this.hideCancel(id);\n                    }\n                    thumb = getThumbnail(id);\n                    if (thumb && !thumb.src) {\n                        cachedWaitingForThumbnailImg.then(function(waitingImg) {\n                            thumb.src = waitingImg.src;\n                            if (waitingImg.style.maxHeight && waitingImg.style.maxWidth) {\n                                qq(thumb).css({\n                                    maxHeight: waitingImg.style.maxHeight,\n                                    maxWidth: waitingImg.style.maxWidth\n                                });\n                            }\n                            show(thumb);\n                        });\n                    }\n                }\n            },\n            addFileToCache: function(id, name, prependInfo, hideForever) {\n                this.addFile(id, name, prependInfo, hideForever, true);\n            },\n            addCacheToDom: function() {\n                fileList.appendChild(fileBatch.content);\n                fileBatch.content = document.createDocumentFragment();\n                fileBatch.map = {};\n            },\n            removeFile: function(id) {\n                qq(getFile(id)).remove();\n            },\n            getFileId: function(el) {\n                var currentNode = el;\n                if (currentNode) {\n                    while (currentNode.getAttribute(FILE_ID_ATTR) == null) {\n                        currentNode = currentNode.parentNode;\n                    }\n                    return parseInt(currentNode.getAttribute(FILE_ID_ATTR));\n                }\n            },\n            getFileList: function() {\n                return fileList;\n            },\n            markFilenameEditable: function(id) {\n                var filename = getFilename(id);\n                filename && qq(filename).addClass(options.classes.editable);\n            },\n            updateFilename: function(id, name) {\n                var filenameEl = getFilename(id);\n                if (filenameEl) {\n                    qq(filenameEl).setText(name);\n                    filenameEl.setAttribute(\"title\", name);\n                }\n            },\n            hideFilename: function(id) {\n                hide(getFilename(id));\n            },\n            showFilename: function(id) {\n                show(getFilename(id));\n            },\n            isFileName: function(el) {\n                return qq(el).hasClass(selectorClasses.file);\n            },\n            getButton: function() {\n                return options.button || getTemplateEl(container, selectorClasses.button);\n            },\n            hideDropProcessing: function() {\n                hide(getDropProcessing());\n            },\n            showDropProcessing: function() {\n                show(getDropProcessing());\n            },\n            getDropZone: function() {\n                return getTemplateEl(container, selectorClasses.drop);\n            },\n            isEditFilenamePossible: function() {\n                return isEditElementsExist;\n            },\n            hideRetry: function(id) {\n                hide(getRetry(id));\n            },\n            isRetryPossible: function() {\n                return isRetryElementExist;\n            },\n            showRetry: function(id) {\n                show(getRetry(id));\n            },\n            getFileContainer: function(id) {\n                return getFile(id);\n            },\n            showEditIcon: function(id) {\n                var icon = getEditIcon(id);\n                icon && qq(icon).addClass(options.classes.editable);\n            },\n            isHiddenForever: function(id) {\n                return qq(getFile(id)).hasClass(HIDDEN_FOREVER_CLASS);\n            },\n            hideEditIcon: function(id) {\n                var icon = getEditIcon(id);\n                icon && qq(icon).removeClass(options.classes.editable);\n            },\n            isEditIcon: function(el) {\n                return qq(el).hasClass(selectorClasses.editNameIcon, true);\n            },\n            getEditInput: function(id) {\n                return getTemplateEl(getFile(id), selectorClasses.editFilenameInput);\n            },\n            isEditInput: function(el) {\n                return qq(el).hasClass(selectorClasses.editFilenameInput, true);\n            },\n            updateProgress: function(id, loaded, total) {\n                var bar = getProgress(id), percent;\n                if (bar && total > 0) {\n                    percent = Math.round(loaded / total * 100);\n                    if (percent === 100) {\n                        hide(bar);\n                    } else {\n                        show(bar);\n                    }\n                    setProgressBarWidth(id, percent);\n                }\n            },\n            updateTotalProgress: function(loaded, total) {\n                this.updateProgress(null, loaded, total);\n            },\n            hideProgress: function(id) {\n                var bar = getProgress(id);\n                bar && hide(bar);\n            },\n            hideTotalProgress: function() {\n                this.hideProgress();\n            },\n            resetProgress: function(id) {\n                setProgressBarWidth(id, 0);\n                this.hideTotalProgress(id);\n            },\n            resetTotalProgress: function() {\n                this.resetProgress();\n            },\n            showCancel: function(id) {\n                if (!isCancelDisabled) {\n                    var cancel = getCancel(id);\n                    cancel && qq(cancel).removeClass(options.classes.hide);\n                }\n            },\n            hideCancel: function(id) {\n                hide(getCancel(id));\n            },\n            isCancel: function(el) {\n                return qq(el).hasClass(selectorClasses.cancel, true);\n            },\n            allowPause: function(id) {\n                show(getPause(id));\n                hide(getContinue(id));\n            },\n            uploadPaused: function(id) {\n                this.setStatusText(id, options.text.paused);\n                this.allowContinueButton(id);\n                hide(getSpinner(id));\n            },\n            hidePause: function(id) {\n                hide(getPause(id));\n            },\n            isPause: function(el) {\n                return qq(el).hasClass(selectorClasses.pause, true);\n            },\n            isContinueButton: function(el) {\n                return qq(el).hasClass(selectorClasses.continueButton, true);\n            },\n            allowContinueButton: function(id) {\n                show(getContinue(id));\n                hide(getPause(id));\n            },\n            uploadContinued: function(id) {\n                this.setStatusText(id, \"\");\n                this.allowPause(id);\n                show(getSpinner(id));\n            },\n            showDeleteButton: function(id) {\n                show(getDelete(id));\n            },\n            hideDeleteButton: function(id) {\n                hide(getDelete(id));\n            },\n            isDeleteButton: function(el) {\n                return qq(el).hasClass(selectorClasses.deleteButton, true);\n            },\n            isRetry: function(el) {\n                return qq(el).hasClass(selectorClasses.retry, true);\n            },\n            updateSize: function(id, text) {\n                var size = getSize(id);\n                if (size) {\n                    show(size);\n                    qq(size).setText(text);\n                }\n            },\n            setStatusText: function(id, text) {\n                var textEl = getTemplateEl(getFile(id), selectorClasses.statusText);\n                if (textEl) {\n                    if (text == null) {\n                        qq(textEl).clearText();\n                    } else {\n                        qq(textEl).setText(text);\n                    }\n                }\n            },\n            hideSpinner: function(id) {\n                qq(getFile(id)).removeClass(IN_PROGRESS_CLASS);\n                hide(getSpinner(id));\n            },\n            showSpinner: function(id) {\n                qq(getFile(id)).addClass(IN_PROGRESS_CLASS);\n                show(getSpinner(id));\n            },\n            generatePreview: function(id, optFileOrBlob, customResizeFunction) {\n                if (!this.isHiddenForever(id)) {\n                    thumbGenerationQueue.push({\n                        id: id,\n                        customResizeFunction: customResizeFunction,\n                        optFileOrBlob: optFileOrBlob\n                    });\n                    !thumbnailQueueMonitorRunning && generateNextQueuedPreview();\n                }\n            },\n            updateThumbnail: function(id, thumbnailUrl, showWaitingImg, customResizeFunction) {\n                if (!this.isHiddenForever(id)) {\n                    thumbGenerationQueue.push({\n                        customResizeFunction: customResizeFunction,\n                        update: true,\n                        id: id,\n                        thumbnailUrl: thumbnailUrl,\n                        showWaitingImg: showWaitingImg\n                    });\n                    !thumbnailQueueMonitorRunning && generateNextQueuedPreview();\n                }\n            },\n            hasDialog: function(type) {\n                return qq.supportedFeatures.dialogElement && !!getDialog(type);\n            },\n            showDialog: function(type, message, defaultValue) {\n                var dialog = getDialog(type), messageEl = getTemplateEl(dialog, selectorClasses.dialogMessage), inputEl = dialog.getElementsByTagName(\"INPUT\")[0], cancelBtn = getTemplateEl(dialog, selectorClasses.dialogCancelButton), okBtn = getTemplateEl(dialog, selectorClasses.dialogOkButton), promise = new qq.Promise(), closeHandler = function() {\n                    cancelBtn.removeEventListener(\"click\", cancelClickHandler);\n                    okBtn && okBtn.removeEventListener(\"click\", okClickHandler);\n                    promise.failure();\n                }, cancelClickHandler = function() {\n                    cancelBtn.removeEventListener(\"click\", cancelClickHandler);\n                    dialog.close();\n                }, okClickHandler = function() {\n                    dialog.removeEventListener(\"close\", closeHandler);\n                    okBtn.removeEventListener(\"click\", okClickHandler);\n                    dialog.close();\n                    promise.success(inputEl && inputEl.value);\n                };\n                dialog.addEventListener(\"close\", closeHandler);\n                cancelBtn.addEventListener(\"click\", cancelClickHandler);\n                okBtn && okBtn.addEventListener(\"click\", okClickHandler);\n                if (inputEl) {\n                    inputEl.value = defaultValue;\n                }\n                messageEl.textContent = message;\n                dialog.showModal();\n                return promise;\n            }\n        });\n    };\n    qq.UiEventHandler = function(s, protectedApi) {\n        \"use strict\";\n        var disposer = new qq.DisposeSupport(), spec = {\n            eventType: \"click\",\n            attachTo: null,\n            onHandled: function(target, event) {}\n        };\n        qq.extend(this, {\n            addHandler: function(element) {\n                addHandler(element);\n            },\n            dispose: function() {\n                disposer.dispose();\n            }\n        });\n        function addHandler(element) {\n            disposer.attach(element, spec.eventType, function(event) {\n                event = event || window.event;\n                var target = event.target || event.srcElement;\n                spec.onHandled(target, event);\n            });\n        }\n        qq.extend(protectedApi, {\n            getFileIdFromItem: function(item) {\n                return item.qqFileId;\n            },\n            getDisposeSupport: function() {\n                return disposer;\n            }\n        });\n        qq.extend(spec, s);\n        if (spec.attachTo) {\n            addHandler(spec.attachTo);\n        }\n    };\n    qq.FileButtonsClickHandler = function(s) {\n        \"use strict\";\n        var inheritedInternalApi = {}, spec = {\n            templating: null,\n            log: function(message, lvl) {},\n            onDeleteFile: function(fileId) {},\n            onCancel: function(fileId) {},\n            onRetry: function(fileId) {},\n            onPause: function(fileId) {},\n            onContinue: function(fileId) {},\n            onGetName: function(fileId) {}\n        }, buttonHandlers = {\n            cancel: function(id) {\n                spec.onCancel(id);\n            },\n            retry: function(id) {\n                spec.onRetry(id);\n            },\n            deleteButton: function(id) {\n                spec.onDeleteFile(id);\n            },\n            pause: function(id) {\n                spec.onPause(id);\n            },\n            continueButton: function(id) {\n                spec.onContinue(id);\n            }\n        };\n        function examineEvent(target, event) {\n            qq.each(buttonHandlers, function(buttonType, handler) {\n                var firstLetterCapButtonType = buttonType.charAt(0).toUpperCase() + buttonType.slice(1), fileId;\n                if (spec.templating[\"is\" + firstLetterCapButtonType](target)) {\n                    fileId = spec.templating.getFileId(target);\n                    qq.preventDefault(event);\n                    spec.log(qq.format(\"Detected valid file button click event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                    handler(fileId);\n                    return false;\n                }\n            });\n        }\n        qq.extend(spec, s);\n        spec.eventType = \"click\";\n        spec.onHandled = examineEvent;\n        spec.attachTo = spec.templating.getFileList();\n        qq.extend(this, new qq.UiEventHandler(spec, inheritedInternalApi));\n    };\n    qq.FilenameClickHandler = function(s) {\n        \"use strict\";\n        var inheritedInternalApi = {}, spec = {\n            templating: null,\n            log: function(message, lvl) {},\n            classes: {\n                file: \"qq-upload-file\",\n                editNameIcon: \"qq-edit-filename-icon\"\n            },\n            onGetUploadStatus: function(fileId) {},\n            onGetName: function(fileId) {}\n        };\n        qq.extend(spec, s);\n        function examineEvent(target, event) {\n            if (spec.templating.isFileName(target) || spec.templating.isEditIcon(target)) {\n                var fileId = spec.templating.getFileId(target), status = spec.onGetUploadStatus(fileId);\n                if (status === qq.status.SUBMITTED) {\n                    spec.log(qq.format(\"Detected valid filename click event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                    qq.preventDefault(event);\n                    inheritedInternalApi.handleFilenameEdit(fileId, target, true);\n                }\n            }\n        }\n        spec.eventType = \"click\";\n        spec.onHandled = examineEvent;\n        qq.extend(this, new qq.FilenameEditHandler(spec, inheritedInternalApi));\n    };\n    qq.FilenameInputFocusInHandler = function(s, inheritedInternalApi) {\n        \"use strict\";\n        var spec = {\n            templating: null,\n            onGetUploadStatus: function(fileId) {},\n            log: function(message, lvl) {}\n        };\n        if (!inheritedInternalApi) {\n            inheritedInternalApi = {};\n        }\n        function handleInputFocus(target, event) {\n            if (spec.templating.isEditInput(target)) {\n                var fileId = spec.templating.getFileId(target), status = spec.onGetUploadStatus(fileId);\n                if (status === qq.status.SUBMITTED) {\n                    spec.log(qq.format(\"Detected valid filename input focus event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                    inheritedInternalApi.handleFilenameEdit(fileId, target);\n                }\n            }\n        }\n        spec.eventType = \"focusin\";\n        spec.onHandled = handleInputFocus;\n        qq.extend(spec, s);\n        qq.extend(this, new qq.FilenameEditHandler(spec, inheritedInternalApi));\n    };\n    qq.FilenameInputFocusHandler = function(spec) {\n        \"use strict\";\n        spec.eventType = \"focus\";\n        spec.attachTo = null;\n        qq.extend(this, new qq.FilenameInputFocusInHandler(spec, {}));\n    };\n    qq.FilenameEditHandler = function(s, inheritedInternalApi) {\n        \"use strict\";\n        var spec = {\n            templating: null,\n            log: function(message, lvl) {},\n            onGetUploadStatus: function(fileId) {},\n            onGetName: function(fileId) {},\n            onSetName: function(fileId, newName) {},\n            onEditingStatusChange: function(fileId, isEditing) {}\n        };\n        function getFilenameSansExtension(fileId) {\n            var filenameSansExt = spec.onGetName(fileId), extIdx = filenameSansExt.lastIndexOf(\".\");\n            if (extIdx > 0) {\n                filenameSansExt = filenameSansExt.substr(0, extIdx);\n            }\n            return filenameSansExt;\n        }\n        function getOriginalExtension(fileId) {\n            var origName = spec.onGetName(fileId);\n            return qq.getExtension(origName);\n        }\n        function handleNameUpdate(newFilenameInputEl, fileId) {\n            var newName = newFilenameInputEl.value, origExtension;\n            if (newName !== undefined && qq.trimStr(newName).length > 0) {\n                origExtension = getOriginalExtension(fileId);\n                if (origExtension !== undefined) {\n                    newName = newName + \".\" + origExtension;\n                }\n                spec.onSetName(fileId, newName);\n            }\n            spec.onEditingStatusChange(fileId, false);\n        }\n        function registerInputBlurHandler(inputEl, fileId) {\n            inheritedInternalApi.getDisposeSupport().attach(inputEl, \"blur\", function() {\n                handleNameUpdate(inputEl, fileId);\n            });\n        }\n        function registerInputEnterKeyHandler(inputEl, fileId) {\n            inheritedInternalApi.getDisposeSupport().attach(inputEl, \"keyup\", function(event) {\n                var code = event.keyCode || event.which;\n                if (code === 13) {\n                    handleNameUpdate(inputEl, fileId);\n                }\n            });\n        }\n        qq.extend(spec, s);\n        spec.attachTo = spec.templating.getFileList();\n        qq.extend(this, new qq.UiEventHandler(spec, inheritedInternalApi));\n        qq.extend(inheritedInternalApi, {\n            handleFilenameEdit: function(id, target, focusInput) {\n                var newFilenameInputEl = spec.templating.getEditInput(id);\n                spec.onEditingStatusChange(id, true);\n                newFilenameInputEl.value = getFilenameSansExtension(id);\n                if (focusInput) {\n                    newFilenameInputEl.focus();\n                }\n                registerInputBlurHandler(newFilenameInputEl, id);\n                registerInputEnterKeyHandler(newFilenameInputEl, id);\n            }\n        });\n    };\n    qq.CryptoJS = function(Math, undefined) {\n        var C = {};\n        var C_lib = C.lib = {};\n        var Base = C_lib.Base = function() {\n            function F() {}\n            return {\n                extend: function(overrides) {\n                    F.prototype = this;\n                    var subtype = new F();\n                    if (overrides) {\n                        subtype.mixIn(overrides);\n                    }\n                    if (!subtype.hasOwnProperty(\"init\")) {\n                        subtype.init = function() {\n                            subtype.$super.init.apply(this, arguments);\n                        };\n                    }\n                    subtype.init.prototype = subtype;\n                    subtype.$super = this;\n                    return subtype;\n                },\n                create: function() {\n                    var instance = this.extend();\n                    instance.init.apply(instance, arguments);\n                    return instance;\n                },\n                init: function() {},\n                mixIn: function(properties) {\n                    for (var propertyName in properties) {\n                        if (properties.hasOwnProperty(propertyName)) {\n                            this[propertyName] = properties[propertyName];\n                        }\n                    }\n                    if (properties.hasOwnProperty(\"toString\")) {\n                        this.toString = properties.toString;\n                    }\n                },\n                clone: function() {\n                    return this.init.prototype.extend(this);\n                }\n            };\n        }();\n        var WordArray = C_lib.WordArray = Base.extend({\n            init: function(words, sigBytes) {\n                words = this.words = words || [];\n                if (sigBytes != undefined) {\n                    this.sigBytes = sigBytes;\n                } else {\n                    this.sigBytes = words.length * 4;\n                }\n            },\n            toString: function(encoder) {\n                return (encoder || Hex).stringify(this);\n            },\n            concat: function(wordArray) {\n                var thisWords = this.words;\n                var thatWords = wordArray.words;\n                var thisSigBytes = this.sigBytes;\n                var thatSigBytes = wordArray.sigBytes;\n                this.clamp();\n                if (thisSigBytes % 4) {\n                    for (var i = 0; i < thatSigBytes; i++) {\n                        var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n                        thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;\n                    }\n                } else if (thatWords.length > 65535) {\n                    for (var i = 0; i < thatSigBytes; i += 4) {\n                        thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];\n                    }\n                } else {\n                    thisWords.push.apply(thisWords, thatWords);\n                }\n                this.sigBytes += thatSigBytes;\n                return this;\n            },\n            clamp: function() {\n                var words = this.words;\n                var sigBytes = this.sigBytes;\n                words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;\n                words.length = Math.ceil(sigBytes / 4);\n            },\n            clone: function() {\n                var clone = Base.clone.call(this);\n                clone.words = this.words.slice(0);\n                return clone;\n            },\n            random: function(nBytes) {\n                var words = [];\n                for (var i = 0; i < nBytes; i += 4) {\n                    words.push(Math.random() * 4294967296 | 0);\n                }\n                return new WordArray.init(words, nBytes);\n            }\n        });\n        var C_enc = C.enc = {};\n        var Hex = C_enc.Hex = {\n            stringify: function(wordArray) {\n                var words = wordArray.words;\n                var sigBytes = wordArray.sigBytes;\n                var hexChars = [];\n                for (var i = 0; i < sigBytes; i++) {\n                    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n                    hexChars.push((bite >>> 4).toString(16));\n                    hexChars.push((bite & 15).toString(16));\n                }\n                return hexChars.join(\"\");\n            },\n            parse: function(hexStr) {\n                var hexStrLength = hexStr.length;\n                var words = [];\n                for (var i = 0; i < hexStrLength; i += 2) {\n                    words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;\n                }\n                return new WordArray.init(words, hexStrLength / 2);\n            }\n        };\n        var Latin1 = C_enc.Latin1 = {\n            stringify: function(wordArray) {\n                var words = wordArray.words;\n                var sigBytes = wordArray.sigBytes;\n                var latin1Chars = [];\n                for (var i = 0; i < sigBytes; i++) {\n                    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n                    latin1Chars.push(String.fromCharCode(bite));\n                }\n                return latin1Chars.join(\"\");\n            },\n            parse: function(latin1Str) {\n                var latin1StrLength = latin1Str.length;\n                var words = [];\n                for (var i = 0; i < latin1StrLength; i++) {\n                    words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;\n                }\n                return new WordArray.init(words, latin1StrLength);\n            }\n        };\n        var Utf8 = C_enc.Utf8 = {\n            stringify: function(wordArray) {\n                try {\n                    return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n                } catch (e) {\n                    throw new Error(\"Malformed UTF-8 data\");\n                }\n            },\n            parse: function(utf8Str) {\n                return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n            }\n        };\n        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n            reset: function() {\n                this._data = new WordArray.init();\n                this._nDataBytes = 0;\n            },\n            _append: function(data) {\n                if (typeof data == \"string\") {\n                    data = Utf8.parse(data);\n                }\n                this._data.concat(data);\n                this._nDataBytes += data.sigBytes;\n            },\n            _process: function(doFlush) {\n                var data = this._data;\n                var dataWords = data.words;\n                var dataSigBytes = data.sigBytes;\n                var blockSize = this.blockSize;\n                var blockSizeBytes = blockSize * 4;\n                var nBlocksReady = dataSigBytes / blockSizeBytes;\n                if (doFlush) {\n                    nBlocksReady = Math.ceil(nBlocksReady);\n                } else {\n                    nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n                }\n                var nWordsReady = nBlocksReady * blockSize;\n                var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n                if (nWordsReady) {\n                    for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n                        this._doProcessBlock(dataWords, offset);\n                    }\n                    var processedWords = dataWords.splice(0, nWordsReady);\n                    data.sigBytes -= nBytesReady;\n                }\n                return new WordArray.init(processedWords, nBytesReady);\n            },\n            clone: function() {\n                var clone = Base.clone.call(this);\n                clone._data = this._data.clone();\n                return clone;\n            },\n            _minBufferSize: 0\n        });\n        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n            cfg: Base.extend(),\n            init: function(cfg) {\n                this.cfg = this.cfg.extend(cfg);\n                this.reset();\n            },\n            reset: function() {\n                BufferedBlockAlgorithm.reset.call(this);\n                this._doReset();\n            },\n            update: function(messageUpdate) {\n                this._append(messageUpdate);\n                this._process();\n                return this;\n            },\n            finalize: function(messageUpdate) {\n                if (messageUpdate) {\n                    this._append(messageUpdate);\n                }\n                var hash = this._doFinalize();\n                return hash;\n            },\n            blockSize: 512 / 32,\n            _createHelper: function(hasher) {\n                return function(message, cfg) {\n                    return new hasher.init(cfg).finalize(message);\n                };\n            },\n            _createHmacHelper: function(hasher) {\n                return function(message, key) {\n                    return new C_algo.HMAC.init(hasher, key).finalize(message);\n                };\n            }\n        });\n        var C_algo = C.algo = {};\n        return C;\n    }(Math);\n    (function() {\n        var C = qq.CryptoJS;\n        var C_lib = C.lib;\n        var WordArray = C_lib.WordArray;\n        var C_enc = C.enc;\n        var Base64 = C_enc.Base64 = {\n            stringify: function(wordArray) {\n                var words = wordArray.words;\n                var sigBytes = wordArray.sigBytes;\n                var map = this._map;\n                wordArray.clamp();\n                var base64Chars = [];\n                for (var i = 0; i < sigBytes; i += 3) {\n                    var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n                    var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;\n                    var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;\n                    var triplet = byte1 << 16 | byte2 << 8 | byte3;\n                    for (var j = 0; j < 4 && i + j * .75 < sigBytes; j++) {\n                        base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));\n                    }\n                }\n                var paddingChar = map.charAt(64);\n                if (paddingChar) {\n                    while (base64Chars.length % 4) {\n                        base64Chars.push(paddingChar);\n                    }\n                }\n                return base64Chars.join(\"\");\n            },\n            parse: function(base64Str) {\n                var base64StrLength = base64Str.length;\n                var map = this._map;\n                var paddingChar = map.charAt(64);\n                if (paddingChar) {\n                    var paddingIndex = base64Str.indexOf(paddingChar);\n                    if (paddingIndex != -1) {\n                        base64StrLength = paddingIndex;\n                    }\n                }\n                var words = [];\n                var nBytes = 0;\n                for (var i = 0; i < base64StrLength; i++) {\n                    if (i % 4) {\n                        var bits1 = map.indexOf(base64Str.charAt(i - 1)) << i % 4 * 2;\n                        var bits2 = map.indexOf(base64Str.charAt(i)) >>> 6 - i % 4 * 2;\n                        words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;\n                        nBytes++;\n                    }\n                }\n                return WordArray.create(words, nBytes);\n            },\n            _map: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n        };\n    })();\n    (function() {\n        var C = qq.CryptoJS;\n        var C_lib = C.lib;\n        var Base = C_lib.Base;\n        var C_enc = C.enc;\n        var Utf8 = C_enc.Utf8;\n        var C_algo = C.algo;\n        var HMAC = C_algo.HMAC = Base.extend({\n            init: function(hasher, key) {\n                hasher = this._hasher = new hasher.init();\n                if (typeof key == \"string\") {\n                    key = Utf8.parse(key);\n                }\n                var hasherBlockSize = hasher.blockSize;\n                var hasherBlockSizeBytes = hasherBlockSize * 4;\n                if (key.sigBytes > hasherBlockSizeBytes) {\n                    key = hasher.finalize(key);\n                }\n                key.clamp();\n                var oKey = this._oKey = key.clone();\n                var iKey = this._iKey = key.clone();\n                var oKeyWords = oKey.words;\n                var iKeyWords = iKey.words;\n                for (var i = 0; i < hasherBlockSize; i++) {\n                    oKeyWords[i] ^= 1549556828;\n                    iKeyWords[i] ^= 909522486;\n                }\n                oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;\n                this.reset();\n            },\n            reset: function() {\n                var hasher = this._hasher;\n                hasher.reset();\n                hasher.update(this._iKey);\n            },\n            update: function(messageUpdate) {\n                this._hasher.update(messageUpdate);\n                return this;\n            },\n            finalize: function(messageUpdate) {\n                var hasher = this._hasher;\n                var innerHash = hasher.finalize(messageUpdate);\n                hasher.reset();\n                var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n                return hmac;\n            }\n        });\n    })();\n    (function() {\n        var C = qq.CryptoJS;\n        var C_lib = C.lib;\n        var WordArray = C_lib.WordArray;\n        var Hasher = C_lib.Hasher;\n        var C_algo = C.algo;\n        var W = [];\n        var SHA1 = C_algo.SHA1 = Hasher.extend({\n            _doReset: function() {\n                this._hash = new WordArray.init([ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ]);\n            },\n            _doProcessBlock: function(M, offset) {\n                var H = this._hash.words;\n                var a = H[0];\n                var b = H[1];\n                var c = H[2];\n                var d = H[3];\n                var e = H[4];\n                for (var i = 0; i < 80; i++) {\n                    if (i < 16) {\n                        W[i] = M[offset + i] | 0;\n                    } else {\n                        var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n                        W[i] = n << 1 | n >>> 31;\n                    }\n                    var t = (a << 5 | a >>> 27) + e + W[i];\n                    if (i < 20) {\n                        t += (b & c | ~b & d) + 1518500249;\n                    } else if (i < 40) {\n                        t += (b ^ c ^ d) + 1859775393;\n                    } else if (i < 60) {\n                        t += (b & c | b & d | c & d) - 1894007588;\n                    } else {\n                        t += (b ^ c ^ d) - 899497514;\n                    }\n                    e = d;\n                    d = c;\n                    c = b << 30 | b >>> 2;\n                    b = a;\n                    a = t;\n                }\n                H[0] = H[0] + a | 0;\n                H[1] = H[1] + b | 0;\n                H[2] = H[2] + c | 0;\n                H[3] = H[3] + d | 0;\n                H[4] = H[4] + e | 0;\n            },\n            _doFinalize: function() {\n                var data = this._data;\n                var dataWords = data.words;\n                var nBitsTotal = this._nDataBytes * 8;\n                var nBitsLeft = data.sigBytes * 8;\n                dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);\n                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n                data.sigBytes = dataWords.length * 4;\n                this._process();\n                return this._hash;\n            },\n            clone: function() {\n                var clone = Hasher.clone.call(this);\n                clone._hash = this._hash.clone();\n                return clone;\n            }\n        });\n        C.SHA1 = Hasher._createHelper(SHA1);\n        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);\n    })();\n    (function(Math) {\n        var C = qq.CryptoJS;\n        var C_lib = C.lib;\n        var WordArray = C_lib.WordArray;\n        var Hasher = C_lib.Hasher;\n        var C_algo = C.algo;\n        var H = [];\n        var K = [];\n        (function() {\n            function isPrime(n) {\n                var sqrtN = Math.sqrt(n);\n                for (var factor = 2; factor <= sqrtN; factor++) {\n                    if (!(n % factor)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            function getFractionalBits(n) {\n                return (n - (n | 0)) * 4294967296 | 0;\n            }\n            var n = 2;\n            var nPrime = 0;\n            while (nPrime < 64) {\n                if (isPrime(n)) {\n                    if (nPrime < 8) {\n                        H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n                    }\n                    K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n                    nPrime++;\n                }\n                n++;\n            }\n        })();\n        var W = [];\n        var SHA256 = C_algo.SHA256 = Hasher.extend({\n            _doReset: function() {\n                this._hash = new WordArray.init(H.slice(0));\n            },\n            _doProcessBlock: function(M, offset) {\n                var H = this._hash.words;\n                var a = H[0];\n                var b = H[1];\n                var c = H[2];\n                var d = H[3];\n                var e = H[4];\n                var f = H[5];\n                var g = H[6];\n                var h = H[7];\n                for (var i = 0; i < 64; i++) {\n                    if (i < 16) {\n                        W[i] = M[offset + i] | 0;\n                    } else {\n                        var gamma0x = W[i - 15];\n                        var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n                        var gamma1x = W[i - 2];\n                        var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n                        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n                    }\n                    var ch = e & f ^ ~e & g;\n                    var maj = a & b ^ a & c ^ b & c;\n                    var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n                    var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n                    var t1 = h + sigma1 + ch + K[i] + W[i];\n                    var t2 = sigma0 + maj;\n                    h = g;\n                    g = f;\n                    f = e;\n                    e = d + t1 | 0;\n                    d = c;\n                    c = b;\n                    b = a;\n                    a = t1 + t2 | 0;\n                }\n                H[0] = H[0] + a | 0;\n                H[1] = H[1] + b | 0;\n                H[2] = H[2] + c | 0;\n                H[3] = H[3] + d | 0;\n                H[4] = H[4] + e | 0;\n                H[5] = H[5] + f | 0;\n                H[6] = H[6] + g | 0;\n                H[7] = H[7] + h | 0;\n            },\n            _doFinalize: function() {\n                var data = this._data;\n                var dataWords = data.words;\n                var nBitsTotal = this._nDataBytes * 8;\n                var nBitsLeft = data.sigBytes * 8;\n                dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);\n                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n                data.sigBytes = dataWords.length * 4;\n                this._process();\n                return this._hash;\n            },\n            clone: function() {\n                var clone = Hasher.clone.call(this);\n                clone._hash = this._hash.clone();\n                return clone;\n            }\n        });\n        C.SHA256 = Hasher._createHelper(SHA256);\n        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n    })(Math);\n    (function() {\n        if (typeof ArrayBuffer != \"function\") {\n            return;\n        }\n        var C = qq.CryptoJS;\n        var C_lib = C.lib;\n        var WordArray = C_lib.WordArray;\n        var superInit = WordArray.init;\n        var subInit = WordArray.init = function(typedArray) {\n            if (typedArray instanceof ArrayBuffer) {\n                typedArray = new Uint8Array(typedArray);\n            }\n            if (typedArray instanceof Int8Array || typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {\n                typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n            }\n            if (typedArray instanceof Uint8Array) {\n                var typedArrayByteLength = typedArray.byteLength;\n                var words = [];\n                for (var i = 0; i < typedArrayByteLength; i++) {\n                    words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;\n                }\n                superInit.call(this, words, typedArrayByteLength);\n            } else {\n                superInit.apply(this, arguments);\n            }\n        };\n        subInit.prototype = WordArray;\n    })();\n    qq.s3 = qq.s3 || {};\n    qq.s3.util = qq.s3.util || function() {\n        \"use strict\";\n        return {\n            ALGORITHM_PARAM_NAME: \"x-amz-algorithm\",\n            AWS_PARAM_PREFIX: \"x-amz-meta-\",\n            CREDENTIAL_PARAM_NAME: \"x-amz-credential\",\n            DATE_PARAM_NAME: \"x-amz-date\",\n            REDUCED_REDUNDANCY_PARAM_NAME: \"x-amz-storage-class\",\n            REDUCED_REDUNDANCY_PARAM_VALUE: \"REDUCED_REDUNDANCY\",\n            SERVER_SIDE_ENCRYPTION_PARAM_NAME: \"x-amz-server-side-encryption\",\n            SERVER_SIDE_ENCRYPTION_PARAM_VALUE: \"AES256\",\n            SESSION_TOKEN_PARAM_NAME: \"x-amz-security-token\",\n            V4_ALGORITHM_PARAM_VALUE: \"AWS4-HMAC-SHA256\",\n            V4_SIGNATURE_PARAM_NAME: \"x-amz-signature\",\n            CASE_SENSITIVE_PARAM_NAMES: [ \"Cache-Control\", \"Content-Disposition\", \"Content-Encoding\", \"Content-MD5\" ],\n            UNSIGNABLE_REST_HEADER_NAMES: [ \"Cache-Control\", \"Content-Disposition\", \"Content-Encoding\", \"Content-MD5\" ],\n            UNPREFIXED_PARAM_NAMES: [ \"Cache-Control\", \"Content-Disposition\", \"Content-Encoding\", \"Content-MD5\", \"x-amz-server-side-encryption-customer-algorithm\", \"x-amz-server-side-encryption-customer-key\", \"x-amz-server-side-encryption-customer-key-MD5\" ],\n            getBucket: function(endpoint) {\n                var patterns = [ /^(?:https?:\\/\\/)?([a-z0-9.\\-_]+)\\.s3(?:-[a-z0-9\\-]+)?\\.amazonaws\\.com/i, /^(?:https?:\\/\\/)?s3(?:-[a-z0-9\\-]+)?\\.amazonaws\\.com\\/([a-z0-9.\\-_]+)/i, /^(?:https?:\\/\\/)?([a-z0-9.\\-_]+)/i ], bucket;\n                qq.each(patterns, function(idx, pattern) {\n                    var match = pattern.exec(endpoint);\n                    if (match) {\n                        bucket = match[1];\n                        return false;\n                    }\n                });\n                return bucket;\n            },\n            _getPrefixedParamName: function(name) {\n                if (qq.indexOf(qq.s3.util.UNPREFIXED_PARAM_NAMES, name) >= 0) {\n                    return name;\n                }\n                return qq.s3.util.AWS_PARAM_PREFIX + name;\n            },\n            getPolicy: function(spec) {\n                var policy = {}, conditions = [], bucket = spec.bucket, date = spec.date, drift = spec.clockDrift, key = spec.key, accessKey = spec.accessKey, acl = spec.acl, type = spec.type, expectedStatus = spec.expectedStatus, sessionToken = spec.sessionToken, params = spec.params, successRedirectUrl = qq.s3.util.getSuccessRedirectAbsoluteUrl(spec.successRedirectUrl), minFileSize = spec.minFileSize, maxFileSize = spec.maxFileSize, reducedRedundancy = spec.reducedRedundancy, region = spec.region, serverSideEncryption = spec.serverSideEncryption, signatureVersion = spec.signatureVersion;\n                policy.expiration = qq.s3.util.getPolicyExpirationDate(date, drift);\n                conditions.push({\n                    acl: acl\n                });\n                conditions.push({\n                    bucket: bucket\n                });\n                if (type) {\n                    conditions.push({\n                        \"Content-Type\": type\n                    });\n                }\n                if (expectedStatus) {\n                    conditions.push({\n                        success_action_status: expectedStatus.toString()\n                    });\n                }\n                if (successRedirectUrl) {\n                    conditions.push({\n                        success_action_redirect: successRedirectUrl\n                    });\n                }\n                if (reducedRedundancy) {\n                    conditions.push({});\n                    conditions[conditions.length - 1][qq.s3.util.REDUCED_REDUNDANCY_PARAM_NAME] = qq.s3.util.REDUCED_REDUNDANCY_PARAM_VALUE;\n                }\n                if (sessionToken) {\n                    conditions.push({});\n                    conditions[conditions.length - 1][qq.s3.util.SESSION_TOKEN_PARAM_NAME] = sessionToken;\n                }\n                if (serverSideEncryption) {\n                    conditions.push({});\n                    conditions[conditions.length - 1][qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_NAME] = qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_VALUE;\n                }\n                if (signatureVersion === 2) {\n                    conditions.push({\n                        key: key\n                    });\n                } else if (signatureVersion === 4) {\n                    conditions.push({});\n                    conditions[conditions.length - 1][qq.s3.util.ALGORITHM_PARAM_NAME] = qq.s3.util.V4_ALGORITHM_PARAM_VALUE;\n                    conditions.push({});\n                    conditions[conditions.length - 1].key = key;\n                    conditions.push({});\n                    conditions[conditions.length - 1][qq.s3.util.CREDENTIAL_PARAM_NAME] = qq.s3.util.getV4CredentialsString({\n                        date: date,\n                        key: accessKey,\n                        region: region\n                    });\n                    conditions.push({});\n                    conditions[conditions.length - 1][qq.s3.util.DATE_PARAM_NAME] = qq.s3.util.getV4PolicyDate(date, drift);\n                }\n                qq.each(params, function(name, val) {\n                    var awsParamName = qq.s3.util._getPrefixedParamName(name), param = {};\n                    if (qq.indexOf(qq.s3.util.UNPREFIXED_PARAM_NAMES, awsParamName) >= 0) {\n                        param[awsParamName] = val;\n                    } else {\n                        param[awsParamName] = encodeURIComponent(val);\n                    }\n                    conditions.push(param);\n                });\n                policy.conditions = conditions;\n                qq.s3.util.enforceSizeLimits(policy, minFileSize, maxFileSize);\n                return policy;\n            },\n            refreshPolicyCredentials: function(policy, newSessionToken) {\n                var sessionTokenFound = false;\n                qq.each(policy.conditions, function(oldCondIdx, oldCondObj) {\n                    qq.each(oldCondObj, function(oldCondName, oldCondVal) {\n                        if (oldCondName === qq.s3.util.SESSION_TOKEN_PARAM_NAME) {\n                            oldCondObj[oldCondName] = newSessionToken;\n                            sessionTokenFound = true;\n                        }\n                    });\n                });\n                if (!sessionTokenFound) {\n                    policy.conditions.push({});\n                    policy.conditions[policy.conditions.length - 1][qq.s3.util.SESSION_TOKEN_PARAM_NAME] = newSessionToken;\n                }\n            },\n            generateAwsParams: function(spec, signPolicyCallback) {\n                var awsParams = {}, customParams = spec.params, promise = new qq.Promise(), sessionToken = spec.sessionToken, drift = spec.clockDrift, type = spec.type, key = spec.key, accessKey = spec.accessKey, acl = spec.acl, expectedStatus = spec.expectedStatus, successRedirectUrl = qq.s3.util.getSuccessRedirectAbsoluteUrl(spec.successRedirectUrl), reducedRedundancy = spec.reducedRedundancy, region = spec.region, serverSideEncryption = spec.serverSideEncryption, signatureVersion = spec.signatureVersion, now = new Date(), log = spec.log, policyJson;\n                spec.date = now;\n                policyJson = qq.s3.util.getPolicy(spec);\n                awsParams.key = key;\n                if (type) {\n                    awsParams[\"Content-Type\"] = type;\n                }\n                if (expectedStatus) {\n                    awsParams.success_action_status = expectedStatus;\n                }\n                if (successRedirectUrl) {\n                    awsParams.success_action_redirect = successRedirectUrl;\n                }\n                if (reducedRedundancy) {\n                    awsParams[qq.s3.util.REDUCED_REDUNDANCY_PARAM_NAME] = qq.s3.util.REDUCED_REDUNDANCY_PARAM_VALUE;\n                }\n                if (serverSideEncryption) {\n                    awsParams[qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_NAME] = qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_VALUE;\n                }\n                if (sessionToken) {\n                    awsParams[qq.s3.util.SESSION_TOKEN_PARAM_NAME] = sessionToken;\n                }\n                awsParams.acl = acl;\n                qq.each(customParams, function(name, val) {\n                    var awsParamName = qq.s3.util._getPrefixedParamName(name);\n                    if (qq.indexOf(qq.s3.util.UNPREFIXED_PARAM_NAMES, awsParamName) >= 0) {\n                        awsParams[awsParamName] = val;\n                    } else {\n                        awsParams[awsParamName] = encodeURIComponent(val);\n                    }\n                });\n                if (signatureVersion === 2) {\n                    awsParams.AWSAccessKeyId = accessKey;\n                } else if (signatureVersion === 4) {\n                    awsParams[qq.s3.util.ALGORITHM_PARAM_NAME] = qq.s3.util.V4_ALGORITHM_PARAM_VALUE;\n                    awsParams[qq.s3.util.CREDENTIAL_PARAM_NAME] = qq.s3.util.getV4CredentialsString({\n                        date: now,\n                        key: accessKey,\n                        region: region\n                    });\n                    awsParams[qq.s3.util.DATE_PARAM_NAME] = qq.s3.util.getV4PolicyDate(now, drift);\n                }\n                signPolicyCallback(policyJson).then(function(policyAndSignature, updatedAccessKey, updatedSessionToken) {\n                    awsParams.policy = policyAndSignature.policy;\n                    if (spec.signatureVersion === 2) {\n                        awsParams.signature = policyAndSignature.signature;\n                        if (updatedAccessKey) {\n                            awsParams.AWSAccessKeyId = updatedAccessKey;\n                        }\n                    } else if (spec.signatureVersion === 4) {\n                        awsParams[qq.s3.util.V4_SIGNATURE_PARAM_NAME] = policyAndSignature.signature;\n                    }\n                    if (updatedSessionToken) {\n                        awsParams[qq.s3.util.SESSION_TOKEN_PARAM_NAME] = updatedSessionToken;\n                    }\n                    promise.success(awsParams);\n                }, function(errorMessage) {\n                    errorMessage = errorMessage || \"Can't continue further with request to S3 as we did not receive \" + \"a valid signature and policy from the server.\";\n                    log(\"Policy signing failed.  \" + errorMessage, \"error\");\n                    promise.failure(errorMessage);\n                });\n                return promise;\n            },\n            enforceSizeLimits: function(policy, minSize, maxSize) {\n                var adjustedMinSize = minSize < 0 ? 0 : minSize, adjustedMaxSize = maxSize <= 0 ? 9007199254740992 : maxSize;\n                if (minSize > 0 || maxSize > 0) {\n                    policy.conditions.push([ \"content-length-range\", adjustedMinSize.toString(), adjustedMaxSize.toString() ]);\n                }\n            },\n            getPolicyExpirationDate: function(date, drift) {\n                var adjustedDate = new Date(date.getTime() + drift);\n                return qq.s3.util.getPolicyDate(adjustedDate, 5);\n            },\n            getCredentialsDate: function(date) {\n                return date.getUTCFullYear() + \"\" + (\"0\" + (date.getUTCMonth() + 1)).slice(-2) + (\"0\" + date.getUTCDate()).slice(-2);\n            },\n            getPolicyDate: function(date, _minutesToAdd_) {\n                var minutesToAdd = _minutesToAdd_ || 0, pad, r;\n                date.setMinutes(date.getMinutes() + (minutesToAdd || 0));\n                if (Date.prototype.toISOString) {\n                    return date.toISOString();\n                } else {\n                    pad = function(number) {\n                        r = String(number);\n                        if (r.length === 1) {\n                            r = \"0\" + r;\n                        }\n                        return r;\n                    };\n                    return date.getUTCFullYear() + \"-\" + pad(date.getUTCMonth() + 1) + \"-\" + pad(date.getUTCDate()) + \"T\" + pad(date.getUTCHours()) + \":\" + pad(date.getUTCMinutes()) + \":\" + pad(date.getUTCSeconds()) + \".\" + String((date.getUTCMilliseconds() / 1e3).toFixed(3)).slice(2, 5) + \"Z\";\n                }\n            },\n            parseIframeResponse: function(iframe) {\n                var doc = iframe.contentDocument || iframe.contentWindow.document, queryString = doc.location.search, match = /bucket=(.+)&key=(.+)&etag=(.+)/.exec(queryString);\n                if (match) {\n                    return {\n                        bucket: match[1],\n                        key: match[2],\n                        etag: match[3].replace(/%22/g, \"\")\n                    };\n                }\n            },\n            getSuccessRedirectAbsoluteUrl: function(successRedirectUrl) {\n                if (successRedirectUrl) {\n                    var targetAnchorContainer = document.createElement(\"div\"), targetAnchor;\n                    if (qq.ie7()) {\n                        targetAnchorContainer.innerHTML = \"<a href='\" + successRedirectUrl + \"'></a>\";\n                        targetAnchor = targetAnchorContainer.firstChild;\n                        return targetAnchor.href;\n                    } else {\n                        targetAnchor = document.createElement(\"a\");\n                        targetAnchor.href = successRedirectUrl;\n                        targetAnchor.href = targetAnchor.href;\n                        return targetAnchor.href;\n                    }\n                }\n            },\n            getV4CredentialsString: function(spec) {\n                return spec.key + \"/\" + qq.s3.util.getCredentialsDate(spec.date) + \"/\" + spec.region + \"/s3/aws4_request\";\n            },\n            getV4PolicyDate: function(date, drift) {\n                var adjustedDate = new Date(date.getTime() + drift);\n                return qq.s3.util.getCredentialsDate(adjustedDate) + \"T\" + (\"0\" + adjustedDate.getUTCHours()).slice(-2) + (\"0\" + adjustedDate.getUTCMinutes()).slice(-2) + (\"0\" + adjustedDate.getUTCSeconds()).slice(-2) + \"Z\";\n            },\n            encodeQueryStringParam: function(param) {\n                var percentEncoded = encodeURIComponent(param);\n                percentEncoded = percentEncoded.replace(/[!'()]/g, escape);\n                percentEncoded = percentEncoded.replace(/\\*/g, \"%2A\");\n                return percentEncoded.replace(/%20/g, \"+\");\n            },\n            uriEscape: function(string) {\n                var output = encodeURIComponent(string);\n                output = output.replace(/[^A-Za-z0-9_.~\\-%]+/g, escape);\n                output = output.replace(/[*]/g, function(ch) {\n                    return \"%\" + ch.charCodeAt(0).toString(16).toUpperCase();\n                });\n                return output;\n            },\n            uriEscapePath: function(path) {\n                var parts = [];\n                qq.each(path.split(\"/\"), function(idx, item) {\n                    parts.push(qq.s3.util.uriEscape(item));\n                });\n                return parts.join(\"/\");\n            }\n        };\n    }();\n    (function() {\n        \"use strict\";\n        qq.nonTraditionalBasePublicApi = {\n            setUploadSuccessParams: function(params, id) {\n                this._uploadSuccessParamsStore.set(params, id);\n            },\n            setUploadSuccessEndpoint: function(endpoint, id) {\n                this._uploadSuccessEndpointStore.set(endpoint, id);\n            }\n        };\n        qq.nonTraditionalBasePrivateApi = {\n            _onComplete: function(id, name, result, xhr) {\n                var success = result.success ? true : false, self = this, onCompleteArgs = arguments, successEndpoint = this._uploadSuccessEndpointStore.get(id), successCustomHeaders = this._options.uploadSuccess.customHeaders, successMethod = this._options.uploadSuccess.method, cors = this._options.cors, promise = new qq.Promise(), uploadSuccessParams = this._uploadSuccessParamsStore.get(id), fileParams = this._paramsStore.get(id), onSuccessFromServer = function(successRequestResult) {\n                    delete self._failedSuccessRequestCallbacks[id];\n                    qq.extend(result, successRequestResult);\n                    qq.FineUploaderBasic.prototype._onComplete.apply(self, onCompleteArgs);\n                    promise.success(successRequestResult);\n                }, onFailureFromServer = function(successRequestResult) {\n                    var callback = submitSuccessRequest;\n                    qq.extend(result, successRequestResult);\n                    if (result && result.reset) {\n                        callback = null;\n                    }\n                    if (!callback) {\n                        delete self._failedSuccessRequestCallbacks[id];\n                    } else {\n                        self._failedSuccessRequestCallbacks[id] = callback;\n                    }\n                    if (!self._onAutoRetry(id, name, result, xhr, callback)) {\n                        qq.FineUploaderBasic.prototype._onComplete.apply(self, onCompleteArgs);\n                        promise.failure(successRequestResult);\n                    }\n                }, submitSuccessRequest, successAjaxRequester;\n                if (success && successEndpoint) {\n                    successAjaxRequester = new qq.UploadSuccessAjaxRequester({\n                        endpoint: successEndpoint,\n                        method: successMethod,\n                        customHeaders: successCustomHeaders,\n                        cors: cors,\n                        log: qq.bind(this.log, this)\n                    });\n                    qq.extend(uploadSuccessParams, self._getEndpointSpecificParams(id, result, xhr), true);\n                    fileParams && qq.extend(uploadSuccessParams, fileParams, true);\n                    submitSuccessRequest = qq.bind(function() {\n                        successAjaxRequester.sendSuccessRequest(id, uploadSuccessParams).then(onSuccessFromServer, onFailureFromServer);\n                    }, self);\n                    submitSuccessRequest();\n                    return promise;\n                }\n                return qq.FineUploaderBasic.prototype._onComplete.apply(this, arguments);\n            },\n            _manualRetry: function(id) {\n                var successRequestCallback = this._failedSuccessRequestCallbacks[id];\n                return qq.FineUploaderBasic.prototype._manualRetry.call(this, id, successRequestCallback);\n            }\n        };\n    })();\n    (function() {\n        \"use strict\";\n        qq.s3.FineUploaderBasic = function(o) {\n            var options = {\n                request: {\n                    accessKey: null,\n                    clockDrift: 0\n                },\n                objectProperties: {\n                    acl: \"private\",\n                    bucket: qq.bind(function(id) {\n                        return qq.s3.util.getBucket(this.getEndpoint(id));\n                    }, this),\n                    host: qq.bind(function(id) {\n                        return /(?:http|https):\\/\\/(.+)(?:\\/.+)?/.exec(this._endpointStore.get(id))[1];\n                    }, this),\n                    key: \"uuid\",\n                    reducedRedundancy: false,\n                    region: \"us-east-1\",\n                    serverSideEncryption: false\n                },\n                credentials: {\n                    accessKey: null,\n                    secretKey: null,\n                    expiration: null,\n                    sessionToken: null\n                },\n                signature: {\n                    customHeaders: {},\n                    endpoint: null,\n                    version: 2\n                },\n                uploadSuccess: {\n                    endpoint: null,\n                    method: \"POST\",\n                    params: {},\n                    customHeaders: {}\n                },\n                iframeSupport: {\n                    localBlankPagePath: null\n                },\n                chunking: {\n                    partSize: 5242880\n                },\n                cors: {\n                    allowXdr: true\n                },\n                callbacks: {\n                    onCredentialsExpired: function() {}\n                }\n            };\n            qq.extend(options, o, true);\n            if (!this.setCredentials(options.credentials, true)) {\n                this._currentCredentials.accessKey = options.request.accessKey;\n            }\n            this._aclStore = this._createStore(options.objectProperties.acl);\n            qq.FineUploaderBasic.call(this, options);\n            this._uploadSuccessParamsStore = this._createStore(this._options.uploadSuccess.params);\n            this._uploadSuccessEndpointStore = this._createStore(this._options.uploadSuccess.endpoint);\n            this._failedSuccessRequestCallbacks = {};\n            this._cannedKeys = {};\n            this._cannedBuckets = {};\n            this._buckets = {};\n            this._hosts = {};\n        };\n        qq.extend(qq.s3.FineUploaderBasic.prototype, qq.basePublicApi);\n        qq.extend(qq.s3.FineUploaderBasic.prototype, qq.basePrivateApi);\n        qq.extend(qq.s3.FineUploaderBasic.prototype, qq.nonTraditionalBasePublicApi);\n        qq.extend(qq.s3.FineUploaderBasic.prototype, qq.nonTraditionalBasePrivateApi);\n        qq.extend(qq.s3.FineUploaderBasic.prototype, {\n            getBucket: function(id) {\n                if (this._cannedBuckets[id] == null) {\n                    return this._buckets[id];\n                }\n                return this._cannedBuckets[id];\n            },\n            getKey: function(id) {\n                if (this._cannedKeys[id] == null) {\n                    return this._handler.getThirdPartyFileId(id);\n                }\n                return this._cannedKeys[id];\n            },\n            reset: function() {\n                qq.FineUploaderBasic.prototype.reset.call(this);\n                this._failedSuccessRequestCallbacks = [];\n                this._buckets = {};\n                this._hosts = {};\n            },\n            setCredentials: function(credentials, ignoreEmpty) {\n                if (credentials && credentials.secretKey) {\n                    if (!credentials.accessKey) {\n                        throw new qq.Error(\"Invalid credentials: no accessKey\");\n                    } else if (!credentials.expiration) {\n                        throw new qq.Error(\"Invalid credentials: no expiration\");\n                    } else {\n                        this._currentCredentials = qq.extend({}, credentials);\n                        if (qq.isString(credentials.expiration)) {\n                            this._currentCredentials.expiration = new Date(credentials.expiration);\n                        }\n                    }\n                    return true;\n                } else if (!ignoreEmpty) {\n                    throw new qq.Error(\"Invalid credentials parameter!\");\n                } else {\n                    this._currentCredentials = {};\n                }\n            },\n            setAcl: function(acl, id) {\n                this._aclStore.set(acl, id);\n            },\n            _createUploadHandler: function() {\n                var self = this, additionalOptions = {\n                    aclStore: this._aclStore,\n                    getBucket: qq.bind(this._determineBucket, this),\n                    getHost: qq.bind(this._determineHost, this),\n                    getKeyName: qq.bind(this._determineKeyName, this),\n                    iframeSupport: this._options.iframeSupport,\n                    objectProperties: this._options.objectProperties,\n                    signature: this._options.signature,\n                    clockDrift: this._options.request.clockDrift,\n                    validation: {\n                        minSizeLimit: this._options.validation.minSizeLimit,\n                        maxSizeLimit: this._options.validation.sizeLimit\n                    }\n                };\n                qq.override(this._endpointStore, function(super_) {\n                    return {\n                        get: function(id) {\n                            var endpoint = super_.get(id);\n                            if (endpoint.indexOf(\"http\") < 0) {\n                                return \"http://\" + endpoint;\n                            }\n                            return endpoint;\n                        }\n                    };\n                });\n                qq.override(this._paramsStore, function(super_) {\n                    return {\n                        get: function(id) {\n                            var oldParams = super_.get(id), modifiedParams = {};\n                            qq.each(oldParams, function(name, val) {\n                                var paramName = name;\n                                if (qq.indexOf(qq.s3.util.CASE_SENSITIVE_PARAM_NAMES, paramName) < 0) {\n                                    paramName = paramName.toLowerCase();\n                                }\n                                modifiedParams[paramName] = qq.isFunction(val) ? val() : val;\n                            });\n                            return modifiedParams;\n                        }\n                    };\n                });\n                additionalOptions.signature.credentialsProvider = {\n                    get: function() {\n                        return self._currentCredentials;\n                    },\n                    onExpired: function() {\n                        var updateCredentials = new qq.Promise(), callbackRetVal = self._options.callbacks.onCredentialsExpired();\n                        if (qq.isGenericPromise(callbackRetVal)) {\n                            callbackRetVal.then(function(credentials) {\n                                try {\n                                    self.setCredentials(credentials);\n                                    updateCredentials.success();\n                                } catch (error) {\n                                    self.log(\"Invalid credentials returned from onCredentialsExpired callback! (\" + error.message + \")\", \"error\");\n                                    updateCredentials.failure(\"onCredentialsExpired did not return valid credentials.\");\n                                }\n                            }, function(errorMsg) {\n                                self.log(\"onCredentialsExpired callback indicated failure! (\" + errorMsg + \")\", \"error\");\n                                updateCredentials.failure(\"onCredentialsExpired callback failed.\");\n                            });\n                        } else {\n                            self.log(\"onCredentialsExpired callback did not return a promise!\", \"error\");\n                            updateCredentials.failure(\"Unexpected return value for onCredentialsExpired.\");\n                        }\n                        return updateCredentials;\n                    }\n                };\n                return qq.FineUploaderBasic.prototype._createUploadHandler.call(this, additionalOptions, \"s3\");\n            },\n            _determineObjectPropertyValue: function(id, property) {\n                var maybe = this._options.objectProperties[property], promise = new qq.Promise(), self = this;\n                if (qq.isFunction(maybe)) {\n                    maybe = maybe(id);\n                    if (qq.isGenericPromise(maybe)) {\n                        promise = maybe;\n                    } else {\n                        promise.success(maybe);\n                    }\n                } else if (qq.isString(maybe)) {\n                    promise.success(maybe);\n                }\n                promise.then(function success(value) {\n                    self[\"_\" + property + \"s\"][id] = value;\n                }, function failure(errorMsg) {\n                    qq.log(\"Problem determining \" + property + \" for ID \" + id + \" (\" + errorMsg + \")\", \"error\");\n                });\n                return promise;\n            },\n            _determineBucket: function(id) {\n                return this._determineObjectPropertyValue(id, \"bucket\");\n            },\n            _determineHost: function(id) {\n                return this._determineObjectPropertyValue(id, \"host\");\n            },\n            _determineKeyName: function(id, filename) {\n                var promise = new qq.Promise(), keynameLogic = this._options.objectProperties.key, extension = qq.getExtension(filename), onGetKeynameFailure = promise.failure, onGetKeynameSuccess = function(keyname, extension) {\n                    var keynameToUse = keyname;\n                    if (extension !== undefined) {\n                        keynameToUse += \".\" + extension;\n                    }\n                    promise.success(keynameToUse);\n                };\n                switch (keynameLogic) {\n                  case \"uuid\":\n                    onGetKeynameSuccess(this.getUuid(id), extension);\n                    break;\n\n                  case \"filename\":\n                    onGetKeynameSuccess(filename);\n                    break;\n\n                  default:\n                    if (qq.isFunction(keynameLogic)) {\n                        this._handleKeynameFunction(keynameLogic, id, onGetKeynameSuccess, onGetKeynameFailure);\n                    } else {\n                        this.log(keynameLogic + \" is not a valid value for the s3.keyname option!\", \"error\");\n                        onGetKeynameFailure();\n                    }\n                }\n                return promise;\n            },\n            _handleKeynameFunction: function(keynameFunc, id, successCallback, failureCallback) {\n                var self = this, onSuccess = function(keyname) {\n                    successCallback(keyname);\n                }, onFailure = function(reason) {\n                    self.log(qq.format(\"Failed to retrieve key name for {}.  Reason: {}\", id, reason || \"null\"), \"error\");\n                    failureCallback(reason);\n                }, keyname = keynameFunc.call(this, id);\n                if (qq.isGenericPromise(keyname)) {\n                    keyname.then(onSuccess, onFailure);\n                } else if (keyname == null) {\n                    onFailure();\n                } else {\n                    onSuccess(keyname);\n                }\n            },\n            _getEndpointSpecificParams: function(id, response, maybeXhr) {\n                var params = {\n                    key: this.getKey(id),\n                    uuid: this.getUuid(id),\n                    name: this.getName(id),\n                    bucket: this.getBucket(id)\n                };\n                if (maybeXhr && maybeXhr.getResponseHeader(\"ETag\")) {\n                    params.etag = maybeXhr.getResponseHeader(\"ETag\");\n                } else if (response.etag) {\n                    params.etag = response.etag;\n                }\n                return params;\n            },\n            _onSubmitDelete: function(id, onSuccessCallback) {\n                var additionalMandatedParams = {\n                    key: this.getKey(id),\n                    bucket: this.getBucket(id)\n                };\n                return qq.FineUploaderBasic.prototype._onSubmitDelete.call(this, id, onSuccessCallback, additionalMandatedParams);\n            },\n            _addCannedFile: function(sessionData) {\n                var id;\n                if (sessionData.s3Key == null) {\n                    throw new qq.Error(\"Did not find s3Key property in server session response.  This is required!\");\n                } else {\n                    id = qq.FineUploaderBasic.prototype._addCannedFile.apply(this, arguments);\n                    this._cannedKeys[id] = sessionData.s3Key;\n                    this._cannedBuckets[id] = sessionData.s3Bucket;\n                }\n                return id;\n            }\n        });\n    })();\n    if (!window.Uint8ClampedArray) {\n        window.Uint8ClampedArray = function() {};\n    }\n    qq.s3.RequestSigner = function(o) {\n        \"use strict\";\n        var requester, thisSignatureRequester = this, pendingSignatures = {}, options = {\n            expectingPolicy: false,\n            method: \"POST\",\n            signatureSpec: {\n                drift: 0,\n                credentialsProvider: {},\n                endpoint: null,\n                customHeaders: {},\n                version: 2\n            },\n            maxConnections: 3,\n            endpointStore: {},\n            paramsStore: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {}\n        }, credentialsProvider, generateHeaders = function(signatureConstructor, signature, promise) {\n            var headers = signatureConstructor.getHeaders();\n            if (options.signatureSpec.version === 4) {\n                headers.Authorization = qq.s3.util.V4_ALGORITHM_PARAM_VALUE + \" Credential=\" + options.signatureSpec.credentialsProvider.get().accessKey + \"/\" + qq.s3.util.getCredentialsDate(signatureConstructor.getRequestDate()) + \"/\" + options.signatureSpec.region + \"/\" + \"s3/aws4_request,\" + \"SignedHeaders=\" + signatureConstructor.getSignedHeaders() + \",\" + \"Signature=\" + signature;\n            } else {\n                headers.Authorization = \"AWS \" + options.signatureSpec.credentialsProvider.get().accessKey + \":\" + signature;\n            }\n            promise.success(headers, signatureConstructor.getEndOfUrl());\n        }, v2 = {\n            getStringToSign: function(signatureSpec) {\n                return qq.format(\"{}\\n{}\\n{}\\n\\n{}/{}/{}\", signatureSpec.method, signatureSpec.contentMd5 || \"\", signatureSpec.contentType || \"\", signatureSpec.headersStr || \"\\n\", signatureSpec.bucket, signatureSpec.endOfUrl);\n            },\n            signApiRequest: function(signatureConstructor, headersStr, signatureEffort) {\n                var headersWordArray = qq.CryptoJS.enc.Utf8.parse(headersStr), headersHmacSha1 = qq.CryptoJS.HmacSHA1(headersWordArray, credentialsProvider.get().secretKey), headersHmacSha1Base64 = qq.CryptoJS.enc.Base64.stringify(headersHmacSha1);\n                generateHeaders(signatureConstructor, headersHmacSha1Base64, signatureEffort);\n            },\n            signPolicy: function(policy, signatureEffort, updatedAccessKey, updatedSessionToken) {\n                var policyStr = JSON.stringify(policy), policyWordArray = qq.CryptoJS.enc.Utf8.parse(policyStr), base64Policy = qq.CryptoJS.enc.Base64.stringify(policyWordArray), policyHmacSha1 = qq.CryptoJS.HmacSHA1(base64Policy, credentialsProvider.get().secretKey), policyHmacSha1Base64 = qq.CryptoJS.enc.Base64.stringify(policyHmacSha1);\n                signatureEffort.success({\n                    policy: base64Policy,\n                    signature: policyHmacSha1Base64\n                }, updatedAccessKey, updatedSessionToken);\n            }\n        }, v4 = {\n            getCanonicalQueryString: function(endOfUri) {\n                var queryParamIdx = endOfUri.indexOf(\"?\"), canonicalQueryString = \"\", encodedQueryParams, encodedQueryParamNames, queryStrings;\n                if (queryParamIdx >= 0) {\n                    encodedQueryParams = {};\n                    queryStrings = endOfUri.substr(queryParamIdx + 1).split(\"&\");\n                    qq.each(queryStrings, function(idx, queryString) {\n                        var nameAndVal = queryString.split(\"=\"), paramVal = nameAndVal[1];\n                        if (paramVal == null) {\n                            paramVal = \"\";\n                        }\n                        encodedQueryParams[encodeURIComponent(nameAndVal[0])] = encodeURIComponent(paramVal);\n                    });\n                    encodedQueryParamNames = Object.keys(encodedQueryParams).sort();\n                    encodedQueryParamNames.forEach(function(encodedQueryParamName, idx) {\n                        canonicalQueryString += encodedQueryParamName + \"=\" + encodedQueryParams[encodedQueryParamName];\n                        if (idx < encodedQueryParamNames.length - 1) {\n                            canonicalQueryString += \"&\";\n                        }\n                    });\n                }\n                return canonicalQueryString;\n            },\n            getCanonicalRequest: function(signatureSpec) {\n                return qq.format(\"{}\\n{}\\n{}\\n{}\\n{}\\n{}\", signatureSpec.method, v4.getCanonicalUri(signatureSpec.endOfUrl), v4.getCanonicalQueryString(signatureSpec.endOfUrl), signatureSpec.headersStr || \"\\n\", v4.getSignedHeaders(signatureSpec.headerNames), signatureSpec.hashedContent);\n            },\n            getCanonicalUri: function(endOfUri) {\n                var path = endOfUri, queryParamIdx = endOfUri.indexOf(\"?\");\n                if (queryParamIdx > 0) {\n                    path = endOfUri.substr(0, queryParamIdx);\n                }\n                return \"/\" + path;\n            },\n            getEncodedHashedPayload: function(body) {\n                var promise = new qq.Promise(), reader;\n                if (qq.isBlob(body)) {\n                    reader = new FileReader();\n                    reader.onloadend = function(e) {\n                        if (e.target.readyState === FileReader.DONE) {\n                            if (e.target.error) {\n                                promise.failure(e.target.error);\n                            } else {\n                                var wordArray = qq.CryptoJS.lib.WordArray.create(e.target.result);\n                                promise.success(qq.CryptoJS.SHA256(wordArray).toString());\n                            }\n                        }\n                    };\n                    reader.readAsArrayBuffer(body);\n                } else {\n                    body = body || \"\";\n                    promise.success(qq.CryptoJS.SHA256(body).toString());\n                }\n                return promise;\n            },\n            getScope: function(date, region) {\n                return qq.s3.util.getCredentialsDate(date) + \"/\" + region + \"/s3/aws4_request\";\n            },\n            getStringToSign: function(signatureSpec) {\n                var canonicalRequest = v4.getCanonicalRequest(signatureSpec), date = qq.s3.util.getV4PolicyDate(signatureSpec.date, signatureSpec.drift), hashedRequest = qq.CryptoJS.SHA256(canonicalRequest).toString(), scope = v4.getScope(signatureSpec.date, options.signatureSpec.region), stringToSignTemplate = \"AWS4-HMAC-SHA256\\n{}\\n{}\\n{}\";\n                return {\n                    hashed: qq.format(stringToSignTemplate, date, scope, hashedRequest),\n                    raw: qq.format(stringToSignTemplate, date, scope, canonicalRequest)\n                };\n            },\n            getSignedHeaders: function(headerNames) {\n                var signedHeaders = \"\";\n                headerNames.forEach(function(headerName, idx) {\n                    signedHeaders += headerName.toLowerCase();\n                    if (idx < headerNames.length - 1) {\n                        signedHeaders += \";\";\n                    }\n                });\n                return signedHeaders;\n            },\n            signApiRequest: function(signatureConstructor, headersStr, signatureEffort) {\n                var secretKey = credentialsProvider.get().secretKey, headersPattern = /.+\\n.+\\n(\\d+)\\/(.+)\\/s3\\/.+\\n(.+)/, matches = headersPattern.exec(headersStr), dateKey, dateRegionKey, dateRegionServiceKey, signingKey;\n                dateKey = qq.CryptoJS.HmacSHA256(matches[1], \"AWS4\" + secretKey);\n                dateRegionKey = qq.CryptoJS.HmacSHA256(matches[2], dateKey);\n                dateRegionServiceKey = qq.CryptoJS.HmacSHA256(\"s3\", dateRegionKey);\n                signingKey = qq.CryptoJS.HmacSHA256(\"aws4_request\", dateRegionServiceKey);\n                generateHeaders(signatureConstructor, qq.CryptoJS.HmacSHA256(headersStr, signingKey), signatureEffort);\n            },\n            signPolicy: function(policy, signatureEffort, updatedAccessKey, updatedSessionToken) {\n                var policyStr = JSON.stringify(policy), policyWordArray = qq.CryptoJS.enc.Utf8.parse(policyStr), base64Policy = qq.CryptoJS.enc.Base64.stringify(policyWordArray), secretKey = credentialsProvider.get().secretKey, credentialPattern = /.+\\/(.+)\\/(.+)\\/s3\\/aws4_request/, credentialCondition = function() {\n                    var credential = null;\n                    qq.each(policy.conditions, function(key, condition) {\n                        var val = condition[\"x-amz-credential\"];\n                        if (val) {\n                            credential = val;\n                            return false;\n                        }\n                    });\n                    return credential;\n                }(), matches, dateKey, dateRegionKey, dateRegionServiceKey, signingKey;\n                matches = credentialPattern.exec(credentialCondition);\n                dateKey = qq.CryptoJS.HmacSHA256(matches[1], \"AWS4\" + secretKey);\n                dateRegionKey = qq.CryptoJS.HmacSHA256(matches[2], dateKey);\n                dateRegionServiceKey = qq.CryptoJS.HmacSHA256(\"s3\", dateRegionKey);\n                signingKey = qq.CryptoJS.HmacSHA256(\"aws4_request\", dateRegionServiceKey);\n                signatureEffort.success({\n                    policy: base64Policy,\n                    signature: qq.CryptoJS.HmacSHA256(base64Policy, signingKey).toString()\n                }, updatedAccessKey, updatedSessionToken);\n            }\n        };\n        qq.extend(options, o, true);\n        credentialsProvider = options.signatureSpec.credentialsProvider;\n        function handleSignatureReceived(id, xhrOrXdr, isError) {\n            var responseJson = xhrOrXdr.responseText, pendingSignatureData = pendingSignatures[id], promise = pendingSignatureData.promise, signatureConstructor = pendingSignatureData.signatureConstructor, errorMessage, response;\n            delete pendingSignatures[id];\n            if (responseJson) {\n                try {\n                    response = qq.parseJson(responseJson);\n                } catch (error) {\n                    options.log(\"Error attempting to parse signature response: \" + error, \"error\");\n                }\n            }\n            if (response && response.invalid) {\n                isError = true;\n                errorMessage = \"Invalid policy document or request headers!\";\n            } else if (response) {\n                if (options.expectingPolicy && !response.policy) {\n                    isError = true;\n                    errorMessage = \"Response does not include the base64 encoded policy!\";\n                } else if (!response.signature) {\n                    isError = true;\n                    errorMessage = \"Response does not include the signature!\";\n                }\n            } else {\n                isError = true;\n                errorMessage = \"Received an empty or invalid response from the server!\";\n            }\n            if (isError) {\n                if (errorMessage) {\n                    options.log(errorMessage, \"error\");\n                }\n                promise.failure(errorMessage);\n            } else if (signatureConstructor) {\n                generateHeaders(signatureConstructor, response.signature, promise);\n            } else {\n                promise.success(response);\n            }\n        }\n        function getStringToSignArtifacts(id, version, requestInfo) {\n            var promise = new qq.Promise(), method = \"POST\", headerNames = [], headersStr = \"\", now = new Date(), endOfUrl, signatureSpec, toSign, generateStringToSign = function(requestInfo) {\n                var contentMd5, headerIndexesToRemove = [];\n                qq.each(requestInfo.headers, function(name) {\n                    headerNames.push(name);\n                });\n                headerNames.sort();\n                qq.each(headerNames, function(idx, headerName) {\n                    if (qq.indexOf(qq.s3.util.UNSIGNABLE_REST_HEADER_NAMES, headerName) < 0) {\n                        headersStr += headerName.toLowerCase() + \":\" + requestInfo.headers[headerName].trim() + \"\\n\";\n                    } else if (headerName === \"Content-MD5\") {\n                        contentMd5 = requestInfo.headers[headerName];\n                    } else {\n                        headerIndexesToRemove.unshift(idx);\n                    }\n                });\n                qq.each(headerIndexesToRemove, function(idx, headerIdx) {\n                    headerNames.splice(headerIdx, 1);\n                });\n                signatureSpec = {\n                    bucket: requestInfo.bucket,\n                    contentMd5: contentMd5,\n                    contentType: requestInfo.contentType,\n                    date: now,\n                    drift: options.signatureSpec.drift,\n                    endOfUrl: endOfUrl,\n                    hashedContent: requestInfo.hashedContent,\n                    headerNames: headerNames,\n                    headersStr: headersStr,\n                    method: method\n                };\n                toSign = version === 2 ? v2.getStringToSign(signatureSpec) : v4.getStringToSign(signatureSpec);\n                return {\n                    date: now,\n                    endOfUrl: endOfUrl,\n                    signedHeaders: version === 4 ? v4.getSignedHeaders(signatureSpec.headerNames) : null,\n                    toSign: version === 4 ? toSign.hashed : toSign,\n                    toSignRaw: version === 4 ? toSign.raw : toSign\n                };\n            };\n            switch (requestInfo.type) {\n              case thisSignatureRequester.REQUEST_TYPE.MULTIPART_ABORT:\n                method = \"DELETE\";\n                endOfUrl = qq.format(\"uploadId={}\", requestInfo.uploadId);\n                break;\n\n              case thisSignatureRequester.REQUEST_TYPE.MULTIPART_INITIATE:\n                endOfUrl = \"uploads\";\n                break;\n\n              case thisSignatureRequester.REQUEST_TYPE.MULTIPART_COMPLETE:\n                endOfUrl = qq.format(\"uploadId={}\", requestInfo.uploadId);\n                break;\n\n              case thisSignatureRequester.REQUEST_TYPE.MULTIPART_UPLOAD:\n                method = \"PUT\";\n                endOfUrl = qq.format(\"partNumber={}&uploadId={}\", requestInfo.partNum, requestInfo.uploadId);\n                break;\n            }\n            endOfUrl = requestInfo.key + \"?\" + endOfUrl;\n            if (version === 4) {\n                v4.getEncodedHashedPayload(requestInfo.content).then(function(hashedContent) {\n                    requestInfo.headers[\"x-amz-content-sha256\"] = hashedContent;\n                    requestInfo.headers.Host = requestInfo.host;\n                    requestInfo.headers[\"x-amz-date\"] = qq.s3.util.getV4PolicyDate(now, options.signatureSpec.drift);\n                    requestInfo.hashedContent = hashedContent;\n                    promise.success(generateStringToSign(requestInfo));\n                }, function(err) {\n                    promise.failure(err);\n                });\n            } else {\n                promise.success(generateStringToSign(requestInfo));\n            }\n            return promise;\n        }\n        function determineSignatureClientSide(id, toBeSigned, signatureEffort, updatedAccessKey, updatedSessionToken) {\n            var updatedHeaders;\n            if (toBeSigned.signatureConstructor) {\n                if (updatedSessionToken) {\n                    updatedHeaders = toBeSigned.signatureConstructor.getHeaders();\n                    updatedHeaders[qq.s3.util.SESSION_TOKEN_PARAM_NAME] = updatedSessionToken;\n                    toBeSigned.signatureConstructor.withHeaders(updatedHeaders);\n                }\n                toBeSigned.signatureConstructor.getToSign(id).then(function(signatureArtifacts) {\n                    signApiRequest(toBeSigned.signatureConstructor, signatureArtifacts.stringToSign, signatureEffort);\n                }, function(err) {\n                    signatureEffort.failure(err);\n                });\n            } else {\n                updatedSessionToken && qq.s3.util.refreshPolicyCredentials(toBeSigned, updatedSessionToken);\n                signPolicy(toBeSigned, signatureEffort, updatedAccessKey, updatedSessionToken);\n            }\n        }\n        function signPolicy(policy, signatureEffort, updatedAccessKey, updatedSessionToken) {\n            if (options.signatureSpec.version === 4) {\n                v4.signPolicy(policy, signatureEffort, updatedAccessKey, updatedSessionToken);\n            } else {\n                v2.signPolicy(policy, signatureEffort, updatedAccessKey, updatedSessionToken);\n            }\n        }\n        function signApiRequest(signatureConstructor, headersStr, signatureEffort) {\n            if (options.signatureSpec.version === 4) {\n                v4.signApiRequest(signatureConstructor, headersStr, signatureEffort);\n            } else {\n                v2.signApiRequest(signatureConstructor, headersStr, signatureEffort);\n            }\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            method: options.method,\n            contentType: \"application/json; charset=utf-8\",\n            endpointStore: {\n                get: function() {\n                    return options.signatureSpec.endpoint;\n                }\n            },\n            paramsStore: options.paramsStore,\n            maxConnections: options.maxConnections,\n            customHeaders: options.signatureSpec.customHeaders,\n            log: options.log,\n            onComplete: handleSignatureReceived,\n            cors: options.cors\n        }));\n        qq.extend(this, {\n            getSignature: function(id, toBeSigned) {\n                var params = toBeSigned, signatureConstructor = toBeSigned.signatureConstructor, signatureEffort = new qq.Promise(), queryParams;\n                if (options.signatureSpec.version === 4) {\n                    queryParams = {\n                        v4: true\n                    };\n                }\n                if (credentialsProvider.get().secretKey && qq.CryptoJS) {\n                    if (credentialsProvider.get().expiration.getTime() > Date.now()) {\n                        determineSignatureClientSide(id, toBeSigned, signatureEffort);\n                    } else {\n                        credentialsProvider.onExpired().then(function() {\n                            determineSignatureClientSide(id, toBeSigned, signatureEffort, credentialsProvider.get().accessKey, credentialsProvider.get().sessionToken);\n                        }, function(errorMsg) {\n                            options.log(\"Attempt to update expired credentials apparently failed! Unable to sign request.  \", \"error\");\n                            signatureEffort.failure(\"Unable to sign request - expired credentials.\");\n                        });\n                    }\n                } else {\n                    options.log(\"Submitting S3 signature request for \" + id);\n                    if (signatureConstructor) {\n                        signatureConstructor.getToSign(id).then(function(signatureArtifacts) {\n                            params = {\n                                headers: signatureArtifacts.stringToSignRaw\n                            };\n                            requester.initTransport(id).withParams(params).withQueryParams(queryParams).send();\n                        }, function(err) {\n                            options.log(\"Failed to construct signature. \", \"error\");\n                            signatureEffort.failure(\"Failed to construct signature.\");\n                        });\n                    } else {\n                        requester.initTransport(id).withParams(params).withQueryParams(queryParams).send();\n                    }\n                    pendingSignatures[id] = {\n                        promise: signatureEffort,\n                        signatureConstructor: signatureConstructor\n                    };\n                }\n                return signatureEffort;\n            },\n            constructStringToSign: function(type, bucket, host, key) {\n                var headers = {}, uploadId, content, contentType, partNum, artifacts;\n                return {\n                    withHeaders: function(theHeaders) {\n                        headers = theHeaders;\n                        return this;\n                    },\n                    withUploadId: function(theUploadId) {\n                        uploadId = theUploadId;\n                        return this;\n                    },\n                    withContent: function(theContent) {\n                        content = theContent;\n                        return this;\n                    },\n                    withContentType: function(theContentType) {\n                        contentType = theContentType;\n                        return this;\n                    },\n                    withPartNum: function(thePartNum) {\n                        partNum = thePartNum;\n                        return this;\n                    },\n                    getToSign: function(id) {\n                        var sessionToken = credentialsProvider.get().sessionToken, promise = new qq.Promise(), adjustedDate = new Date(Date.now() + options.signatureSpec.drift);\n                        headers[\"x-amz-date\"] = adjustedDate.toUTCString();\n                        if (sessionToken) {\n                            headers[qq.s3.util.SESSION_TOKEN_PARAM_NAME] = sessionToken;\n                        }\n                        getStringToSignArtifacts(id, options.signatureSpec.version, {\n                            bucket: bucket,\n                            content: content,\n                            contentType: contentType,\n                            headers: headers,\n                            host: host,\n                            key: key,\n                            partNum: partNum,\n                            type: type,\n                            uploadId: uploadId\n                        }).then(function(_artifacts_) {\n                            artifacts = _artifacts_;\n                            promise.success({\n                                headers: function() {\n                                    if (contentType) {\n                                        headers[\"Content-Type\"] = contentType;\n                                    }\n                                    delete headers.Host;\n                                    return headers;\n                                }(),\n                                date: artifacts.date,\n                                endOfUrl: artifacts.endOfUrl,\n                                signedHeaders: artifacts.signedHeaders,\n                                stringToSign: artifacts.toSign,\n                                stringToSignRaw: artifacts.toSignRaw\n                            });\n                        }, function(err) {\n                            promise.failure(err);\n                        });\n                        return promise;\n                    },\n                    getHeaders: function() {\n                        return qq.extend({}, headers);\n                    },\n                    getEndOfUrl: function() {\n                        return artifacts && artifacts.endOfUrl;\n                    },\n                    getRequestDate: function() {\n                        return artifacts && artifacts.date;\n                    },\n                    getSignedHeaders: function() {\n                        return artifacts && artifacts.signedHeaders;\n                    }\n                };\n            }\n        });\n    };\n    qq.s3.RequestSigner.prototype.REQUEST_TYPE = {\n        MULTIPART_INITIATE: \"multipart_initiate\",\n        MULTIPART_COMPLETE: \"multipart_complete\",\n        MULTIPART_ABORT: \"multipart_abort\",\n        MULTIPART_UPLOAD: \"multipart_upload\"\n    };\n    qq.UploadSuccessAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, pendingRequests = [], options = {\n            method: \"POST\",\n            endpoint: null,\n            maxConnections: 3,\n            customHeaders: {},\n            paramsStore: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {}\n        };\n        qq.extend(options, o);\n        function handleSuccessResponse(id, xhrOrXdr, isError) {\n            var promise = pendingRequests[id], responseJson = xhrOrXdr.responseText, successIndicator = {\n                success: true\n            }, failureIndicator = {\n                success: false\n            }, parsedResponse;\n            delete pendingRequests[id];\n            options.log(qq.format(\"Received the following response body to an upload success request for id {}: {}\", id, responseJson));\n            try {\n                parsedResponse = qq.parseJson(responseJson);\n                if (isError || parsedResponse && (parsedResponse.error || parsedResponse.success === false)) {\n                    options.log(\"Upload success request was rejected by the server.\", \"error\");\n                    promise.failure(qq.extend(parsedResponse, failureIndicator));\n                } else {\n                    options.log(\"Upload success was acknowledged by the server.\");\n                    promise.success(qq.extend(parsedResponse, successIndicator));\n                }\n            } catch (error) {\n                if (isError) {\n                    options.log(qq.format(\"Your server indicated failure in its upload success request response for id {}!\", id), \"error\");\n                    promise.failure(failureIndicator);\n                } else {\n                    options.log(\"Upload success was acknowledged by the server.\");\n                    promise.success(successIndicator);\n                }\n            }\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            method: options.method,\n            endpointStore: {\n                get: function() {\n                    return options.endpoint;\n                }\n            },\n            paramsStore: options.paramsStore,\n            maxConnections: options.maxConnections,\n            customHeaders: options.customHeaders,\n            log: options.log,\n            onComplete: handleSuccessResponse,\n            cors: options.cors\n        }));\n        qq.extend(this, {\n            sendSuccessRequest: function(id, spec) {\n                var promise = new qq.Promise();\n                options.log(\"Submitting upload success request/notification for \" + id);\n                requester.initTransport(id).withParams(spec).send();\n                pendingRequests[id] = promise;\n                return promise;\n            }\n        });\n    };\n    qq.s3.InitiateMultipartAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, pendingInitiateRequests = {}, options = {\n            filenameParam: \"qqfilename\",\n            method: \"POST\",\n            endpointStore: null,\n            paramsStore: null,\n            signatureSpec: null,\n            aclStore: null,\n            reducedRedundancy: false,\n            serverSideEncryption: false,\n            maxConnections: 3,\n            getContentType: function(id) {},\n            getBucket: function(id) {},\n            getHost: function(id) {},\n            getKey: function(id) {},\n            getName: function(id) {},\n            log: function(str, level) {}\n        }, getSignatureAjaxRequester;\n        qq.extend(options, o);\n        getSignatureAjaxRequester = new qq.s3.RequestSigner({\n            endpointStore: options.endpointStore,\n            signatureSpec: options.signatureSpec,\n            cors: options.cors,\n            log: options.log\n        });\n        function getHeaders(id) {\n            var bucket = options.getBucket(id), host = options.getHost(id), headers = {}, promise = new qq.Promise(), key = options.getKey(id), signatureConstructor;\n            headers[\"x-amz-acl\"] = options.aclStore.get(id);\n            if (options.reducedRedundancy) {\n                headers[qq.s3.util.REDUCED_REDUNDANCY_PARAM_NAME] = qq.s3.util.REDUCED_REDUNDANCY_PARAM_VALUE;\n            }\n            if (options.serverSideEncryption) {\n                headers[qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_NAME] = qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_VALUE;\n            }\n            headers[qq.s3.util.AWS_PARAM_PREFIX + options.filenameParam] = encodeURIComponent(options.getName(id));\n            qq.each(options.paramsStore.get(id), function(name, val) {\n                if (qq.indexOf(qq.s3.util.UNPREFIXED_PARAM_NAMES, name) >= 0) {\n                    headers[name] = val;\n                } else {\n                    headers[qq.s3.util.AWS_PARAM_PREFIX + name] = encodeURIComponent(val);\n                }\n            });\n            signatureConstructor = getSignatureAjaxRequester.constructStringToSign(getSignatureAjaxRequester.REQUEST_TYPE.MULTIPART_INITIATE, bucket, host, key).withContentType(options.getContentType(id)).withHeaders(headers);\n            getSignatureAjaxRequester.getSignature(id, {\n                signatureConstructor: signatureConstructor\n            }).then(promise.success, promise.failure);\n            return promise;\n        }\n        function handleInitiateRequestComplete(id, xhr, isError) {\n            var promise = pendingInitiateRequests[id], domParser = new DOMParser(), responseDoc = domParser.parseFromString(xhr.responseText, \"application/xml\"), uploadIdElements, messageElements, uploadId, errorMessage, status;\n            delete pendingInitiateRequests[id];\n            if (isError) {\n                status = xhr.status;\n                messageElements = responseDoc.getElementsByTagName(\"Message\");\n                if (messageElements.length > 0) {\n                    errorMessage = messageElements[0].textContent;\n                }\n            } else {\n                uploadIdElements = responseDoc.getElementsByTagName(\"UploadId\");\n                if (uploadIdElements.length > 0) {\n                    uploadId = uploadIdElements[0].textContent;\n                } else {\n                    errorMessage = \"Upload ID missing from request\";\n                }\n            }\n            if (uploadId === undefined) {\n                if (errorMessage) {\n                    options.log(qq.format(\"Specific problem detected initiating multipart upload request for {}: '{}'.\", id, errorMessage), \"error\");\n                } else {\n                    options.log(qq.format(\"Unexplained error with initiate multipart upload request for {}.  Status code {}.\", id, status), \"error\");\n                }\n                promise.failure(\"Problem initiating upload request.\", xhr);\n            } else {\n                options.log(qq.format(\"Initiate multipart upload request successful for {}.  Upload ID is {}\", id, uploadId));\n                promise.success(uploadId, xhr);\n            }\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            method: options.method,\n            contentType: null,\n            endpointStore: options.endpointStore,\n            maxConnections: options.maxConnections,\n            allowXRequestedWithAndCacheControl: false,\n            log: options.log,\n            onComplete: handleInitiateRequestComplete,\n            successfulResponseCodes: {\n                POST: [ 200 ]\n            }\n        }));\n        qq.extend(this, {\n            send: function(id) {\n                var promise = new qq.Promise();\n                getHeaders(id).then(function(headers, endOfUrl) {\n                    options.log(\"Submitting S3 initiate multipart upload request for \" + id);\n                    pendingInitiateRequests[id] = promise;\n                    requester.initTransport(id).withPath(endOfUrl).withHeaders(headers).send();\n                }, promise.failure);\n                return promise;\n            }\n        });\n    };\n    qq.s3.CompleteMultipartAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, pendingCompleteRequests = {}, options = {\n            method: \"POST\",\n            contentType: \"text/xml\",\n            endpointStore: null,\n            signatureSpec: null,\n            maxConnections: 3,\n            getBucket: function(id) {},\n            getHost: function(id) {},\n            getKey: function(id) {},\n            log: function(str, level) {}\n        }, getSignatureAjaxRequester;\n        qq.extend(options, o);\n        getSignatureAjaxRequester = new qq.s3.RequestSigner({\n            endpointStore: options.endpointStore,\n            signatureSpec: options.signatureSpec,\n            cors: options.cors,\n            log: options.log\n        });\n        function getHeaders(id, uploadId, body) {\n            var headers = {}, promise = new qq.Promise(), bucket = options.getBucket(id), host = options.getHost(id), signatureConstructor = getSignatureAjaxRequester.constructStringToSign(getSignatureAjaxRequester.REQUEST_TYPE.MULTIPART_COMPLETE, bucket, host, options.getKey(id)).withUploadId(uploadId).withContent(body).withContentType(\"application/xml; charset=UTF-8\");\n            getSignatureAjaxRequester.getSignature(id, {\n                signatureConstructor: signatureConstructor\n            }).then(promise.success, promise.failure);\n            return promise;\n        }\n        function handleCompleteRequestComplete(id, xhr, isError) {\n            var promise = pendingCompleteRequests[id], domParser = new DOMParser(), bucket = options.getBucket(id), key = options.getKey(id), responseDoc = domParser.parseFromString(xhr.responseText, \"application/xml\"), bucketEls = responseDoc.getElementsByTagName(\"Bucket\"), keyEls = responseDoc.getElementsByTagName(\"Key\");\n            delete pendingCompleteRequests[id];\n            options.log(qq.format(\"Complete response status {}, body = {}\", xhr.status, xhr.responseText));\n            if (isError) {\n                options.log(qq.format(\"Complete Multipart Upload request for {} failed with status {}.\", id, xhr.status), \"error\");\n            } else {\n                if (bucketEls.length && keyEls.length) {\n                    if (bucketEls[0].textContent !== bucket) {\n                        isError = true;\n                        options.log(qq.format(\"Wrong bucket in response to Complete Multipart Upload request for {}.\", id), \"error\");\n                    }\n                } else {\n                    isError = true;\n                    options.log(qq.format(\"Missing bucket and/or key in response to Complete Multipart Upload request for {}.\", id), \"error\");\n                }\n            }\n            if (isError) {\n                promise.failure(\"Problem combining the file parts!\", xhr);\n            } else {\n                promise.success({}, xhr);\n            }\n        }\n        function getCompleteRequestBody(etagEntries) {\n            var doc = document.implementation.createDocument(null, \"CompleteMultipartUpload\", null);\n            etagEntries.sort(function(a, b) {\n                return a.part - b.part;\n            });\n            qq.each(etagEntries, function(idx, etagEntry) {\n                var part = etagEntry.part, etag = etagEntry.etag, partEl = doc.createElement(\"Part\"), partNumEl = doc.createElement(\"PartNumber\"), partNumTextEl = doc.createTextNode(part), etagTextEl = doc.createTextNode(etag), etagEl = doc.createElement(\"ETag\");\n                etagEl.appendChild(etagTextEl);\n                partNumEl.appendChild(partNumTextEl);\n                partEl.appendChild(partNumEl);\n                partEl.appendChild(etagEl);\n                qq(doc).children()[0].appendChild(partEl);\n            });\n            return new XMLSerializer().serializeToString(doc);\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            method: options.method,\n            contentType: \"application/xml; charset=UTF-8\",\n            endpointStore: options.endpointStore,\n            maxConnections: options.maxConnections,\n            allowXRequestedWithAndCacheControl: false,\n            log: options.log,\n            onComplete: handleCompleteRequestComplete,\n            successfulResponseCodes: {\n                POST: [ 200 ]\n            }\n        }));\n        qq.extend(this, {\n            send: function(id, uploadId, etagEntries) {\n                var promise = new qq.Promise(), body = getCompleteRequestBody(etagEntries);\n                getHeaders(id, uploadId, body).then(function(headers, endOfUrl) {\n                    options.log(\"Submitting S3 complete multipart upload request for \" + id);\n                    pendingCompleteRequests[id] = promise;\n                    delete headers[\"Content-Type\"];\n                    requester.initTransport(id).withPath(endOfUrl).withHeaders(headers).withPayload(body).send();\n                }, promise.failure);\n                return promise;\n            }\n        });\n    };\n    qq.s3.AbortMultipartAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, options = {\n            method: \"DELETE\",\n            endpointStore: null,\n            signatureSpec: null,\n            maxConnections: 3,\n            getBucket: function(id) {},\n            getHost: function(id) {},\n            getKey: function(id) {},\n            log: function(str, level) {}\n        }, getSignatureAjaxRequester;\n        qq.extend(options, o);\n        getSignatureAjaxRequester = new qq.s3.RequestSigner({\n            endpointStore: options.endpointStore,\n            signatureSpec: options.signatureSpec,\n            cors: options.cors,\n            log: options.log\n        });\n        function getHeaders(id, uploadId) {\n            var headers = {}, promise = new qq.Promise(), bucket = options.getBucket(id), host = options.getHost(id), signatureConstructor = getSignatureAjaxRequester.constructStringToSign(getSignatureAjaxRequester.REQUEST_TYPE.MULTIPART_ABORT, bucket, host, options.getKey(id)).withUploadId(uploadId);\n            getSignatureAjaxRequester.getSignature(id, {\n                signatureConstructor: signatureConstructor\n            }).then(promise.success, promise.failure);\n            return promise;\n        }\n        function handleAbortRequestComplete(id, xhr, isError) {\n            var domParser = new DOMParser(), responseDoc = domParser.parseFromString(xhr.responseText, \"application/xml\"), errorEls = responseDoc.getElementsByTagName(\"Error\"), awsErrorMsg;\n            options.log(qq.format(\"Abort response status {}, body = {}\", xhr.status, xhr.responseText));\n            if (isError) {\n                options.log(qq.format(\"Abort Multipart Upload request for {} failed with status {}.\", id, xhr.status), \"error\");\n            } else {\n                if (errorEls.length) {\n                    isError = true;\n                    awsErrorMsg = responseDoc.getElementsByTagName(\"Message\")[0].textContent;\n                    options.log(qq.format(\"Failed to Abort Multipart Upload request for {}.  Error: {}\", id, awsErrorMsg), \"error\");\n                } else {\n                    options.log(qq.format(\"Abort MPU request succeeded for file ID {}.\", id));\n                }\n            }\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            validMethods: [ \"DELETE\" ],\n            method: options.method,\n            contentType: null,\n            endpointStore: options.endpointStore,\n            maxConnections: options.maxConnections,\n            allowXRequestedWithAndCacheControl: false,\n            log: options.log,\n            onComplete: handleAbortRequestComplete,\n            successfulResponseCodes: {\n                DELETE: [ 204 ]\n            }\n        }));\n        qq.extend(this, {\n            send: function(id, uploadId) {\n                getHeaders(id, uploadId).then(function(headers, endOfUrl) {\n                    options.log(\"Submitting S3 Abort multipart upload request for \" + id);\n                    requester.initTransport(id).withPath(endOfUrl).withHeaders(headers).send();\n                });\n            }\n        });\n    };\n    qq.s3.XhrUploadHandler = function(spec, proxy) {\n        \"use strict\";\n        var getName = proxy.getName, log = proxy.log, clockDrift = spec.clockDrift, expectedStatus = 200, onGetBucket = spec.getBucket, onGetHost = spec.getHost, onGetKeyName = spec.getKeyName, filenameParam = spec.filenameParam, paramsStore = spec.paramsStore, endpointStore = spec.endpointStore, aclStore = spec.aclStore, reducedRedundancy = spec.objectProperties.reducedRedundancy, region = spec.objectProperties.region, serverSideEncryption = spec.objectProperties.serverSideEncryption, validation = spec.validation, signature = qq.extend({\n            region: region,\n            drift: clockDrift\n        }, spec.signature), handler = this, credentialsProvider = spec.signature.credentialsProvider, chunked = {\n            combine: function(id) {\n                var uploadId = handler._getPersistableData(id).uploadId, etagMap = handler._getPersistableData(id).etags, result = new qq.Promise();\n                requesters.completeMultipart.send(id, uploadId, etagMap).then(result.success, function failure(reason, xhr) {\n                    result.failure(upload.done(id, xhr).response, xhr);\n                });\n                return result;\n            },\n            done: function(id, xhr, chunkIdx) {\n                var response = upload.response.parse(id, xhr), etag;\n                if (response.success) {\n                    etag = xhr.getResponseHeader(\"ETag\");\n                    if (!handler._getPersistableData(id).etags) {\n                        handler._getPersistableData(id).etags = [];\n                    }\n                    handler._getPersistableData(id).etags.push({\n                        part: chunkIdx + 1,\n                        etag: etag\n                    });\n                }\n            },\n            initHeaders: function(id, chunkIdx, blob) {\n                var headers = {}, bucket = upload.bucket.getName(id), host = upload.host.getName(id), key = upload.key.urlSafe(id), promise = new qq.Promise(), signatureConstructor = requesters.restSignature.constructStringToSign(requesters.restSignature.REQUEST_TYPE.MULTIPART_UPLOAD, bucket, host, key).withPartNum(chunkIdx + 1).withContent(blob).withUploadId(handler._getPersistableData(id).uploadId);\n                requesters.restSignature.getSignature(id + \".\" + chunkIdx, {\n                    signatureConstructor: signatureConstructor\n                }).then(promise.success, promise.failure);\n                return promise;\n            },\n            put: function(id, chunkIdx) {\n                var xhr = handler._createXhr(id, chunkIdx), chunkData = handler._getChunkData(id, chunkIdx), domain = spec.endpointStore.get(id), promise = new qq.Promise();\n                chunked.initHeaders(id, chunkIdx, chunkData.blob).then(function(headers, endOfUrl) {\n                    if (xhr._cancelled) {\n                        log(qq.format(\"Upload of item {}.{} cancelled. Upload will not start after successful signature request.\", id, chunkIdx));\n                        promise.failure({\n                            error: \"Chunk upload cancelled\"\n                        });\n                    } else {\n                        var url = domain + \"/\" + endOfUrl;\n                        handler._registerProgressHandler(id, chunkIdx, chunkData.size);\n                        upload.track(id, xhr, chunkIdx).then(promise.success, promise.failure);\n                        xhr.open(\"PUT\", url, true);\n                        qq.each(headers, function(name, val) {\n                            xhr.setRequestHeader(name, val);\n                        });\n                        xhr.send(chunkData.blob);\n                    }\n                }, function() {\n                    promise.failure({\n                        error: \"Problem signing the chunk!\"\n                    }, xhr);\n                });\n                return promise;\n            },\n            send: function(id, chunkIdx) {\n                var promise = new qq.Promise();\n                chunked.setup(id).then(function() {\n                    chunked.put(id, chunkIdx).then(promise.success, promise.failure);\n                }, function(errorMessage, xhr) {\n                    promise.failure({\n                        error: errorMessage\n                    }, xhr);\n                });\n                return promise;\n            },\n            setup: function(id) {\n                var promise = new qq.Promise(), uploadId = handler._getPersistableData(id).uploadId, uploadIdPromise = new qq.Promise();\n                if (!uploadId) {\n                    handler._getPersistableData(id).uploadId = uploadIdPromise;\n                    requesters.initiateMultipart.send(id).then(function(uploadId) {\n                        handler._getPersistableData(id).uploadId = uploadId;\n                        uploadIdPromise.success(uploadId);\n                        promise.success(uploadId);\n                    }, function(errorMsg, xhr) {\n                        handler._getPersistableData(id).uploadId = null;\n                        promise.failure(errorMsg, xhr);\n                        uploadIdPromise.failure(errorMsg, xhr);\n                    });\n                } else if (uploadId instanceof qq.Promise) {\n                    uploadId.then(function(uploadId) {\n                        promise.success(uploadId);\n                    });\n                } else {\n                    promise.success(uploadId);\n                }\n                return promise;\n            }\n        }, requesters = {\n            abortMultipart: new qq.s3.AbortMultipartAjaxRequester({\n                endpointStore: endpointStore,\n                signatureSpec: signature,\n                cors: spec.cors,\n                log: log,\n                getBucket: function(id) {\n                    return upload.bucket.getName(id);\n                },\n                getHost: function(id) {\n                    return upload.host.getName(id);\n                },\n                getKey: function(id) {\n                    return upload.key.urlSafe(id);\n                }\n            }),\n            completeMultipart: new qq.s3.CompleteMultipartAjaxRequester({\n                endpointStore: endpointStore,\n                signatureSpec: signature,\n                cors: spec.cors,\n                log: log,\n                getBucket: function(id) {\n                    return upload.bucket.getName(id);\n                },\n                getHost: function(id) {\n                    return upload.host.getName(id);\n                },\n                getKey: function(id) {\n                    return upload.key.urlSafe(id);\n                }\n            }),\n            initiateMultipart: new qq.s3.InitiateMultipartAjaxRequester({\n                filenameParam: filenameParam,\n                endpointStore: endpointStore,\n                paramsStore: paramsStore,\n                signatureSpec: signature,\n                aclStore: aclStore,\n                reducedRedundancy: reducedRedundancy,\n                serverSideEncryption: serverSideEncryption,\n                cors: spec.cors,\n                log: log,\n                getContentType: function(id) {\n                    return handler._getMimeType(id);\n                },\n                getBucket: function(id) {\n                    return upload.bucket.getName(id);\n                },\n                getHost: function(id) {\n                    return upload.host.getName(id);\n                },\n                getKey: function(id) {\n                    return upload.key.urlSafe(id);\n                },\n                getName: function(id) {\n                    return getName(id);\n                }\n            }),\n            policySignature: new qq.s3.RequestSigner({\n                expectingPolicy: true,\n                signatureSpec: signature,\n                cors: spec.cors,\n                log: log\n            }),\n            restSignature: new qq.s3.RequestSigner({\n                endpointStore: endpointStore,\n                signatureSpec: signature,\n                cors: spec.cors,\n                log: log\n            })\n        }, simple = {\n            initParams: function(id) {\n                var customParams = paramsStore.get(id);\n                customParams[filenameParam] = getName(id);\n                return qq.s3.util.generateAwsParams({\n                    endpoint: endpointStore.get(id),\n                    clockDrift: clockDrift,\n                    params: customParams,\n                    type: handler._getMimeType(id),\n                    bucket: upload.bucket.getName(id),\n                    key: handler.getThirdPartyFileId(id),\n                    accessKey: credentialsProvider.get().accessKey,\n                    sessionToken: credentialsProvider.get().sessionToken,\n                    acl: aclStore.get(id),\n                    expectedStatus: expectedStatus,\n                    minFileSize: validation.minSizeLimit,\n                    maxFileSize: validation.maxSizeLimit,\n                    reducedRedundancy: reducedRedundancy,\n                    region: region,\n                    serverSideEncryption: serverSideEncryption,\n                    signatureVersion: signature.version,\n                    log: log\n                }, qq.bind(requesters.policySignature.getSignature, this, id));\n            },\n            send: function(id) {\n                var promise = new qq.Promise(), xhr = handler._createXhr(id), fileOrBlob = handler.getFile(id);\n                handler._registerProgressHandler(id);\n                upload.track(id, xhr).then(promise.success, promise.failure);\n                simple.setup(id, xhr, fileOrBlob).then(function(toSend) {\n                    log(\"Sending upload request for \" + id);\n                    xhr.send(toSend);\n                }, promise.failure);\n                return promise;\n            },\n            setup: function(id, xhr, fileOrBlob) {\n                var formData = new FormData(), endpoint = endpointStore.get(id), url = endpoint, promise = new qq.Promise();\n                simple.initParams(id).then(function(awsParams) {\n                    xhr.open(\"POST\", url, true);\n                    qq.obj2FormData(awsParams, formData);\n                    formData.append(\"file\", fileOrBlob);\n                    promise.success(formData);\n                }, function(errorMessage) {\n                    promise.failure({\n                        error: errorMessage\n                    });\n                });\n                return promise;\n            }\n        }, upload = {\n            bucket: {\n                promise: function(id) {\n                    var promise = new qq.Promise(), cachedBucket = handler._getFileState(id).bucket;\n                    if (cachedBucket) {\n                        promise.success(cachedBucket);\n                    } else {\n                        onGetBucket(id).then(function(bucket) {\n                            handler._getFileState(id).bucket = bucket;\n                            promise.success(bucket);\n                        }, promise.failure);\n                    }\n                    return promise;\n                },\n                getName: function(id) {\n                    return handler._getFileState(id).bucket;\n                }\n            },\n            host: {\n                promise: function(id) {\n                    var promise = new qq.Promise(), cachedHost = handler._getFileState(id).host;\n                    if (cachedHost) {\n                        promise.success(cachedHost);\n                    } else {\n                        onGetHost(id).then(function(host) {\n                            handler._getFileState(id).host = host;\n                            promise.success(host);\n                        }, promise.failure);\n                    }\n                    return promise;\n                },\n                getName: function(id) {\n                    return handler._getFileState(id).host;\n                }\n            },\n            done: function(id, xhr) {\n                var response = upload.response.parse(id, xhr), isError = response.success !== true;\n                if (isError && upload.response.shouldReset(response.code)) {\n                    log(\"This is an unrecoverable error, we must restart the upload entirely on the next retry attempt.\", \"error\");\n                    response.reset = true;\n                }\n                return {\n                    success: !isError,\n                    response: response\n                };\n            },\n            key: {\n                promise: function(id) {\n                    var promise = new qq.Promise(), key = handler.getThirdPartyFileId(id);\n                    if (key == null) {\n                        handler._setThirdPartyFileId(id, promise);\n                        onGetKeyName(id, getName(id)).then(function(keyName) {\n                            handler._setThirdPartyFileId(id, keyName);\n                            promise.success(keyName);\n                        }, function(errorReason) {\n                            handler._setThirdPartyFileId(id, null);\n                            promise.failure(errorReason);\n                        });\n                    } else if (qq.isGenericPromise(key)) {\n                        key.then(promise.success, promise.failure);\n                    } else {\n                        promise.success(key);\n                    }\n                    return promise;\n                },\n                urlSafe: function(id) {\n                    var encodedKey = handler.getThirdPartyFileId(id);\n                    return qq.s3.util.uriEscapePath(encodedKey);\n                }\n            },\n            response: {\n                parse: function(id, xhr) {\n                    var response = {}, parsedErrorProps;\n                    try {\n                        log(qq.format(\"Received response status {} with body: {}\", xhr.status, xhr.responseText));\n                        if (xhr.status === expectedStatus) {\n                            response.success = true;\n                        } else {\n                            parsedErrorProps = upload.response.parseError(xhr.responseText);\n                            if (parsedErrorProps) {\n                                response.error = parsedErrorProps.message;\n                                response.code = parsedErrorProps.code;\n                            }\n                        }\n                    } catch (error) {\n                        log(\"Error when attempting to parse xhr response text (\" + error.message + \")\", \"error\");\n                    }\n                    return response;\n                },\n                parseError: function(awsResponseXml) {\n                    var parser = new DOMParser(), parsedDoc = parser.parseFromString(awsResponseXml, \"application/xml\"), errorEls = parsedDoc.getElementsByTagName(\"Error\"), errorDetails = {}, codeEls, messageEls;\n                    if (errorEls.length) {\n                        codeEls = parsedDoc.getElementsByTagName(\"Code\");\n                        messageEls = parsedDoc.getElementsByTagName(\"Message\");\n                        if (messageEls.length) {\n                            errorDetails.message = messageEls[0].textContent;\n                        }\n                        if (codeEls.length) {\n                            errorDetails.code = codeEls[0].textContent;\n                        }\n                        return errorDetails;\n                    }\n                },\n                shouldReset: function(errorCode) {\n                    return errorCode === \"EntityTooSmall\" || errorCode === \"InvalidPart\" || errorCode === \"InvalidPartOrder\" || errorCode === \"NoSuchUpload\";\n                }\n            },\n            start: function(id, optChunkIdx) {\n                var promise = new qq.Promise();\n                upload.key.promise(id).then(function() {\n                    upload.bucket.promise(id).then(function() {\n                        upload.host.promise(id).then(function() {\n                            if (optChunkIdx == null) {\n                                simple.send(id).then(promise.success, promise.failure);\n                            } else {\n                                chunked.send(id, optChunkIdx).then(promise.success, promise.failure);\n                            }\n                        });\n                    });\n                }, function(errorReason) {\n                    promise.failure({\n                        error: errorReason\n                    });\n                });\n                return promise;\n            },\n            track: function(id, xhr, optChunkIdx) {\n                var promise = new qq.Promise();\n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState === 4) {\n                        var result;\n                        if (optChunkIdx == null) {\n                            result = upload.done(id, xhr);\n                            promise[result.success ? \"success\" : \"failure\"](result.response, xhr);\n                        } else {\n                            chunked.done(id, xhr, optChunkIdx);\n                            result = upload.done(id, xhr);\n                            promise[result.success ? \"success\" : \"failure\"](result.response, xhr);\n                        }\n                    }\n                };\n                return promise;\n            }\n        };\n        qq.extend(this, {\n            uploadChunk: upload.start,\n            uploadFile: upload.start\n        });\n        qq.extend(this, new qq.XhrUploadHandler({\n            options: qq.extend({\n                namespace: \"s3\"\n            }, spec),\n            proxy: qq.extend({\n                getEndpoint: spec.endpointStore.get\n            }, proxy)\n        }));\n        qq.override(this, function(super_) {\n            return {\n                expunge: function(id) {\n                    var uploadId = handler._getPersistableData(id) && handler._getPersistableData(id).uploadId, existedInLocalStorage = handler._maybeDeletePersistedChunkData(id);\n                    if (uploadId !== undefined && existedInLocalStorage) {\n                        requesters.abortMultipart.send(id, uploadId);\n                    }\n                    super_.expunge(id);\n                },\n                finalizeChunks: function(id) {\n                    return chunked.combine(id);\n                },\n                _getLocalStorageId: function(id) {\n                    var baseStorageId = super_._getLocalStorageId(id), bucketName = upload.bucket.getName(id);\n                    return baseStorageId + \"-\" + bucketName;\n                }\n            };\n        });\n    };\n    qq.s3.FormUploadHandler = function(options, proxy) {\n        \"use strict\";\n        var handler = this, clockDrift = options.clockDrift, onUuidChanged = proxy.onUuidChanged, getName = proxy.getName, getUuid = proxy.getUuid, log = proxy.log, onGetBucket = options.getBucket, onGetKeyName = options.getKeyName, filenameParam = options.filenameParam, paramsStore = options.paramsStore, endpointStore = options.endpointStore, aclStore = options.aclStore, reducedRedundancy = options.objectProperties.reducedRedundancy, region = options.objectProperties.region, serverSideEncryption = options.objectProperties.serverSideEncryption, validation = options.validation, signature = options.signature, successRedirectUrl = options.iframeSupport.localBlankPagePath, credentialsProvider = options.signature.credentialsProvider, getSignatureAjaxRequester = new qq.s3.RequestSigner({\n            signatureSpec: signature,\n            cors: options.cors,\n            log: log\n        });\n        if (successRedirectUrl === undefined) {\n            throw new Error(\"successRedirectEndpoint MUST be defined if you intend to use browsers that do not support the File API!\");\n        }\n        function isValidResponse(id, iframe) {\n            var response, endpoint = options.endpointStore.get(id), bucket = handler._getFileState(id).bucket, doc, innerHtml, responseData;\n            try {\n                doc = iframe.contentDocument || iframe.contentWindow.document;\n                innerHtml = doc.body.innerHTML;\n                responseData = qq.s3.util.parseIframeResponse(iframe);\n                if (responseData.bucket === bucket && responseData.key === qq.s3.util.encodeQueryStringParam(handler.getThirdPartyFileId(id))) {\n                    return true;\n                }\n                log(\"Response from AWS included an unexpected bucket or key name.\", \"error\");\n            } catch (error) {\n                log(\"Error when attempting to parse form upload response (\" + error.message + \")\", \"error\");\n            }\n            return false;\n        }\n        function generateAwsParams(id) {\n            var customParams = paramsStore.get(id);\n            customParams[filenameParam] = getName(id);\n            return qq.s3.util.generateAwsParams({\n                endpoint: endpointStore.get(id),\n                clockDrift: clockDrift,\n                params: customParams,\n                bucket: handler._getFileState(id).bucket,\n                key: handler.getThirdPartyFileId(id),\n                accessKey: credentialsProvider.get().accessKey,\n                sessionToken: credentialsProvider.get().sessionToken,\n                acl: aclStore.get(id),\n                minFileSize: validation.minSizeLimit,\n                maxFileSize: validation.maxSizeLimit,\n                successRedirectUrl: successRedirectUrl,\n                reducedRedundancy: reducedRedundancy,\n                region: region,\n                serverSideEncryption: serverSideEncryption,\n                signatureVersion: signature.version,\n                log: log\n            }, qq.bind(getSignatureAjaxRequester.getSignature, this, id));\n        }\n        function createForm(id, iframe) {\n            var promise = new qq.Promise(), method = \"POST\", endpoint = options.endpointStore.get(id), fileName = getName(id);\n            generateAwsParams(id).then(function(params) {\n                var form = handler._initFormForUpload({\n                    method: method,\n                    endpoint: endpoint,\n                    params: params,\n                    paramsInBody: true,\n                    targetName: iframe.name\n                });\n                promise.success(form);\n            }, function(errorMessage) {\n                promise.failure(errorMessage);\n                handleFinishedUpload(id, iframe, fileName, {\n                    error: errorMessage\n                });\n            });\n            return promise;\n        }\n        function handleUpload(id) {\n            var iframe = handler._createIframe(id), input = handler.getInput(id), promise = new qq.Promise();\n            createForm(id, iframe).then(function(form) {\n                form.appendChild(input);\n                handler._attachLoadEvent(iframe, function(response) {\n                    log(\"iframe loaded\");\n                    if (response) {\n                        if (response.success === false) {\n                            log(\"Amazon likely rejected the upload request\", \"error\");\n                            promise.failure(response);\n                        }\n                    } else {\n                        response = {};\n                        response.success = isValidResponse(id, iframe);\n                        if (response.success === false) {\n                            log(\"A success response was received by Amazon, but it was invalid in some way.\", \"error\");\n                            promise.failure(response);\n                        } else {\n                            qq.extend(response, qq.s3.util.parseIframeResponse(iframe));\n                            promise.success(response);\n                        }\n                    }\n                    handleFinishedUpload(id, iframe);\n                });\n                log(\"Sending upload request for \" + id);\n                form.submit();\n                qq(form).remove();\n            }, promise.failure);\n            return promise;\n        }\n        function handleFinishedUpload(id, iframe) {\n            handler._detachLoadEvent(id);\n            iframe && qq(iframe).remove();\n        }\n        qq.extend(this, new qq.FormUploadHandler({\n            options: {\n                isCors: false,\n                inputName: \"file\"\n            },\n            proxy: {\n                onCancel: options.onCancel,\n                onUuidChanged: onUuidChanged,\n                getName: getName,\n                getUuid: getUuid,\n                log: log\n            }\n        }));\n        qq.extend(this, {\n            uploadFile: function(id) {\n                var name = getName(id), promise = new qq.Promise();\n                if (handler.getThirdPartyFileId(id)) {\n                    if (handler._getFileState(id).bucket) {\n                        handleUpload(id).then(promise.success, promise.failure);\n                    } else {\n                        onGetBucket(id).then(function(bucket) {\n                            handler._getFileState(id).bucket = bucket;\n                            handleUpload(id).then(promise.success, promise.failure);\n                        });\n                    }\n                } else {\n                    onGetKeyName(id, name).then(function(key) {\n                        onGetBucket(id).then(function(bucket) {\n                            handler._getFileState(id).bucket = bucket;\n                            handler._setThirdPartyFileId(id, key);\n                            handleUpload(id).then(promise.success, promise.failure);\n                        }, function(errorReason) {\n                            promise.failure({\n                                error: errorReason\n                            });\n                        });\n                    }, function(errorReason) {\n                        promise.failure({\n                            error: errorReason\n                        });\n                    });\n                }\n                return promise;\n            }\n        });\n    };\n    (function() {\n        \"use strict\";\n        qq.s3.FineUploader = function(o) {\n            var options = {\n                failedUploadTextDisplay: {\n                    mode: \"custom\"\n                }\n            };\n            qq.extend(options, o, true);\n            qq.FineUploader.call(this, options, \"s3\");\n            if (!qq.supportedFeatures.ajaxUploading && options.iframeSupport.localBlankPagePath === undefined) {\n                this._options.element.innerHTML = \"<div>You MUST set the <code>localBlankPagePath</code> property \" + \"of the <code>iframeSupport</code> option since this browser does not support the File API!</div>\";\n            }\n        };\n        qq.extend(qq.s3.FineUploader.prototype, qq.s3.FineUploaderBasic.prototype);\n        qq.extend(qq.s3.FineUploader.prototype, qq.uiPublicApi);\n        qq.extend(qq.s3.FineUploader.prototype, qq.uiPrivateApi);\n    })();\n    qq.azure = qq.azure || {};\n    qq.azure.util = qq.azure.util || function() {\n        \"use strict\";\n        return {\n            AZURE_PARAM_PREFIX: \"x-ms-meta-\",\n            _paramNameMatchesAzureParameter: function(name) {\n                switch (name) {\n                  case \"Cache-Control\":\n                  case \"Content-Disposition\":\n                  case \"Content-Encoding\":\n                  case \"Content-MD5\":\n                  case \"x-ms-blob-content-encoding\":\n                  case \"x-ms-blob-content-disposition\":\n                  case \"x-ms-blob-content-md5\":\n                  case \"x-ms-blob-cache-control\":\n                    return true;\n\n                  default:\n                    return false;\n                }\n            },\n            _getPrefixedParamName: function(name) {\n                if (qq.azure.util._paramNameMatchesAzureParameter(name)) {\n                    return name;\n                } else {\n                    return qq.azure.util.AZURE_PARAM_PREFIX + name;\n                }\n            },\n            getParamsAsHeaders: function(params) {\n                var headers = {};\n                qq.each(params, function(name, val) {\n                    var headerName = qq.azure.util._getPrefixedParamName(name), value = null;\n                    if (qq.isFunction(val)) {\n                        value = String(val());\n                    } else if (qq.isObject(val)) {\n                        qq.extend(headers, qq.azure.util.getParamsAsHeaders(val));\n                    } else {\n                        value = String(val);\n                    }\n                    if (value !== null) {\n                        if (qq.azure.util._paramNameMatchesAzureParameter(name)) {\n                            headers[headerName] = value;\n                        } else {\n                            headers[headerName] = encodeURIComponent(value);\n                        }\n                    }\n                });\n                return headers;\n            },\n            parseAzureError: function(responseText, log) {\n                var domParser = new DOMParser(), responseDoc = domParser.parseFromString(responseText, \"application/xml\"), errorTag = responseDoc.getElementsByTagName(\"Error\")[0], errorDetails = {}, codeTag, messageTag;\n                log(\"Received error response: \" + responseText, \"error\");\n                if (errorTag) {\n                    messageTag = errorTag.getElementsByTagName(\"Message\")[0];\n                    if (messageTag) {\n                        errorDetails.message = messageTag.textContent;\n                    }\n                    codeTag = errorTag.getElementsByTagName(\"Code\")[0];\n                    if (codeTag) {\n                        errorDetails.code = codeTag.textContent;\n                    }\n                    log(\"Parsed Azure error: \" + JSON.stringify(errorDetails), \"error\");\n                    return errorDetails;\n                }\n            }\n        };\n    }();\n    (function() {\n        \"use strict\";\n        qq.nonTraditionalBasePublicApi = {\n            setUploadSuccessParams: function(params, id) {\n                this._uploadSuccessParamsStore.set(params, id);\n            },\n            setUploadSuccessEndpoint: function(endpoint, id) {\n                this._uploadSuccessEndpointStore.set(endpoint, id);\n            }\n        };\n        qq.nonTraditionalBasePrivateApi = {\n            _onComplete: function(id, name, result, xhr) {\n                var success = result.success ? true : false, self = this, onCompleteArgs = arguments, successEndpoint = this._uploadSuccessEndpointStore.get(id), successCustomHeaders = this._options.uploadSuccess.customHeaders, successMethod = this._options.uploadSuccess.method, cors = this._options.cors, promise = new qq.Promise(), uploadSuccessParams = this._uploadSuccessParamsStore.get(id), fileParams = this._paramsStore.get(id), onSuccessFromServer = function(successRequestResult) {\n                    delete self._failedSuccessRequestCallbacks[id];\n                    qq.extend(result, successRequestResult);\n                    qq.FineUploaderBasic.prototype._onComplete.apply(self, onCompleteArgs);\n                    promise.success(successRequestResult);\n                }, onFailureFromServer = function(successRequestResult) {\n                    var callback = submitSuccessRequest;\n                    qq.extend(result, successRequestResult);\n                    if (result && result.reset) {\n                        callback = null;\n                    }\n                    if (!callback) {\n                        delete self._failedSuccessRequestCallbacks[id];\n                    } else {\n                        self._failedSuccessRequestCallbacks[id] = callback;\n                    }\n                    if (!self._onAutoRetry(id, name, result, xhr, callback)) {\n                        qq.FineUploaderBasic.prototype._onComplete.apply(self, onCompleteArgs);\n                        promise.failure(successRequestResult);\n                    }\n                }, submitSuccessRequest, successAjaxRequester;\n                if (success && successEndpoint) {\n                    successAjaxRequester = new qq.UploadSuccessAjaxRequester({\n                        endpoint: successEndpoint,\n                        method: successMethod,\n                        customHeaders: successCustomHeaders,\n                        cors: cors,\n                        log: qq.bind(this.log, this)\n                    });\n                    qq.extend(uploadSuccessParams, self._getEndpointSpecificParams(id, result, xhr), true);\n                    fileParams && qq.extend(uploadSuccessParams, fileParams, true);\n                    submitSuccessRequest = qq.bind(function() {\n                        successAjaxRequester.sendSuccessRequest(id, uploadSuccessParams).then(onSuccessFromServer, onFailureFromServer);\n                    }, self);\n                    submitSuccessRequest();\n                    return promise;\n                }\n                return qq.FineUploaderBasic.prototype._onComplete.apply(this, arguments);\n            },\n            _manualRetry: function(id) {\n                var successRequestCallback = this._failedSuccessRequestCallbacks[id];\n                return qq.FineUploaderBasic.prototype._manualRetry.call(this, id, successRequestCallback);\n            }\n        };\n    })();\n    (function() {\n        \"use strict\";\n        qq.azure.FineUploaderBasic = function(o) {\n            if (!qq.supportedFeatures.ajaxUploading) {\n                throw new qq.Error(\"Uploading directly to Azure is not possible in this browser.\");\n            }\n            var options = {\n                signature: {\n                    endpoint: null,\n                    customHeaders: {}\n                },\n                blobProperties: {\n                    name: \"uuid\"\n                },\n                uploadSuccess: {\n                    endpoint: null,\n                    method: \"POST\",\n                    params: {},\n                    customHeaders: {}\n                },\n                chunking: {\n                    partSize: 4e6,\n                    minFileSize: 4000001\n                }\n            };\n            qq.extend(options, o, true);\n            qq.FineUploaderBasic.call(this, options);\n            this._uploadSuccessParamsStore = this._createStore(this._options.uploadSuccess.params);\n            this._uploadSuccessEndpointStore = this._createStore(this._options.uploadSuccess.endpoint);\n            this._failedSuccessRequestCallbacks = {};\n            this._cannedBlobNames = {};\n        };\n        qq.extend(qq.azure.FineUploaderBasic.prototype, qq.basePublicApi);\n        qq.extend(qq.azure.FineUploaderBasic.prototype, qq.basePrivateApi);\n        qq.extend(qq.azure.FineUploaderBasic.prototype, qq.nonTraditionalBasePublicApi);\n        qq.extend(qq.azure.FineUploaderBasic.prototype, qq.nonTraditionalBasePrivateApi);\n        qq.extend(qq.azure.FineUploaderBasic.prototype, {\n            getBlobName: function(id) {\n                if (this._cannedBlobNames[id] == null) {\n                    return this._handler.getThirdPartyFileId(id);\n                }\n                return this._cannedBlobNames[id];\n            },\n            _getEndpointSpecificParams: function(id) {\n                return {\n                    blob: this.getBlobName(id),\n                    uuid: this.getUuid(id),\n                    name: this.getName(id),\n                    container: this._endpointStore.get(id)\n                };\n            },\n            _createUploadHandler: function() {\n                return qq.FineUploaderBasic.prototype._createUploadHandler.call(this, {\n                    signature: this._options.signature,\n                    onGetBlobName: qq.bind(this._determineBlobName, this),\n                    deleteBlob: qq.bind(this._deleteBlob, this, true)\n                }, \"azure\");\n            },\n            _determineBlobName: function(id) {\n                var self = this, blobNameOptionValue = this._options.blobProperties.name, uuid = this.getUuid(id), filename = this.getName(id), fileExtension = qq.getExtension(filename), blobNameToUse = uuid;\n                if (qq.isString(blobNameOptionValue)) {\n                    switch (blobNameOptionValue) {\n                      case \"uuid\":\n                        if (fileExtension !== undefined) {\n                            blobNameToUse += \".\" + fileExtension;\n                        }\n                        return new qq.Promise().success(blobNameToUse);\n\n                      case \"filename\":\n                        return new qq.Promise().success(filename);\n\n                      default:\n                        return new qq.Promise.failure(\"Invalid blobName option value - \" + blobNameOptionValue);\n                    }\n                } else {\n                    return blobNameOptionValue.call(this, id);\n                }\n            },\n            _addCannedFile: function(sessionData) {\n                var id;\n                if (sessionData.blobName == null) {\n                    throw new qq.Error(\"Did not find blob name property in server session response.  This is required!\");\n                } else {\n                    id = qq.FineUploaderBasic.prototype._addCannedFile.apply(this, arguments);\n                    this._cannedBlobNames[id] = sessionData.blobName;\n                }\n                return id;\n            },\n            _deleteBlob: function(relatedToCancel, id) {\n                var self = this, deleteBlobSasUri = {}, blobUriStore = {\n                    get: function(id) {\n                        return self._endpointStore.get(id) + \"/\" + self.getBlobName(id);\n                    }\n                }, deleteFileEndpointStore = {\n                    get: function(id) {\n                        return deleteBlobSasUri[id];\n                    }\n                }, getSasSuccess = function(id, sasUri) {\n                    deleteBlobSasUri[id] = sasUri;\n                    deleteBlob.send(id);\n                }, getSasFailure = function(id, reason, xhr) {\n                    if (relatedToCancel) {\n                        self.log(\"Will cancel upload, but cannot remove uncommitted parts from Azure due to issue retrieving SAS\", \"error\");\n                        qq.FineUploaderBasic.prototype._onCancel.call(self, id, self.getName(id));\n                    } else {\n                        self._onDeleteComplete(id, xhr, true);\n                        self._options.callbacks.onDeleteComplete(id, xhr, true);\n                    }\n                }, deleteBlob = new qq.azure.DeleteBlob({\n                    endpointStore: deleteFileEndpointStore,\n                    log: qq.bind(self.log, self),\n                    onDelete: function(id) {\n                        self._onDelete(id);\n                        self._options.callbacks.onDelete(id);\n                    },\n                    onDeleteComplete: function(id, xhrOrXdr, isError) {\n                        delete deleteBlobSasUri[id];\n                        if (isError) {\n                            if (relatedToCancel) {\n                                self.log(\"Will cancel upload, but failed to remove uncommitted parts from Azure.\", \"error\");\n                            } else {\n                                qq.azure.util.parseAzureError(xhrOrXdr.responseText, qq.bind(self.log, self));\n                            }\n                        }\n                        if (relatedToCancel) {\n                            qq.FineUploaderBasic.prototype._onCancel.call(self, id, self.getName(id));\n                            self.log(\"Deleted uncommitted blob chunks for \" + id);\n                        } else {\n                            self._onDeleteComplete(id, xhrOrXdr, isError);\n                            self._options.callbacks.onDeleteComplete(id, xhrOrXdr, isError);\n                        }\n                    }\n                }), getSas = new qq.azure.GetSas({\n                    cors: this._options.cors,\n                    customHeaders: this._options.signature.customHeaders,\n                    endpointStore: {\n                        get: function() {\n                            return self._options.signature.endpoint;\n                        }\n                    },\n                    restRequestVerb: deleteBlob.method,\n                    log: qq.bind(self.log, self)\n                });\n                getSas.request(id, blobUriStore.get(id)).then(qq.bind(getSasSuccess, self, id), qq.bind(getSasFailure, self, id));\n            },\n            _createDeleteHandler: function() {\n                var self = this;\n                return {\n                    sendDelete: function(id, uuid) {\n                        self._deleteBlob(false, id);\n                    }\n                };\n            }\n        });\n    })();\n    qq.azure.XhrUploadHandler = function(spec, proxy) {\n        \"use strict\";\n        var handler = this, log = proxy.log, cors = spec.cors, endpointStore = spec.endpointStore, paramsStore = spec.paramsStore, signature = spec.signature, filenameParam = spec.filenameParam, minFileSizeForChunking = spec.chunking.minFileSize, deleteBlob = spec.deleteBlob, onGetBlobName = spec.onGetBlobName, getName = proxy.getName, getSize = proxy.getSize, getBlobMetadata = function(id) {\n            var params = paramsStore.get(id);\n            params[filenameParam] = getName(id);\n            return params;\n        }, api = {\n            putBlob: new qq.azure.PutBlob({\n                getBlobMetadata: getBlobMetadata,\n                log: log\n            }),\n            putBlock: new qq.azure.PutBlock({\n                log: log\n            }),\n            putBlockList: new qq.azure.PutBlockList({\n                getBlobMetadata: getBlobMetadata,\n                log: log\n            }),\n            getSasForPutBlobOrBlock: new qq.azure.GetSas({\n                cors: cors,\n                customHeaders: signature.customHeaders,\n                endpointStore: {\n                    get: function() {\n                        return signature.endpoint;\n                    }\n                },\n                log: log,\n                restRequestVerb: \"PUT\"\n            })\n        };\n        function combineChunks(id) {\n            var promise = new qq.Promise();\n            getSignedUrl(id).then(function(sasUri) {\n                var mimeType = handler._getMimeType(id), blockIdEntries = handler._getPersistableData(id).blockIdEntries;\n                api.putBlockList.send(id, sasUri, blockIdEntries, mimeType, function(xhr) {\n                    handler._registerXhr(id, null, xhr, api.putBlockList);\n                }).then(function(xhr) {\n                    log(\"Success combining chunks for id \" + id);\n                    promise.success({}, xhr);\n                }, function(xhr) {\n                    log(\"Attempt to combine chunks failed for id \" + id, \"error\");\n                    handleFailure(xhr, promise);\n                });\n            }, promise.failure);\n            return promise;\n        }\n        function determineBlobUrl(id) {\n            var containerUrl = endpointStore.get(id), promise = new qq.Promise(), getBlobNameSuccess = function(blobName) {\n                handler._setThirdPartyFileId(id, blobName);\n                promise.success(containerUrl + \"/\" + blobName);\n            }, getBlobNameFailure = function(reason) {\n                promise.failure(reason);\n            };\n            onGetBlobName(id).then(getBlobNameSuccess, getBlobNameFailure);\n            return promise;\n        }\n        function getSignedUrl(id, optChunkIdx) {\n            var getSasId = optChunkIdx == null ? id : id + \".\" + optChunkIdx, promise = new qq.Promise(), getSasSuccess = function(sasUri) {\n                log(\"GET SAS request succeeded.\");\n                promise.success(sasUri);\n            }, getSasFailure = function(reason, getSasXhr) {\n                log(\"GET SAS request failed: \" + reason, \"error\");\n                promise.failure({\n                    error: \"Problem communicating with local server\"\n                }, getSasXhr);\n            }, determineBlobUrlSuccess = function(blobUrl) {\n                api.getSasForPutBlobOrBlock.request(getSasId, blobUrl).then(getSasSuccess, getSasFailure);\n            }, determineBlobUrlFailure = function(reason) {\n                log(qq.format(\"Failed to determine blob name for ID {} - {}\", id, reason), \"error\");\n                promise.failure({\n                    error: reason\n                });\n            };\n            determineBlobUrl(id).then(determineBlobUrlSuccess, determineBlobUrlFailure);\n            return promise;\n        }\n        function handleFailure(xhr, promise) {\n            var azureError = qq.azure.util.parseAzureError(xhr.responseText, log), errorMsg = \"Problem sending file to Azure\";\n            promise.failure({\n                error: errorMsg,\n                azureError: azureError && azureError.message,\n                reset: xhr.status === 403\n            });\n        }\n        qq.extend(this, {\n            uploadChunk: function(id, chunkIdx) {\n                var promise = new qq.Promise();\n                getSignedUrl(id, chunkIdx).then(function(sasUri) {\n                    var xhr = handler._createXhr(id, chunkIdx), chunkData = handler._getChunkData(id, chunkIdx);\n                    handler._registerProgressHandler(id, chunkIdx, chunkData.size);\n                    handler._registerXhr(id, chunkIdx, xhr, api.putBlock);\n                    api.putBlock.upload(id + \".\" + chunkIdx, xhr, sasUri, chunkIdx, chunkData.blob).then(function(blockIdEntry) {\n                        if (!handler._getPersistableData(id).blockIdEntries) {\n                            handler._getPersistableData(id).blockIdEntries = [];\n                        }\n                        handler._getPersistableData(id).blockIdEntries.push(blockIdEntry);\n                        log(\"Put Block call succeeded for \" + id);\n                        promise.success({}, xhr);\n                    }, function() {\n                        log(qq.format(\"Put Block call failed for ID {} on part {}\", id, chunkIdx), \"error\");\n                        handleFailure(xhr, promise);\n                    });\n                }, promise.failure);\n                return promise;\n            },\n            uploadFile: function(id) {\n                var promise = new qq.Promise(), fileOrBlob = handler.getFile(id);\n                getSignedUrl(id).then(function(sasUri) {\n                    var xhr = handler._createXhr(id);\n                    handler._registerProgressHandler(id);\n                    api.putBlob.upload(id, xhr, sasUri, fileOrBlob).then(function() {\n                        log(\"Put Blob call succeeded for \" + id);\n                        promise.success({}, xhr);\n                    }, function() {\n                        log(\"Put Blob call failed for \" + id, \"error\");\n                        handleFailure(xhr, promise);\n                    });\n                }, promise.failure);\n                return promise;\n            }\n        });\n        qq.extend(this, new qq.XhrUploadHandler({\n            options: qq.extend({\n                namespace: \"azure\"\n            }, spec),\n            proxy: qq.extend({\n                getEndpoint: spec.endpointStore.get\n            }, proxy)\n        }));\n        qq.override(this, function(super_) {\n            return {\n                expunge: function(id) {\n                    var relatedToCancel = handler._wasCanceled(id), chunkingData = handler._getPersistableData(id), blockIdEntries = chunkingData && chunkingData.blockIdEntries || [];\n                    if (relatedToCancel && blockIdEntries.length > 0) {\n                        deleteBlob(id);\n                    }\n                    super_.expunge(id);\n                },\n                finalizeChunks: function(id) {\n                    return combineChunks(id);\n                },\n                _shouldChunkThisFile: function(id) {\n                    var maybePossible = super_._shouldChunkThisFile(id);\n                    return maybePossible && getSize(id) >= minFileSizeForChunking;\n                }\n            };\n        });\n    };\n    qq.azure.GetSas = function(o) {\n        \"use strict\";\n        var requester, options = {\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            customHeaders: {},\n            restRequestVerb: \"PUT\",\n            endpointStore: null,\n            log: function(str, level) {}\n        }, requestPromises = {};\n        qq.extend(options, o);\n        function sasResponseReceived(id, xhr, isError) {\n            var promise = requestPromises[id];\n            if (isError) {\n                promise.failure(\"Received response code \" + xhr.status, xhr);\n            } else {\n                if (xhr.responseText.length) {\n                    promise.success(xhr.responseText);\n                } else {\n                    promise.failure(\"Empty response.\", xhr);\n                }\n            }\n            delete requestPromises[id];\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            validMethods: [ \"GET\" ],\n            method: \"GET\",\n            successfulResponseCodes: {\n                GET: [ 200 ]\n            },\n            contentType: null,\n            customHeaders: options.customHeaders,\n            endpointStore: options.endpointStore,\n            cors: options.cors,\n            log: options.log,\n            onComplete: sasResponseReceived\n        }));\n        qq.extend(this, {\n            request: function(id, blobUri) {\n                var requestPromise = new qq.Promise(), restVerb = options.restRequestVerb;\n                options.log(qq.format(\"Submitting GET SAS request for a {} REST request related to file ID {}.\", restVerb, id));\n                requestPromises[id] = requestPromise;\n                requester.initTransport(id).withParams({\n                    bloburi: blobUri,\n                    _method: restVerb\n                }).withCacheBuster().send();\n                return requestPromise;\n            }\n        });\n    };\n    qq.UploadSuccessAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, pendingRequests = [], options = {\n            method: \"POST\",\n            endpoint: null,\n            maxConnections: 3,\n            customHeaders: {},\n            paramsStore: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {}\n        };\n        qq.extend(options, o);\n        function handleSuccessResponse(id, xhrOrXdr, isError) {\n            var promise = pendingRequests[id], responseJson = xhrOrXdr.responseText, successIndicator = {\n                success: true\n            }, failureIndicator = {\n                success: false\n            }, parsedResponse;\n            delete pendingRequests[id];\n            options.log(qq.format(\"Received the following response body to an upload success request for id {}: {}\", id, responseJson));\n            try {\n                parsedResponse = qq.parseJson(responseJson);\n                if (isError || parsedResponse && (parsedResponse.error || parsedResponse.success === false)) {\n                    options.log(\"Upload success request was rejected by the server.\", \"error\");\n                    promise.failure(qq.extend(parsedResponse, failureIndicator));\n                } else {\n                    options.log(\"Upload success was acknowledged by the server.\");\n                    promise.success(qq.extend(parsedResponse, successIndicator));\n                }\n            } catch (error) {\n                if (isError) {\n                    options.log(qq.format(\"Your server indicated failure in its upload success request response for id {}!\", id), \"error\");\n                    promise.failure(failureIndicator);\n                } else {\n                    options.log(\"Upload success was acknowledged by the server.\");\n                    promise.success(successIndicator);\n                }\n            }\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            method: options.method,\n            endpointStore: {\n                get: function() {\n                    return options.endpoint;\n                }\n            },\n            paramsStore: options.paramsStore,\n            maxConnections: options.maxConnections,\n            customHeaders: options.customHeaders,\n            log: options.log,\n            onComplete: handleSuccessResponse,\n            cors: options.cors\n        }));\n        qq.extend(this, {\n            sendSuccessRequest: function(id, spec) {\n                var promise = new qq.Promise();\n                options.log(\"Submitting upload success request/notification for \" + id);\n                requester.initTransport(id).withParams(spec).send();\n                pendingRequests[id] = promise;\n                return promise;\n            }\n        });\n    };\n    qq.azure.DeleteBlob = function(o) {\n        \"use strict\";\n        var requester, method = \"DELETE\", options = {\n            endpointStore: {},\n            onDelete: function(id) {},\n            onDeleteComplete: function(id, xhr, isError) {},\n            log: function(str, level) {}\n        };\n        qq.extend(options, o);\n        requester = qq.extend(this, new qq.AjaxRequester({\n            validMethods: [ method ],\n            method: method,\n            successfulResponseCodes: function() {\n                var codes = {};\n                codes[method] = [ 202 ];\n                return codes;\n            }(),\n            contentType: null,\n            endpointStore: options.endpointStore,\n            allowXRequestedWithAndCacheControl: false,\n            cors: {\n                expected: true\n            },\n            log: options.log,\n            onSend: options.onDelete,\n            onComplete: options.onDeleteComplete\n        }));\n        qq.extend(this, {\n            method: method,\n            send: function(id) {\n                options.log(\"Submitting Delete Blob request for \" + id);\n                return requester.initTransport(id).send();\n            }\n        });\n    };\n    qq.azure.PutBlob = function(o) {\n        \"use strict\";\n        var requester, method = \"PUT\", options = {\n            getBlobMetadata: function(id) {},\n            log: function(str, level) {}\n        }, endpoints = {}, promises = {}, endpointHandler = {\n            get: function(id) {\n                return endpoints[id];\n            }\n        };\n        qq.extend(options, o);\n        requester = qq.extend(this, new qq.AjaxRequester({\n            validMethods: [ method ],\n            method: method,\n            successfulResponseCodes: function() {\n                var codes = {};\n                codes[method] = [ 201 ];\n                return codes;\n            }(),\n            contentType: null,\n            customHeaders: function(id) {\n                var params = options.getBlobMetadata(id), headers = qq.azure.util.getParamsAsHeaders(params);\n                headers[\"x-ms-blob-type\"] = \"BlockBlob\";\n                return headers;\n            },\n            endpointStore: endpointHandler,\n            allowXRequestedWithAndCacheControl: false,\n            cors: {\n                expected: true\n            },\n            log: options.log,\n            onComplete: function(id, xhr, isError) {\n                var promise = promises[id];\n                delete endpoints[id];\n                delete promises[id];\n                if (isError) {\n                    promise.failure();\n                } else {\n                    promise.success();\n                }\n            }\n        }));\n        qq.extend(this, {\n            method: method,\n            upload: function(id, xhr, url, file) {\n                var promise = new qq.Promise();\n                options.log(\"Submitting Put Blob request for \" + id);\n                promises[id] = promise;\n                endpoints[id] = url;\n                requester.initTransport(id).withPayload(file).withHeaders({\n                    \"Content-Type\": file.type\n                }).send(xhr);\n                return promise;\n            }\n        });\n    };\n    qq.azure.PutBlock = function(o) {\n        \"use strict\";\n        var requester, method = \"PUT\", blockIdEntries = {}, promises = {}, options = {\n            log: function(str, level) {}\n        }, endpoints = {}, endpointHandler = {\n            get: function(id) {\n                return endpoints[id];\n            }\n        };\n        qq.extend(options, o);\n        requester = qq.extend(this, new qq.AjaxRequester({\n            validMethods: [ method ],\n            method: method,\n            successfulResponseCodes: function() {\n                var codes = {};\n                codes[method] = [ 201 ];\n                return codes;\n            }(),\n            contentType: null,\n            endpointStore: endpointHandler,\n            allowXRequestedWithAndCacheControl: false,\n            cors: {\n                expected: true\n            },\n            log: options.log,\n            onComplete: function(id, xhr, isError) {\n                var promise = promises[id], blockIdEntry = blockIdEntries[id];\n                delete endpoints[id];\n                delete promises[id];\n                delete blockIdEntries[id];\n                if (isError) {\n                    promise.failure();\n                } else {\n                    promise.success(blockIdEntry);\n                }\n            }\n        }));\n        function createBlockId(partNum) {\n            var digits = 5, zeros = new Array(digits + 1).join(\"0\"), paddedPartNum = (zeros + partNum).slice(-digits);\n            return btoa(paddedPartNum);\n        }\n        qq.extend(this, {\n            method: method,\n            upload: function(id, xhr, sasUri, partNum, blob) {\n                var promise = new qq.Promise(), blockId = createBlockId(partNum);\n                promises[id] = promise;\n                options.log(qq.format(\"Submitting Put Block request for {} = part {}\", id, partNum));\n                endpoints[id] = qq.format(\"{}&comp=block&blockid={}\", sasUri, encodeURIComponent(blockId));\n                blockIdEntries[id] = {\n                    part: partNum,\n                    id: blockId\n                };\n                requester.initTransport(id).withPayload(blob).send(xhr);\n                return promise;\n            }\n        });\n    };\n    qq.azure.PutBlockList = function(o) {\n        \"use strict\";\n        var requester, method = \"PUT\", promises = {}, options = {\n            getBlobMetadata: function(id) {},\n            log: function(str, level) {}\n        }, endpoints = {}, endpointHandler = {\n            get: function(id) {\n                return endpoints[id];\n            }\n        };\n        qq.extend(options, o);\n        requester = qq.extend(this, new qq.AjaxRequester({\n            validMethods: [ method ],\n            method: method,\n            successfulResponseCodes: function() {\n                var codes = {};\n                codes[method] = [ 201 ];\n                return codes;\n            }(),\n            customHeaders: function(id) {\n                var params = options.getBlobMetadata(id);\n                return qq.azure.util.getParamsAsHeaders(params);\n            },\n            contentType: \"text/plain\",\n            endpointStore: endpointHandler,\n            allowXRequestedWithAndCacheControl: false,\n            cors: {\n                expected: true\n            },\n            log: options.log,\n            onSend: function() {},\n            onComplete: function(id, xhr, isError) {\n                var promise = promises[id];\n                delete endpoints[id];\n                delete promises[id];\n                if (isError) {\n                    promise.failure(xhr);\n                } else {\n                    promise.success(xhr);\n                }\n            }\n        }));\n        function createRequestBody(blockIdEntries) {\n            var doc = document.implementation.createDocument(null, \"BlockList\", null);\n            blockIdEntries.sort(function(a, b) {\n                return a.part - b.part;\n            });\n            qq.each(blockIdEntries, function(idx, blockIdEntry) {\n                var latestEl = doc.createElement(\"Latest\"), latestTextEl = doc.createTextNode(blockIdEntry.id);\n                latestEl.appendChild(latestTextEl);\n                qq(doc).children()[0].appendChild(latestEl);\n            });\n            return new XMLSerializer().serializeToString(doc);\n        }\n        qq.extend(this, {\n            method: method,\n            send: function(id, sasUri, blockIdEntries, fileMimeType, registerXhrCallback) {\n                var promise = new qq.Promise(), blockIdsXml = createRequestBody(blockIdEntries), xhr;\n                promises[id] = promise;\n                options.log(qq.format(\"Submitting Put Block List request for {}\", id));\n                endpoints[id] = qq.format(\"{}&comp=blocklist\", sasUri);\n                xhr = requester.initTransport(id).withPayload(blockIdsXml).withHeaders({\n                    \"x-ms-blob-content-type\": fileMimeType\n                }).send();\n                registerXhrCallback(xhr);\n                return promise;\n            }\n        });\n    };\n    (function() {\n        \"use strict\";\n        qq.azure.FineUploader = function(o) {\n            var options = {\n                failedUploadTextDisplay: {\n                    mode: \"custom\"\n                }\n            };\n            qq.extend(options, o, true);\n            qq.FineUploader.call(this, options, \"azure\");\n        };\n        qq.extend(qq.azure.FineUploader.prototype, qq.azure.FineUploaderBasic.prototype);\n        qq.extend(qq.azure.FineUploader.prototype, qq.uiPublicApi);\n        qq.extend(qq.azure.FineUploader.prototype, qq.uiPrivateApi);\n        qq.extend(qq.azure.FineUploader.prototype, {});\n    })();\n})(window);\n//# sourceMappingURL=all.fine-uploader.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fine-uploader/all.fine-uploader/all.fine-uploader.js\n// module id = 70\n// module chunks = 1","\"use strict\";\n\nmodule.exports = require(\"../all.fine-uploader/all.fine-uploader\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fine-uploader/lib/all.js\n// module id = 71\n// module chunks = 1","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 76\n// module chunks = 1","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\tvar sourceMap = obj.sourceMap;\n\n\tif (media) {\n\t\tstyleElement.setAttribute(\"media\", media);\n\t}\n\n\tif (sourceMap) {\n\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t// this makes source maps inside style tags work properly in Chrome\n\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader/addStyles.js\n// module id = 77\n// module chunks = 1"],"sourceRoot":""}